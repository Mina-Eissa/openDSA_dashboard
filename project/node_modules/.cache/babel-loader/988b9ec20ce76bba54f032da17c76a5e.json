{"ast":null,"code":"/**\r\n * This function determines if j is a leaf of the ith row subtree.\r\n * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)\r\n *\r\n * @param {Number}  i               The ith row subtree\r\n * @param {Number}  j               The node to test\r\n * @param {Array}   w               The workspace array\r\n * @param {Number}  first           The index offset within the workspace for the first array\r\n * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array\r\n * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array\r\n * @param {Number}  ancestor        The index offset within the workspace for the ancestor array\r\n *\r\n * @return {Object}\r\n *\r\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n */\nexport function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {\n  var s, sparent; // our result\n\n  var jleaf = 0;\n  var q; // check j is a leaf\n\n  if (i <= j || w[first + j] <= w[maxfirst + i]) {\n    return -1;\n  } // update max first[j] seen so far\n\n\n  w[maxfirst + i] = w[first + j]; // jprev = previous leaf of ith subtree\n\n  var jprev = w[prevleaf + i];\n  w[prevleaf + i] = j; // check j is first or subsequent leaf\n\n  if (jprev === -1) {\n    // 1st leaf, q = root of ith subtree\n    jleaf = 1;\n    q = i;\n  } else {\n    // update jleaf\n    jleaf = 2; // q = least common ancester (jprev,j)\n\n    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {\n      ;\n    }\n\n    for (s = jprev; s !== q; s = sparent) {\n      // path compression\n      sparent = w[ancestor + s];\n      w[ancestor + s] = q;\n    }\n  }\n\n  return {\n    jleaf,\n    q\n  };\n}","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js"],"names":["csLeaf","i","j","w","first","maxfirst","prevleaf","ancestor","s","sparent","jleaf","q","jprev"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,MAAT,CAAgBC,CAAhB,EAAmBC,CAAnB,EAAsBC,CAAtB,EAAyBC,KAAzB,EAAgCC,QAAhC,EAA0CC,QAA1C,EAAoDC,QAApD,EAA8D;AACnE,MAAIC,CAAJ,EAAOC,OAAP,CADmE,CAGnE;;AACA,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAIC,CAAJ,CALmE,CAOnE;;AACA,MAAIV,CAAC,IAAIC,CAAL,IAAUC,CAAC,CAACC,KAAK,GAAGF,CAAT,CAAD,IAAgBC,CAAC,CAACE,QAAQ,GAAGJ,CAAZ,CAA/B,EAA+C;AAC7C,WAAO,CAAC,CAAR;AACD,GAVkE,CAWnE;;;AACAE,EAAAA,CAAC,CAACE,QAAQ,GAAGJ,CAAZ,CAAD,GAAkBE,CAAC,CAACC,KAAK,GAAGF,CAAT,CAAnB,CAZmE,CAanE;;AACA,MAAIU,KAAK,GAAGT,CAAC,CAACG,QAAQ,GAAGL,CAAZ,CAAb;AACAE,EAAAA,CAAC,CAACG,QAAQ,GAAGL,CAAZ,CAAD,GAAkBC,CAAlB,CAfmE,CAiBnE;;AACA,MAAIU,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB;AACAF,IAAAA,KAAK,GAAG,CAAR;AACAC,IAAAA,CAAC,GAAGV,CAAJ;AACD,GAJD,MAIO;AACL;AACAS,IAAAA,KAAK,GAAG,CAAR,CAFK,CAGL;;AACA,SAAKC,CAAC,GAAGC,KAAT,EAAgBD,CAAC,KAAKR,CAAC,CAACI,QAAQ,GAAGI,CAAZ,CAAvB,EAAuCA,CAAC,GAAGR,CAAC,CAACI,QAAQ,GAAGI,CAAZ,CAA5C,EAA4D;AAC1D;AACD;;AACD,SAAKH,CAAC,GAAGI,KAAT,EAAgBJ,CAAC,KAAKG,CAAtB,EAAyBH,CAAC,GAAGC,OAA7B,EAAsC;AACpC;AACAA,MAAAA,OAAO,GAAGN,CAAC,CAACI,QAAQ,GAAGC,CAAZ,CAAX;AACAL,MAAAA,CAAC,CAACI,QAAQ,GAAGC,CAAZ,CAAD,GAAkBG,CAAlB;AACD;AACF;;AACD,SAAO;AACLD,IAAAA,KADK;AAELC,IAAAA;AAFK,GAAP;AAID","sourcesContent":["/**\r\n * This function determines if j is a leaf of the ith row subtree.\r\n * Consider A(i,j), node j in ith row subtree and return lca(jprev,j)\r\n *\r\n * @param {Number}  i               The ith row subtree\r\n * @param {Number}  j               The node to test\r\n * @param {Array}   w               The workspace array\r\n * @param {Number}  first           The index offset within the workspace for the first array\r\n * @param {Number}  maxfirst        The index offset within the workspace for the maxfirst array\r\n * @param {Number}  prevleaf        The index offset within the workspace for the prevleaf array\r\n * @param {Number}  ancestor        The index offset within the workspace for the ancestor array\r\n *\r\n * @return {Object}\r\n *\r\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n */\r\nexport function csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor) {\r\n  var s, sparent;\r\n\r\n  // our result\r\n  var jleaf = 0;\r\n  var q;\r\n\r\n  // check j is a leaf\r\n  if (i <= j || w[first + j] <= w[maxfirst + i]) {\r\n    return -1;\r\n  }\r\n  // update max first[j] seen so far\r\n  w[maxfirst + i] = w[first + j];\r\n  // jprev = previous leaf of ith subtree\r\n  var jprev = w[prevleaf + i];\r\n  w[prevleaf + i] = j;\r\n\r\n  // check j is first or subsequent leaf\r\n  if (jprev === -1) {\r\n    // 1st leaf, q = root of ith subtree\r\n    jleaf = 1;\r\n    q = i;\r\n  } else {\r\n    // update jleaf\r\n    jleaf = 2;\r\n    // q = least common ancester (jprev,j)\r\n    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {\r\n      ;\r\n    }\r\n    for (s = jprev; s !== q; s = sparent) {\r\n      // path compression\r\n      sparent = w[ancestor + s];\r\n      w[ancestor + s] = q;\r\n    }\r\n  }\r\n  return {\r\n    jleaf,\r\n    q\r\n  };\r\n}"]},"metadata":{},"sourceType":"module"}