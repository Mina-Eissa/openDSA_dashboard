{"ast":null,"code":"import { isInteger } from '../../utils/number.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'rationalize';\nvar dependencies = ['config', 'typed', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'parse', 'simplifyConstant', 'simplifyCore', 'simplify', '?bignumber', '?fraction', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode', 'ParenthesisNode'];\nexport var createRationalize = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    typed,\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    parse,\n    simplifyConstant,\n    simplifyCore,\n    simplify,\n    fraction,\n    bignumber,\n    mathWithTransform,\n    matrix,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    SymbolNode,\n    ParenthesisNode\n  } = _ref;\n  /**\r\n   * Transform a rationalizable expression in a rational fraction.\r\n   * If rational fraction is one variable polynomial then converts\r\n   * the numerator and denominator in canonical form, with decreasing\r\n   * exponents, returning the coefficients of numerator.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     rationalize(expr)\r\n   *     rationalize(expr, detailed)\r\n   *     rationalize(expr, scope)\r\n   *     rationalize(expr, scope, detailed)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.rationalize('sin(x)+y')\r\n   *                   //  Error: There is an unsolved function call\r\n   *     math.rationalize('2x/y - y/(x+1)')\r\n   *                   // (2*x^2-y^2+2*x)/(x*y+y)\r\n   *     math.rationalize('(2x+1)^6')\r\n   *                   // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1\r\n   *     math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')\r\n   *                   // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)\r\n   *     math.rationalize('x/(1-x)/(x-2)/(x-3)/(x-4) + 2x/ ( (1-2x)/(2-3x) )/ ((3-4x)/(4-5x) )') =\r\n   *                   // (-30*x^7+344*x^6-1506*x^5+3200*x^4-3472*x^3+1846*x^2-381*x)/\r\n   *                   //     (-8*x^6+90*x^5-383*x^4+780*x^3-797*x^2+390*x-72)\r\n   *\r\n   *     math.rationalize('x+x+x+y',{y:1}) // 3*x+1\r\n   *     math.rationalize('x+x+x+y',{})    // 3*x+y\r\n   *\r\n   *     const ret = math.rationalize('x+x+x+y',{},true)\r\n   *                   // ret.expression=3*x+y, ret.variables = [\"x\",\"y\"]\r\n   *     const ret = math.rationalize('-2+5x^2',{},true)\r\n   *                   // ret.expression=5*x^2-2, ret.variables = [\"x\"], ret.coefficients=[-2,0,5]\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplify\r\n   *\r\n   * @param  {Node|string} expr    The expression to check if is a polynomial expression\r\n   * @param  {Object|boolean}      optional scope of expression or true for already evaluated rational expression at input\r\n   * @param  {Boolean}  detailed   optional True if return an object, false if return expression node (default)\r\n   *\r\n   * @return {Object | Node}    The rational polynomial of `expr` or an object\r\n   *            `{expression, numerator, denominator, variables, coefficients}`, where\r\n   *              `expression` is a `Node` with the node simplified expression,\r\n   *              `numerator` is a `Node` with the simplified numerator of expression,\r\n   *              `denominator` is a `Node` or `boolean` with the simplified denominator or `false` (if there is no denominator),\r\n   *              `variables` is an array with variable names,\r\n   *              and `coefficients` is an array with coefficients of numerator sorted by increased exponent\r\n   *           {Expression Node}  node simplified expression\r\n   *\r\n   */\n\n  function _rationalize(expr) {\n    var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var detailed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var setRules = rulesRationalize(); // Rules for change polynomial in near canonical form\n\n    var polyRet = polynomial(expr, scope, true, setRules.firstRules); // Check if expression is a rationalizable polynomial\n\n    var nVars = polyRet.variables.length;\n    var noExactFractions = {\n      exactFractions: false\n    };\n    var withExactFractions = {\n      exactFractions: true\n    };\n    expr = polyRet.expression;\n\n    if (nVars >= 1) {\n      // If expression in not a constant\n      expr = expandPower(expr); // First expand power of polynomials (cannot be made from rules!)\n\n      var sBefore; // Previous expression\n\n      var rules;\n      var eDistrDiv = true;\n      var redoInic = false; // Apply the initial rules, including succ div rules:\n\n      expr = simplify(expr, setRules.firstRules, {}, noExactFractions);\n      var s;\n\n      while (true) {\n        // Alternate applying successive division rules and distr.div.rules\n        // until there are no more changes:\n        rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;\n        expr = simplify(expr, rules, {}, withExactFractions);\n        eDistrDiv = !eDistrDiv; // Swap between Distr.Div and Succ. Div. Rules\n\n        s = expr.toString();\n\n        if (s === sBefore) {\n          break; // No changes : end of the loop\n        }\n\n        redoInic = true;\n        sBefore = s;\n      }\n\n      if (redoInic) {\n        // Apply first rules again without succ div rules (if there are changes)\n        expr = simplify(expr, setRules.firstRulesAgain, {}, noExactFractions);\n      } // Apply final rules:\n\n\n      expr = simplify(expr, setRules.finalRules, {}, noExactFractions);\n    } // NVars >= 1\n\n\n    var coefficients = [];\n    var retRationalize = {};\n\n    if (expr.type === 'OperatorNode' && expr.isBinary() && expr.op === '/') {\n      // Separate numerator from denominator\n      if (nVars === 1) {\n        expr.args[0] = polyToCanonical(expr.args[0], coefficients);\n        expr.args[1] = polyToCanonical(expr.args[1]);\n      }\n\n      if (detailed) {\n        retRationalize.numerator = expr.args[0];\n        retRationalize.denominator = expr.args[1];\n      }\n    } else {\n      if (nVars === 1) {\n        expr = polyToCanonical(expr, coefficients);\n      }\n\n      if (detailed) {\n        retRationalize.numerator = expr;\n        retRationalize.denominator = null;\n      }\n    } // nVars\n\n\n    if (!detailed) return expr;\n    retRationalize.coefficients = coefficients;\n    retRationalize.variables = polyRet.variables;\n    retRationalize.expression = expr;\n    return retRationalize;\n  }\n\n  return typed(name, {\n    Node: _rationalize,\n    'Node, boolean': (expr, detailed) => _rationalize(expr, {}, detailed),\n    'Node, Object': _rationalize,\n    'Node, Object, boolean': _rationalize\n  }); // end of typed rationalize\n\n  /**\r\n   *  Function to simplify an expression using an optional scope and\r\n   *  return it if the expression is a polynomial expression, i.e.\r\n   *  an expression with one or more variables and the operators\r\n   *  +, -, *, and ^, where the exponent can only be a positive integer.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     polynomial(expr,scope,extended, rules)\r\n   *\r\n   * @param  {Node | string} expr     The expression to simplify and check if is polynomial expression\r\n   * @param  {object} scope           Optional scope for expression simplification\r\n   * @param  {boolean} extended       Optional. Default is false. When true allows divide operator.\r\n   * @param  {array}  rules           Optional. Default is no rule.\r\n   *\r\n   *\r\n   * @return {Object}\r\n   *            {Object} node:   node simplified expression\r\n   *            {Array}  variables:  variable names\r\n   */\n\n  function polynomial(expr, scope, extended, rules) {\n    var variables = [];\n    var node = simplify(expr, rules, scope, {\n      exactFractions: false\n    }); // Resolves any variables and functions with all defined parameters\n\n    extended = !!extended;\n    var oper = '+-*' + (extended ? '/' : '');\n    recPoly(node);\n    var retFunc = {};\n    retFunc.expression = node;\n    retFunc.variables = variables;\n    return retFunc; // -------------------------------------------------------------------------------------------------------\n\n    /**\r\n     *  Function to simplify an expression using an optional scope and\r\n     *  return it if the expression is a polynomial expression, i.e.\r\n     *  an expression with one or more variables and the operators\r\n     *  +, -, *, and ^, where the exponent can only be a positive integer.\r\n     *\r\n     * Syntax:\r\n     *\r\n     *     recPoly(node)\r\n     *\r\n     *\r\n     * @param  {Node} node               The current sub tree expression in recursion\r\n     *\r\n     * @return                           nothing, throw an exception if error\r\n     */\n\n    function recPoly(node) {\n      var tp = node.type; // node type\n\n      if (tp === 'FunctionNode') {\n        // No function call in polynomial expression\n        throw new Error('There is an unsolved function call');\n      } else if (tp === 'OperatorNode') {\n        if (node.op === '^') {\n          // TODO: handle negative exponents like in '1/x^(-2)'\n          if (node.args[1].type !== 'ConstantNode' || !isInteger(parseFloat(node.args[1].value))) {\n            throw new Error('There is a non-integer exponent');\n          } else {\n            recPoly(node.args[0]);\n          }\n        } else {\n          if (oper.indexOf(node.op) === -1) {\n            throw new Error('Operator ' + node.op + ' invalid in polynomial expression');\n          }\n\n          for (var i = 0; i < node.args.length; i++) {\n            recPoly(node.args[i]);\n          }\n        } // type of operator\n\n      } else if (tp === 'SymbolNode') {\n        var _name = node.name; // variable name\n\n        var pos = variables.indexOf(_name);\n\n        if (pos === -1) {\n          // new variable in expression\n          variables.push(_name);\n        }\n      } else if (tp === 'ParenthesisNode') {\n        recPoly(node.content);\n      } else if (tp !== 'ConstantNode') {\n        throw new Error('type ' + tp + ' is not allowed in polynomial expression');\n      }\n    } // end of recPoly\n\n  } // end of polynomial\n  // ---------------------------------------------------------------------------------------\n\n  /**\r\n   * Return a rule set to rationalize an polynomial expression in rationalize\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     rulesRationalize()\r\n   *\r\n   * @return {array}        rule set to rationalize an polynomial expression\r\n   */\n\n\n  function rulesRationalize() {\n    var oldRules = [simplifyCore, // sCore\n    {\n      l: 'n+n',\n      r: '2*n'\n    }, {\n      l: 'n+-n',\n      r: '0'\n    }, simplifyConstant, // sConstant\n    {\n      l: 'n*(n1^-1)',\n      r: 'n/n1'\n    }, {\n      l: 'n*n1^-n2',\n      r: 'n/n1^n2'\n    }, {\n      l: 'n1^-1',\n      r: '1/n1'\n    }, {\n      l: 'n*(n1/n2)',\n      r: '(n*n1)/n2'\n    }, {\n      l: '1*n',\n      r: 'n'\n    }];\n    var rulesFirst = [{\n      l: '(-n1)/(-n2)',\n      r: 'n1/n2'\n    }, // Unary division\n    {\n      l: '(-n1)*(-n2)',\n      r: 'n1*n2'\n    }, // Unary multiplication\n    {\n      l: 'n1--n2',\n      r: 'n1+n2'\n    }, // '--' elimination\n    {\n      l: 'n1-n2',\n      r: 'n1+(-n2)'\n    }, // Subtraction turn into add with unï¿½ry minus\n    {\n      l: '(n1+n2)*n3',\n      r: '(n1*n3 + n2*n3)'\n    }, // Distributive 1\n    {\n      l: 'n1*(n2+n3)',\n      r: '(n1*n2+n1*n3)'\n    }, // Distributive 2\n    {\n      l: 'c1*n + c2*n',\n      r: '(c1+c2)*n'\n    }, // Joining constants\n    {\n      l: 'c1*n + n',\n      r: '(c1+1)*n'\n    }, // Joining constants\n    {\n      l: 'c1*n - c2*n',\n      r: '(c1-c2)*n'\n    }, // Joining constants\n    {\n      l: 'c1*n - n',\n      r: '(c1-1)*n'\n    }, // Joining constants\n    {\n      l: 'v/c',\n      r: '(1/c)*v'\n    }, // variable/constant (new!)\n    {\n      l: 'v/-c',\n      r: '-(1/c)*v'\n    }, // variable/constant (new!)\n    {\n      l: '-v*-c',\n      r: 'c*v'\n    }, // Inversion constant and variable 1\n    {\n      l: '-v*c',\n      r: '-c*v'\n    }, // Inversion constant and variable 2\n    {\n      l: 'v*-c',\n      r: '-c*v'\n    }, // Inversion constant and variable 3\n    {\n      l: 'v*c',\n      r: 'c*v'\n    }, // Inversion constant and variable 4\n    {\n      l: '-(-n1*n2)',\n      r: '(n1*n2)'\n    }, // Unary propagation\n    {\n      l: '-(n1*n2)',\n      r: '(-n1*n2)'\n    }, // Unary propagation\n    {\n      l: '-(-n1+n2)',\n      r: '(n1-n2)'\n    }, // Unary propagation\n    {\n      l: '-(n1+n2)',\n      r: '(-n1-n2)'\n    }, // Unary propagation\n    {\n      l: '(n1^n2)^n3',\n      r: '(n1^(n2*n3))'\n    }, // Power to Power\n    {\n      l: '-(-n1/n2)',\n      r: '(n1/n2)'\n    }, // Division and Unary\n    {\n      l: '-(n1/n2)',\n      r: '(-n1/n2)'\n    }]; // Divisao and Unary\n\n    var rulesDistrDiv = [{\n      l: '(n1/n2 + n3/n4)',\n      r: '((n1*n4 + n3*n2)/(n2*n4))'\n    }, // Sum of fractions\n    {\n      l: '(n1/n2 + n3)',\n      r: '((n1 + n3*n2)/n2)'\n    }, // Sum fraction with number 1\n    {\n      l: '(n1 + n2/n3)',\n      r: '((n1*n3 + n2)/n3)'\n    }]; // Sum fraction with number 1\n\n    var rulesSucDiv = [{\n      l: '(n1/(n2/n3))',\n      r: '((n1*n3)/n2)'\n    }, // Division simplification\n    {\n      l: '(n1/n2/n3)',\n      r: '(n1/(n2*n3))'\n    }];\n    var setRules = {}; // rules set in 4 steps.\n    // All rules => infinite loop\n    // setRules.allRules =oldRules.concat(rulesFirst,rulesDistrDiv,rulesSucDiv)\n\n    setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv); // First rule set\n\n    setRules.distrDivRules = rulesDistrDiv; // Just distr. div. rules\n\n    setRules.sucDivRules = rulesSucDiv; // Jus succ. div. rules\n\n    setRules.firstRulesAgain = oldRules.concat(rulesFirst); // Last rules set without succ. div.\n    // Division simplification\n    // Second rule set.\n    // There is no aggregate expression with parentesis, but the only variable can be scattered.\n\n    setRules.finalRules = [simplifyCore, // simplify.rules[0]\n    {\n      l: 'n*-n',\n      r: '-n^2'\n    }, // Joining multiply with power 1\n    {\n      l: 'n*n',\n      r: 'n^2'\n    }, // Joining multiply with power 2\n    simplifyConstant, // simplify.rules[14] old 3rd index in oldRules\n    {\n      l: 'n*-n^n1',\n      r: '-n^(n1+1)'\n    }, // Joining multiply with power 3\n    {\n      l: 'n*n^n1',\n      r: 'n^(n1+1)'\n    }, // Joining multiply with power 4\n    {\n      l: 'n^n1*-n^n2',\n      r: '-n^(n1+n2)'\n    }, // Joining multiply with power 5\n    {\n      l: 'n^n1*n^n2',\n      r: 'n^(n1+n2)'\n    }, // Joining multiply with power 6\n    {\n      l: 'n^n1*-n',\n      r: '-n^(n1+1)'\n    }, // Joining multiply with power 7\n    {\n      l: 'n^n1*n',\n      r: 'n^(n1+1)'\n    }, // Joining multiply with power 8\n    {\n      l: 'n^n1/-n',\n      r: '-n^(n1-1)'\n    }, // Joining multiply with power 8\n    {\n      l: 'n^n1/n',\n      r: 'n^(n1-1)'\n    }, // Joining division with power 1\n    {\n      l: 'n/-n^n1',\n      r: '-n^(1-n1)'\n    }, // Joining division with power 2\n    {\n      l: 'n/n^n1',\n      r: 'n^(1-n1)'\n    }, // Joining division with power 3\n    {\n      l: 'n^n1/-n^n2',\n      r: 'n^(n1-n2)'\n    }, // Joining division with power 4\n    {\n      l: 'n^n1/n^n2',\n      r: 'n^(n1-n2)'\n    }, // Joining division with power 5\n    {\n      l: 'n1+(-n2*n3)',\n      r: 'n1-n2*n3'\n    }, // Solving useless parenthesis 1\n    {\n      l: 'v*(-c)',\n      r: '-c*v'\n    }, // Solving useless unary 2\n    {\n      l: 'n1+-n2',\n      r: 'n1-n2'\n    }, // Solving +- together (new!)\n    {\n      l: 'v*c',\n      r: 'c*v'\n    }, // inversion constant with variable\n    {\n      l: '(n1^n2)^n3',\n      r: '(n1^(n2*n3))'\n    } // Power to Power\n    ];\n    return setRules;\n  } // End rulesRationalize\n  // ---------------------------------------------------------------------------------------\n\n  /**\r\n   *  Expand recursively a tree node for handling with expressions with exponents\r\n   *  (it's not for constants, symbols or functions with exponents)\r\n   *  PS: The other parameters are internal for recursion\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     expandPower(node)\r\n   *\r\n   * @param  {Node} node         Current expression node\r\n   * @param  {node} parent       Parent current node inside the recursion\r\n   * @param  (int}               Parent number of chid inside the rercursion\r\n   *\r\n   * @return {node}        node expression with all powers expanded.\r\n   */\n\n\n  function expandPower(node, parent, indParent) {\n    var tp = node.type;\n    var internal = arguments.length > 1; // TRUE in internal calls\n\n    if (tp === 'OperatorNode' && node.isBinary()) {\n      var does = false;\n      var val;\n\n      if (node.op === '^') {\n        // First operator: Parenthesis or UnaryMinus\n        if ((node.args[0].type === 'ParenthesisNode' || node.args[0].type === 'OperatorNode') && node.args[1].type === 'ConstantNode') {\n          // Second operator: Constant\n          val = parseFloat(node.args[1].value);\n          does = val >= 2 && isInteger(val);\n        }\n      }\n\n      if (does) {\n        // Exponent >= 2\n        // Before:\n        //            operator A --> Subtree\n        // parent pow\n        //            constant\n        //\n        if (val > 2) {\n          // Exponent > 2,\n          // AFTER:  (exponent > 2)\n          //             operator A --> Subtree\n          // parent  *\n          //                 deep clone (operator A --> Subtree\n          //             pow\n          //                 constant - 1\n          //\n          var nEsqTopo = node.args[0];\n          var nDirTopo = new OperatorNode('^', 'pow', [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);\n          node = new OperatorNode('*', 'multiply', [nEsqTopo, nDirTopo]);\n        } else {\n          // Expo = 2 - no power\n          // AFTER:  (exponent =  2)\n          //             operator A --> Subtree\n          // parent   oper\n          //            deep clone (operator A --> Subtree)\n          //\n          node = new OperatorNode('*', 'multiply', [node.args[0], node.args[0].cloneDeep()]);\n        }\n\n        if (internal) {\n          // Change parent references in internal recursive calls\n          if (indParent === 'content') {\n            parent.content = node;\n          } else {\n            parent.args[indParent] = node;\n          }\n        }\n      } // does\n\n    } // binary OperatorNode\n\n\n    if (tp === 'ParenthesisNode') {\n      // Recursion\n      expandPower(node.content, node, 'content');\n    } else if (tp !== 'ConstantNode' && tp !== 'SymbolNode') {\n      for (var i = 0; i < node.args.length; i++) {\n        expandPower(node.args[i], node, i);\n      }\n    }\n\n    if (!internal) {\n      // return the root node\n      return node;\n    }\n  } // End expandPower\n  // ---------------------------------------------------------------------------------------\n\n  /**\r\n   * Auxilary function for rationalize\r\n   * Convert near canonical polynomial in one variable in a canonical polynomial\r\n   * with one term for each exponent in decreasing order\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     polyToCanonical(node [, coefficients])\r\n   *\r\n   * @param  {Node | string} expr       The near canonical polynomial expression to convert in a a canonical polynomial expression\r\n   *\r\n   *        The string or tree expression needs to be at below syntax, with free spaces:\r\n   *         (  (^(-)? | [+-]? )cte (*)? var (^expo)?  | cte )+\r\n   *       Where 'var' is one variable with any valid name\r\n   *             'cte' are real numeric constants with any value. It can be omitted if equal than 1\r\n   *             'expo' are integers greater than 0. It can be omitted if equal than 1.\r\n   *\r\n   * @param  {array}   coefficients             Optional returns coefficients sorted by increased exponent\r\n   *\r\n   *\r\n   * @return {node}        new node tree with one variable polynomial or string error.\r\n   */\n\n\n  function polyToCanonical(node, coefficients) {\n    if (coefficients === undefined) {\n      coefficients = [];\n    } // coefficients.\n\n\n    coefficients[0] = 0; // index is the exponent\n\n    var o = {};\n    o.cte = 1;\n    o.oper = '+'; // fire: mark with * or ^ when finds * or ^ down tree, reset to \"\" with + and -.\n    //       It is used to deduce the exponent: 1 for *, 0 for \"\".\n\n    o.fire = '';\n    var maxExpo = 0; // maximum exponent\n\n    var varname = ''; // variable name\n\n    recurPol(node, null, o);\n    maxExpo = coefficients.length - 1;\n    var first = true;\n    var no;\n\n    for (var i = maxExpo; i >= 0; i--) {\n      if (coefficients[i] === 0) continue;\n      var n1 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));\n      var op = coefficients[i] < 0 ? '-' : '+';\n\n      if (i > 0) {\n        // Is not a constant without variable\n        var n2 = new SymbolNode(varname);\n\n        if (i > 1) {\n          var n3 = new ConstantNode(i);\n          n2 = new OperatorNode('^', 'pow', [n2, n3]);\n        }\n\n        if (coefficients[i] === -1 && first) {\n          n1 = new OperatorNode('-', 'unaryMinus', [n2]);\n        } else if (Math.abs(coefficients[i]) === 1) {\n          n1 = n2;\n        } else {\n          n1 = new OperatorNode('*', 'multiply', [n1, n2]);\n        }\n      }\n\n      if (first) {\n        no = n1;\n      } else if (op === '+') {\n        no = new OperatorNode('+', 'add', [no, n1]);\n      } else {\n        no = new OperatorNode('-', 'subtract', [no, n1]);\n      }\n\n      first = false;\n    } // for\n\n\n    if (first) {\n      return new ConstantNode(0);\n    } else {\n      return no;\n    }\n    /**\r\n     * Recursive auxilary function inside polyToCanonical for\r\n     * converting expression in canonical form\r\n     *\r\n     * Syntax:\r\n     *\r\n     *     recurPol(node, noPai, obj)\r\n     *\r\n     * @param  {Node} node        The current subpolynomial expression\r\n     * @param  {Node | Null}  noPai   The current parent node\r\n     * @param  {object}    obj        Object with many internal flags\r\n     *\r\n     * @return {}                    No return. If error, throws an exception\r\n     */\n\n\n    function recurPol(node, noPai, o) {\n      var tp = node.type;\n\n      if (tp === 'FunctionNode') {\n        // ***** FunctionName *****\n        // No function call in polynomial expression\n        throw new Error('There is an unsolved function call');\n      } else if (tp === 'OperatorNode') {\n        // ***** OperatorName *****\n        if ('+-*^'.indexOf(node.op) === -1) throw new Error('Operator ' + node.op + ' invalid');\n\n        if (noPai !== null) {\n          // -(unary),^  : children of *,+,-\n          if ((node.fn === 'unaryMinus' || node.fn === 'pow') && noPai.fn !== 'add' && noPai.fn !== 'subtract' && noPai.fn !== 'multiply') {\n            throw new Error('Invalid ' + node.op + ' placing');\n          } // -,+,* : children of +,-\n\n\n          if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'multiply') && noPai.fn !== 'add' && noPai.fn !== 'subtract') {\n            throw new Error('Invalid ' + node.op + ' placing');\n          } // -,+ : first child\n\n\n          if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'unaryMinus') && o.noFil !== 0) {\n            throw new Error('Invalid ' + node.op + ' placing');\n          }\n        } // Has parent\n        // Firers: ^,*       Old:   ^,&,-(unary): firers\n\n\n        if (node.op === '^' || node.op === '*') {\n          o.fire = node.op;\n        }\n\n        for (var _i = 0; _i < node.args.length; _i++) {\n          // +,-: reset fire\n          if (node.fn === 'unaryMinus') o.oper = '-';\n\n          if (node.op === '+' || node.fn === 'subtract') {\n            o.fire = '';\n            o.cte = 1; // default if there is no constant\n\n            o.oper = _i === 0 ? '+' : node.op;\n          }\n\n          o.noFil = _i; // number of son\n\n          recurPol(node.args[_i], node, o);\n        } // for in children\n\n      } else if (tp === 'SymbolNode') {\n        // ***** SymbolName *****\n        if (node.name !== varname && varname !== '') {\n          throw new Error('There is more than one variable');\n        }\n\n        varname = node.name;\n\n        if (noPai === null) {\n          coefficients[1] = 1;\n          return;\n        } // ^: Symbol is First child\n\n\n        if (noPai.op === '^' && o.noFil !== 0) {\n          throw new Error('In power the variable should be the first parameter');\n        } // *: Symbol is Second child\n\n\n        if (noPai.op === '*' && o.noFil !== 1) {\n          throw new Error('In multiply the variable should be the second parameter');\n        } // Symbol: firers '',* => it means there is no exponent above, so it's 1 (cte * var)\n\n\n        if (o.fire === '' || o.fire === '*') {\n          if (maxExpo < 1) coefficients[1] = 0;\n          coefficients[1] += o.cte * (o.oper === '+' ? 1 : -1);\n          maxExpo = Math.max(1, maxExpo);\n        }\n      } else if (tp === 'ConstantNode') {\n        var valor = parseFloat(node.value);\n\n        if (noPai === null) {\n          coefficients[0] = valor;\n          return;\n        }\n\n        if (noPai.op === '^') {\n          // cte: second  child of power\n          if (o.noFil !== 1) throw new Error('Constant cannot be powered');\n\n          if (!isInteger(valor) || valor <= 0) {\n            throw new Error('Non-integer exponent is not allowed');\n          }\n\n          for (var _i2 = maxExpo + 1; _i2 < valor; _i2++) {\n            coefficients[_i2] = 0;\n          }\n\n          if (valor > maxExpo) coefficients[valor] = 0;\n          coefficients[valor] += o.cte * (o.oper === '+' ? 1 : -1);\n          maxExpo = Math.max(valor, maxExpo);\n          return;\n        }\n\n        o.cte = valor; // Cte: firer '' => There is no exponent and no multiplication, so the exponent is 0.\n\n        if (o.fire === '') {\n          coefficients[0] += o.cte * (o.oper === '+' ? 1 : -1);\n        }\n      } else {\n        throw new Error('Type ' + tp + ' is not allowed');\n      }\n    } // End of recurPol\n\n  } // End of polyToCanonical\n\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/rationalize.js"],"names":["isInteger","factory","name","dependencies","createRationalize","_ref","config","typed","equal","isZero","add","subtract","multiply","divide","pow","parse","simplifyConstant","simplifyCore","simplify","fraction","bignumber","mathWithTransform","matrix","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","SymbolNode","ParenthesisNode","_rationalize","expr","scope","arguments","length","undefined","detailed","setRules","rulesRationalize","polyRet","polynomial","firstRules","nVars","variables","noExactFractions","exactFractions","withExactFractions","expression","expandPower","sBefore","rules","eDistrDiv","redoInic","s","distrDivRules","sucDivRules","toString","firstRulesAgain","finalRules","coefficients","retRationalize","type","isBinary","op","args","polyToCanonical","numerator","denominator","Node","extended","node","oper","recPoly","retFunc","tp","Error","parseFloat","value","indexOf","i","_name","pos","push","content","oldRules","l","r","rulesFirst","rulesDistrDiv","rulesSucDiv","concat","parent","indParent","internal","does","val","nEsqTopo","nDirTopo","cloneDeep","o","cte","fire","maxExpo","varname","recurPol","first","no","n1","Math","abs","n2","n3","noPai","fn","noFil","_i","max","valor","_i2"],"mappings":"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","sourcesContent":["import { isInteger } from '../../utils/number.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'rationalize';\r\nvar dependencies = ['config', 'typed', 'equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'parse', 'simplifyConstant', 'simplifyCore', 'simplify', '?bignumber', '?fraction', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode', 'ParenthesisNode'];\r\nexport var createRationalize = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    config,\r\n    typed,\r\n    equal,\r\n    isZero,\r\n    add,\r\n    subtract,\r\n    multiply,\r\n    divide,\r\n    pow,\r\n    parse,\r\n    simplifyConstant,\r\n    simplifyCore,\r\n    simplify,\r\n    fraction,\r\n    bignumber,\r\n    mathWithTransform,\r\n    matrix,\r\n    AccessorNode,\r\n    ArrayNode,\r\n    ConstantNode,\r\n    FunctionNode,\r\n    IndexNode,\r\n    ObjectNode,\r\n    OperatorNode,\r\n    SymbolNode,\r\n    ParenthesisNode\r\n  } = _ref;\r\n  /**\r\n   * Transform a rationalizable expression in a rational fraction.\r\n   * If rational fraction is one variable polynomial then converts\r\n   * the numerator and denominator in canonical form, with decreasing\r\n   * exponents, returning the coefficients of numerator.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     rationalize(expr)\r\n   *     rationalize(expr, detailed)\r\n   *     rationalize(expr, scope)\r\n   *     rationalize(expr, scope, detailed)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.rationalize('sin(x)+y')\r\n   *                   //  Error: There is an unsolved function call\r\n   *     math.rationalize('2x/y - y/(x+1)')\r\n   *                   // (2*x^2-y^2+2*x)/(x*y+y)\r\n   *     math.rationalize('(2x+1)^6')\r\n   *                   // 64*x^6+192*x^5+240*x^4+160*x^3+60*x^2+12*x+1\r\n   *     math.rationalize('2x/( (2x-1) / (3x+2) ) - 5x/ ( (3x+4) / (2x^2-5) ) + 3')\r\n   *                   // -20*x^4+28*x^3+104*x^2+6*x-12)/(6*x^2+5*x-4)\r\n   *     math.rationalize('x/(1-x)/(x-2)/(x-3)/(x-4) + 2x/ ( (1-2x)/(2-3x) )/ ((3-4x)/(4-5x) )') =\r\n   *                   // (-30*x^7+344*x^6-1506*x^5+3200*x^4-3472*x^3+1846*x^2-381*x)/\r\n   *                   //     (-8*x^6+90*x^5-383*x^4+780*x^3-797*x^2+390*x-72)\r\n   *\r\n   *     math.rationalize('x+x+x+y',{y:1}) // 3*x+1\r\n   *     math.rationalize('x+x+x+y',{})    // 3*x+y\r\n   *\r\n   *     const ret = math.rationalize('x+x+x+y',{},true)\r\n   *                   // ret.expression=3*x+y, ret.variables = [\"x\",\"y\"]\r\n   *     const ret = math.rationalize('-2+5x^2',{},true)\r\n   *                   // ret.expression=5*x^2-2, ret.variables = [\"x\"], ret.coefficients=[-2,0,5]\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplify\r\n   *\r\n   * @param  {Node|string} expr    The expression to check if is a polynomial expression\r\n   * @param  {Object|boolean}      optional scope of expression or true for already evaluated rational expression at input\r\n   * @param  {Boolean}  detailed   optional True if return an object, false if return expression node (default)\r\n   *\r\n   * @return {Object | Node}    The rational polynomial of `expr` or an object\r\n   *            `{expression, numerator, denominator, variables, coefficients}`, where\r\n   *              `expression` is a `Node` with the node simplified expression,\r\n   *              `numerator` is a `Node` with the simplified numerator of expression,\r\n   *              `denominator` is a `Node` or `boolean` with the simplified denominator or `false` (if there is no denominator),\r\n   *              `variables` is an array with variable names,\r\n   *              and `coefficients` is an array with coefficients of numerator sorted by increased exponent\r\n   *           {Expression Node}  node simplified expression\r\n   *\r\n   */\r\n  function _rationalize(expr) {\r\n    var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n    var detailed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n    var setRules = rulesRationalize(); // Rules for change polynomial in near canonical form\r\n    var polyRet = polynomial(expr, scope, true, setRules.firstRules); // Check if expression is a rationalizable polynomial\r\n    var nVars = polyRet.variables.length;\r\n    var noExactFractions = {\r\n      exactFractions: false\r\n    };\r\n    var withExactFractions = {\r\n      exactFractions: true\r\n    };\r\n    expr = polyRet.expression;\r\n    if (nVars >= 1) {\r\n      // If expression in not a constant\r\n      expr = expandPower(expr); // First expand power of polynomials (cannot be made from rules!)\r\n      var sBefore; // Previous expression\r\n      var rules;\r\n      var eDistrDiv = true;\r\n      var redoInic = false;\r\n      // Apply the initial rules, including succ div rules:\r\n      expr = simplify(expr, setRules.firstRules, {}, noExactFractions);\r\n      var s;\r\n      while (true) {\r\n        // Alternate applying successive division rules and distr.div.rules\r\n        // until there are no more changes:\r\n        rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;\r\n        expr = simplify(expr, rules, {}, withExactFractions);\r\n        eDistrDiv = !eDistrDiv; // Swap between Distr.Div and Succ. Div. Rules\r\n\r\n        s = expr.toString();\r\n        if (s === sBefore) {\r\n          break; // No changes : end of the loop\r\n        }\r\n\r\n        redoInic = true;\r\n        sBefore = s;\r\n      }\r\n      if (redoInic) {\r\n        // Apply first rules again without succ div rules (if there are changes)\r\n        expr = simplify(expr, setRules.firstRulesAgain, {}, noExactFractions);\r\n      }\r\n      // Apply final rules:\r\n      expr = simplify(expr, setRules.finalRules, {}, noExactFractions);\r\n    } // NVars >= 1\r\n\r\n    var coefficients = [];\r\n    var retRationalize = {};\r\n    if (expr.type === 'OperatorNode' && expr.isBinary() && expr.op === '/') {\r\n      // Separate numerator from denominator\r\n      if (nVars === 1) {\r\n        expr.args[0] = polyToCanonical(expr.args[0], coefficients);\r\n        expr.args[1] = polyToCanonical(expr.args[1]);\r\n      }\r\n      if (detailed) {\r\n        retRationalize.numerator = expr.args[0];\r\n        retRationalize.denominator = expr.args[1];\r\n      }\r\n    } else {\r\n      if (nVars === 1) {\r\n        expr = polyToCanonical(expr, coefficients);\r\n      }\r\n      if (detailed) {\r\n        retRationalize.numerator = expr;\r\n        retRationalize.denominator = null;\r\n      }\r\n    }\r\n    // nVars\r\n\r\n    if (!detailed) return expr;\r\n    retRationalize.coefficients = coefficients;\r\n    retRationalize.variables = polyRet.variables;\r\n    retRationalize.expression = expr;\r\n    return retRationalize;\r\n  }\r\n  return typed(name, {\r\n    Node: _rationalize,\r\n    'Node, boolean': (expr, detailed) => _rationalize(expr, {}, detailed),\r\n    'Node, Object': _rationalize,\r\n    'Node, Object, boolean': _rationalize\r\n  }); // end of typed rationalize\r\n\r\n  /**\r\n   *  Function to simplify an expression using an optional scope and\r\n   *  return it if the expression is a polynomial expression, i.e.\r\n   *  an expression with one or more variables and the operators\r\n   *  +, -, *, and ^, where the exponent can only be a positive integer.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     polynomial(expr,scope,extended, rules)\r\n   *\r\n   * @param  {Node | string} expr     The expression to simplify and check if is polynomial expression\r\n   * @param  {object} scope           Optional scope for expression simplification\r\n   * @param  {boolean} extended       Optional. Default is false. When true allows divide operator.\r\n   * @param  {array}  rules           Optional. Default is no rule.\r\n   *\r\n   *\r\n   * @return {Object}\r\n   *            {Object} node:   node simplified expression\r\n   *            {Array}  variables:  variable names\r\n   */\r\n  function polynomial(expr, scope, extended, rules) {\r\n    var variables = [];\r\n    var node = simplify(expr, rules, scope, {\r\n      exactFractions: false\r\n    }); // Resolves any variables and functions with all defined parameters\r\n    extended = !!extended;\r\n    var oper = '+-*' + (extended ? '/' : '');\r\n    recPoly(node);\r\n    var retFunc = {};\r\n    retFunc.expression = node;\r\n    retFunc.variables = variables;\r\n    return retFunc;\r\n\r\n    // -------------------------------------------------------------------------------------------------------\r\n\r\n    /**\r\n     *  Function to simplify an expression using an optional scope and\r\n     *  return it if the expression is a polynomial expression, i.e.\r\n     *  an expression with one or more variables and the operators\r\n     *  +, -, *, and ^, where the exponent can only be a positive integer.\r\n     *\r\n     * Syntax:\r\n     *\r\n     *     recPoly(node)\r\n     *\r\n     *\r\n     * @param  {Node} node               The current sub tree expression in recursion\r\n     *\r\n     * @return                           nothing, throw an exception if error\r\n     */\r\n    function recPoly(node) {\r\n      var tp = node.type; // node type\r\n      if (tp === 'FunctionNode') {\r\n        // No function call in polynomial expression\r\n        throw new Error('There is an unsolved function call');\r\n      } else if (tp === 'OperatorNode') {\r\n        if (node.op === '^') {\r\n          // TODO: handle negative exponents like in '1/x^(-2)'\r\n          if (node.args[1].type !== 'ConstantNode' || !isInteger(parseFloat(node.args[1].value))) {\r\n            throw new Error('There is a non-integer exponent');\r\n          } else {\r\n            recPoly(node.args[0]);\r\n          }\r\n        } else {\r\n          if (oper.indexOf(node.op) === -1) {\r\n            throw new Error('Operator ' + node.op + ' invalid in polynomial expression');\r\n          }\r\n          for (var i = 0; i < node.args.length; i++) {\r\n            recPoly(node.args[i]);\r\n          }\r\n        } // type of operator\r\n      } else if (tp === 'SymbolNode') {\r\n        var _name = node.name; // variable name\r\n        var pos = variables.indexOf(_name);\r\n        if (pos === -1) {\r\n          // new variable in expression\r\n          variables.push(_name);\r\n        }\r\n      } else if (tp === 'ParenthesisNode') {\r\n        recPoly(node.content);\r\n      } else if (tp !== 'ConstantNode') {\r\n        throw new Error('type ' + tp + ' is not allowed in polynomial expression');\r\n      }\r\n    } // end of recPoly\r\n  } // end of polynomial\r\n\r\n  // ---------------------------------------------------------------------------------------\r\n  /**\r\n   * Return a rule set to rationalize an polynomial expression in rationalize\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     rulesRationalize()\r\n   *\r\n   * @return {array}        rule set to rationalize an polynomial expression\r\n   */\r\n  function rulesRationalize() {\r\n    var oldRules = [simplifyCore,\r\n    // sCore\r\n    {\r\n      l: 'n+n',\r\n      r: '2*n'\r\n    }, {\r\n      l: 'n+-n',\r\n      r: '0'\r\n    }, simplifyConstant,\r\n    // sConstant\r\n    {\r\n      l: 'n*(n1^-1)',\r\n      r: 'n/n1'\r\n    }, {\r\n      l: 'n*n1^-n2',\r\n      r: 'n/n1^n2'\r\n    }, {\r\n      l: 'n1^-1',\r\n      r: '1/n1'\r\n    }, {\r\n      l: 'n*(n1/n2)',\r\n      r: '(n*n1)/n2'\r\n    }, {\r\n      l: '1*n',\r\n      r: 'n'\r\n    }];\r\n    var rulesFirst = [{\r\n      l: '(-n1)/(-n2)',\r\n      r: 'n1/n2'\r\n    },\r\n    // Unary division\r\n    {\r\n      l: '(-n1)*(-n2)',\r\n      r: 'n1*n2'\r\n    },\r\n    // Unary multiplication\r\n    {\r\n      l: 'n1--n2',\r\n      r: 'n1+n2'\r\n    },\r\n    // '--' elimination\r\n    {\r\n      l: 'n1-n2',\r\n      r: 'n1+(-n2)'\r\n    },\r\n    // Subtraction turn into add with unï¿½ry minus\r\n    {\r\n      l: '(n1+n2)*n3',\r\n      r: '(n1*n3 + n2*n3)'\r\n    },\r\n    // Distributive 1\r\n    {\r\n      l: 'n1*(n2+n3)',\r\n      r: '(n1*n2+n1*n3)'\r\n    },\r\n    // Distributive 2\r\n    {\r\n      l: 'c1*n + c2*n',\r\n      r: '(c1+c2)*n'\r\n    },\r\n    // Joining constants\r\n    {\r\n      l: 'c1*n + n',\r\n      r: '(c1+1)*n'\r\n    },\r\n    // Joining constants\r\n    {\r\n      l: 'c1*n - c2*n',\r\n      r: '(c1-c2)*n'\r\n    },\r\n    // Joining constants\r\n    {\r\n      l: 'c1*n - n',\r\n      r: '(c1-1)*n'\r\n    },\r\n    // Joining constants\r\n    {\r\n      l: 'v/c',\r\n      r: '(1/c)*v'\r\n    },\r\n    // variable/constant (new!)\r\n    {\r\n      l: 'v/-c',\r\n      r: '-(1/c)*v'\r\n    },\r\n    // variable/constant (new!)\r\n    {\r\n      l: '-v*-c',\r\n      r: 'c*v'\r\n    },\r\n    // Inversion constant and variable 1\r\n    {\r\n      l: '-v*c',\r\n      r: '-c*v'\r\n    },\r\n    // Inversion constant and variable 2\r\n    {\r\n      l: 'v*-c',\r\n      r: '-c*v'\r\n    },\r\n    // Inversion constant and variable 3\r\n    {\r\n      l: 'v*c',\r\n      r: 'c*v'\r\n    },\r\n    // Inversion constant and variable 4\r\n    {\r\n      l: '-(-n1*n2)',\r\n      r: '(n1*n2)'\r\n    },\r\n    // Unary propagation\r\n    {\r\n      l: '-(n1*n2)',\r\n      r: '(-n1*n2)'\r\n    },\r\n    // Unary propagation\r\n    {\r\n      l: '-(-n1+n2)',\r\n      r: '(n1-n2)'\r\n    },\r\n    // Unary propagation\r\n    {\r\n      l: '-(n1+n2)',\r\n      r: '(-n1-n2)'\r\n    },\r\n    // Unary propagation\r\n    {\r\n      l: '(n1^n2)^n3',\r\n      r: '(n1^(n2*n3))'\r\n    },\r\n    // Power to Power\r\n    {\r\n      l: '-(-n1/n2)',\r\n      r: '(n1/n2)'\r\n    },\r\n    // Division and Unary\r\n    {\r\n      l: '-(n1/n2)',\r\n      r: '(-n1/n2)'\r\n    }]; // Divisao and Unary\r\n\r\n    var rulesDistrDiv = [{\r\n      l: '(n1/n2 + n3/n4)',\r\n      r: '((n1*n4 + n3*n2)/(n2*n4))'\r\n    },\r\n    // Sum of fractions\r\n    {\r\n      l: '(n1/n2 + n3)',\r\n      r: '((n1 + n3*n2)/n2)'\r\n    },\r\n    // Sum fraction with number 1\r\n    {\r\n      l: '(n1 + n2/n3)',\r\n      r: '((n1*n3 + n2)/n3)'\r\n    }]; // Sum fraction with number 1\r\n\r\n    var rulesSucDiv = [{\r\n      l: '(n1/(n2/n3))',\r\n      r: '((n1*n3)/n2)'\r\n    },\r\n    // Division simplification\r\n    {\r\n      l: '(n1/n2/n3)',\r\n      r: '(n1/(n2*n3))'\r\n    }];\r\n    var setRules = {}; // rules set in 4 steps.\r\n\r\n    // All rules => infinite loop\r\n    // setRules.allRules =oldRules.concat(rulesFirst,rulesDistrDiv,rulesSucDiv)\r\n\r\n    setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv); // First rule set\r\n    setRules.distrDivRules = rulesDistrDiv; // Just distr. div. rules\r\n    setRules.sucDivRules = rulesSucDiv; // Jus succ. div. rules\r\n    setRules.firstRulesAgain = oldRules.concat(rulesFirst); // Last rules set without succ. div.\r\n\r\n    // Division simplification\r\n\r\n    // Second rule set.\r\n    // There is no aggregate expression with parentesis, but the only variable can be scattered.\r\n    setRules.finalRules = [simplifyCore,\r\n    // simplify.rules[0]\r\n    {\r\n      l: 'n*-n',\r\n      r: '-n^2'\r\n    },\r\n    // Joining multiply with power 1\r\n    {\r\n      l: 'n*n',\r\n      r: 'n^2'\r\n    },\r\n    // Joining multiply with power 2\r\n    simplifyConstant,\r\n    // simplify.rules[14] old 3rd index in oldRules\r\n    {\r\n      l: 'n*-n^n1',\r\n      r: '-n^(n1+1)'\r\n    },\r\n    // Joining multiply with power 3\r\n    {\r\n      l: 'n*n^n1',\r\n      r: 'n^(n1+1)'\r\n    },\r\n    // Joining multiply with power 4\r\n    {\r\n      l: 'n^n1*-n^n2',\r\n      r: '-n^(n1+n2)'\r\n    },\r\n    // Joining multiply with power 5\r\n    {\r\n      l: 'n^n1*n^n2',\r\n      r: 'n^(n1+n2)'\r\n    },\r\n    // Joining multiply with power 6\r\n    {\r\n      l: 'n^n1*-n',\r\n      r: '-n^(n1+1)'\r\n    },\r\n    // Joining multiply with power 7\r\n    {\r\n      l: 'n^n1*n',\r\n      r: 'n^(n1+1)'\r\n    },\r\n    // Joining multiply with power 8\r\n    {\r\n      l: 'n^n1/-n',\r\n      r: '-n^(n1-1)'\r\n    },\r\n    // Joining multiply with power 8\r\n    {\r\n      l: 'n^n1/n',\r\n      r: 'n^(n1-1)'\r\n    },\r\n    // Joining division with power 1\r\n    {\r\n      l: 'n/-n^n1',\r\n      r: '-n^(1-n1)'\r\n    },\r\n    // Joining division with power 2\r\n    {\r\n      l: 'n/n^n1',\r\n      r: 'n^(1-n1)'\r\n    },\r\n    // Joining division with power 3\r\n    {\r\n      l: 'n^n1/-n^n2',\r\n      r: 'n^(n1-n2)'\r\n    },\r\n    // Joining division with power 4\r\n    {\r\n      l: 'n^n1/n^n2',\r\n      r: 'n^(n1-n2)'\r\n    },\r\n    // Joining division with power 5\r\n    {\r\n      l: 'n1+(-n2*n3)',\r\n      r: 'n1-n2*n3'\r\n    },\r\n    // Solving useless parenthesis 1\r\n    {\r\n      l: 'v*(-c)',\r\n      r: '-c*v'\r\n    },\r\n    // Solving useless unary 2\r\n    {\r\n      l: 'n1+-n2',\r\n      r: 'n1-n2'\r\n    },\r\n    // Solving +- together (new!)\r\n    {\r\n      l: 'v*c',\r\n      r: 'c*v'\r\n    },\r\n    // inversion constant with variable\r\n    {\r\n      l: '(n1^n2)^n3',\r\n      r: '(n1^(n2*n3))'\r\n    } // Power to Power\r\n    ];\r\n\r\n    return setRules;\r\n  } // End rulesRationalize\r\n\r\n  // ---------------------------------------------------------------------------------------\r\n  /**\r\n   *  Expand recursively a tree node for handling with expressions with exponents\r\n   *  (it's not for constants, symbols or functions with exponents)\r\n   *  PS: The other parameters are internal for recursion\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     expandPower(node)\r\n   *\r\n   * @param  {Node} node         Current expression node\r\n   * @param  {node} parent       Parent current node inside the recursion\r\n   * @param  (int}               Parent number of chid inside the rercursion\r\n   *\r\n   * @return {node}        node expression with all powers expanded.\r\n   */\r\n  function expandPower(node, parent, indParent) {\r\n    var tp = node.type;\r\n    var internal = arguments.length > 1; // TRUE in internal calls\r\n\r\n    if (tp === 'OperatorNode' && node.isBinary()) {\r\n      var does = false;\r\n      var val;\r\n      if (node.op === '^') {\r\n        // First operator: Parenthesis or UnaryMinus\r\n        if ((node.args[0].type === 'ParenthesisNode' || node.args[0].type === 'OperatorNode') && node.args[1].type === 'ConstantNode') {\r\n          // Second operator: Constant\r\n          val = parseFloat(node.args[1].value);\r\n          does = val >= 2 && isInteger(val);\r\n        }\r\n      }\r\n      if (does) {\r\n        // Exponent >= 2\r\n        // Before:\r\n        //            operator A --> Subtree\r\n        // parent pow\r\n        //            constant\r\n        //\r\n        if (val > 2) {\r\n          // Exponent > 2,\r\n          // AFTER:  (exponent > 2)\r\n          //             operator A --> Subtree\r\n          // parent  *\r\n          //                 deep clone (operator A --> Subtree\r\n          //             pow\r\n          //                 constant - 1\r\n          //\r\n          var nEsqTopo = node.args[0];\r\n          var nDirTopo = new OperatorNode('^', 'pow', [node.args[0].cloneDeep(), new ConstantNode(val - 1)]);\r\n          node = new OperatorNode('*', 'multiply', [nEsqTopo, nDirTopo]);\r\n        } else {\r\n          // Expo = 2 - no power\r\n          // AFTER:  (exponent =  2)\r\n          //             operator A --> Subtree\r\n          // parent   oper\r\n          //            deep clone (operator A --> Subtree)\r\n          //\r\n          node = new OperatorNode('*', 'multiply', [node.args[0], node.args[0].cloneDeep()]);\r\n        }\r\n        if (internal) {\r\n          // Change parent references in internal recursive calls\r\n          if (indParent === 'content') {\r\n            parent.content = node;\r\n          } else {\r\n            parent.args[indParent] = node;\r\n          }\r\n        }\r\n      } // does\r\n    } // binary OperatorNode\r\n\r\n    if (tp === 'ParenthesisNode') {\r\n      // Recursion\r\n      expandPower(node.content, node, 'content');\r\n    } else if (tp !== 'ConstantNode' && tp !== 'SymbolNode') {\r\n      for (var i = 0; i < node.args.length; i++) {\r\n        expandPower(node.args[i], node, i);\r\n      }\r\n    }\r\n    if (!internal) {\r\n      // return the root node\r\n      return node;\r\n    }\r\n  } // End expandPower\r\n\r\n  // ---------------------------------------------------------------------------------------\r\n  /**\r\n   * Auxilary function for rationalize\r\n   * Convert near canonical polynomial in one variable in a canonical polynomial\r\n   * with one term for each exponent in decreasing order\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     polyToCanonical(node [, coefficients])\r\n   *\r\n   * @param  {Node | string} expr       The near canonical polynomial expression to convert in a a canonical polynomial expression\r\n   *\r\n   *        The string or tree expression needs to be at below syntax, with free spaces:\r\n   *         (  (^(-)? | [+-]? )cte (*)? var (^expo)?  | cte )+\r\n   *       Where 'var' is one variable with any valid name\r\n   *             'cte' are real numeric constants with any value. It can be omitted if equal than 1\r\n   *             'expo' are integers greater than 0. It can be omitted if equal than 1.\r\n   *\r\n   * @param  {array}   coefficients             Optional returns coefficients sorted by increased exponent\r\n   *\r\n   *\r\n   * @return {node}        new node tree with one variable polynomial or string error.\r\n   */\r\n  function polyToCanonical(node, coefficients) {\r\n    if (coefficients === undefined) {\r\n      coefficients = [];\r\n    } // coefficients.\r\n\r\n    coefficients[0] = 0; // index is the exponent\r\n    var o = {};\r\n    o.cte = 1;\r\n    o.oper = '+';\r\n\r\n    // fire: mark with * or ^ when finds * or ^ down tree, reset to \"\" with + and -.\r\n    //       It is used to deduce the exponent: 1 for *, 0 for \"\".\r\n    o.fire = '';\r\n    var maxExpo = 0; // maximum exponent\r\n    var varname = ''; // variable name\r\n\r\n    recurPol(node, null, o);\r\n    maxExpo = coefficients.length - 1;\r\n    var first = true;\r\n    var no;\r\n    for (var i = maxExpo; i >= 0; i--) {\r\n      if (coefficients[i] === 0) continue;\r\n      var n1 = new ConstantNode(first ? coefficients[i] : Math.abs(coefficients[i]));\r\n      var op = coefficients[i] < 0 ? '-' : '+';\r\n      if (i > 0) {\r\n        // Is not a constant without variable\r\n        var n2 = new SymbolNode(varname);\r\n        if (i > 1) {\r\n          var n3 = new ConstantNode(i);\r\n          n2 = new OperatorNode('^', 'pow', [n2, n3]);\r\n        }\r\n        if (coefficients[i] === -1 && first) {\r\n          n1 = new OperatorNode('-', 'unaryMinus', [n2]);\r\n        } else if (Math.abs(coefficients[i]) === 1) {\r\n          n1 = n2;\r\n        } else {\r\n          n1 = new OperatorNode('*', 'multiply', [n1, n2]);\r\n        }\r\n      }\r\n      if (first) {\r\n        no = n1;\r\n      } else if (op === '+') {\r\n        no = new OperatorNode('+', 'add', [no, n1]);\r\n      } else {\r\n        no = new OperatorNode('-', 'subtract', [no, n1]);\r\n      }\r\n      first = false;\r\n    } // for\r\n\r\n    if (first) {\r\n      return new ConstantNode(0);\r\n    } else {\r\n      return no;\r\n    }\r\n\r\n    /**\r\n     * Recursive auxilary function inside polyToCanonical for\r\n     * converting expression in canonical form\r\n     *\r\n     * Syntax:\r\n     *\r\n     *     recurPol(node, noPai, obj)\r\n     *\r\n     * @param  {Node} node        The current subpolynomial expression\r\n     * @param  {Node | Null}  noPai   The current parent node\r\n     * @param  {object}    obj        Object with many internal flags\r\n     *\r\n     * @return {}                    No return. If error, throws an exception\r\n     */\r\n    function recurPol(node, noPai, o) {\r\n      var tp = node.type;\r\n      if (tp === 'FunctionNode') {\r\n        // ***** FunctionName *****\r\n        // No function call in polynomial expression\r\n        throw new Error('There is an unsolved function call');\r\n      } else if (tp === 'OperatorNode') {\r\n        // ***** OperatorName *****\r\n        if ('+-*^'.indexOf(node.op) === -1) throw new Error('Operator ' + node.op + ' invalid');\r\n        if (noPai !== null) {\r\n          // -(unary),^  : children of *,+,-\r\n          if ((node.fn === 'unaryMinus' || node.fn === 'pow') && noPai.fn !== 'add' && noPai.fn !== 'subtract' && noPai.fn !== 'multiply') {\r\n            throw new Error('Invalid ' + node.op + ' placing');\r\n          }\r\n\r\n          // -,+,* : children of +,-\r\n          if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'multiply') && noPai.fn !== 'add' && noPai.fn !== 'subtract') {\r\n            throw new Error('Invalid ' + node.op + ' placing');\r\n          }\r\n\r\n          // -,+ : first child\r\n          if ((node.fn === 'subtract' || node.fn === 'add' || node.fn === 'unaryMinus') && o.noFil !== 0) {\r\n            throw new Error('Invalid ' + node.op + ' placing');\r\n          }\r\n        } // Has parent\r\n\r\n        // Firers: ^,*       Old:   ^,&,-(unary): firers\r\n        if (node.op === '^' || node.op === '*') {\r\n          o.fire = node.op;\r\n        }\r\n        for (var _i = 0; _i < node.args.length; _i++) {\r\n          // +,-: reset fire\r\n          if (node.fn === 'unaryMinus') o.oper = '-';\r\n          if (node.op === '+' || node.fn === 'subtract') {\r\n            o.fire = '';\r\n            o.cte = 1; // default if there is no constant\r\n            o.oper = _i === 0 ? '+' : node.op;\r\n          }\r\n          o.noFil = _i; // number of son\r\n          recurPol(node.args[_i], node, o);\r\n        } // for in children\r\n      } else if (tp === 'SymbolNode') {\r\n        // ***** SymbolName *****\r\n        if (node.name !== varname && varname !== '') {\r\n          throw new Error('There is more than one variable');\r\n        }\r\n        varname = node.name;\r\n        if (noPai === null) {\r\n          coefficients[1] = 1;\r\n          return;\r\n        }\r\n\r\n        // ^: Symbol is First child\r\n        if (noPai.op === '^' && o.noFil !== 0) {\r\n          throw new Error('In power the variable should be the first parameter');\r\n        }\r\n\r\n        // *: Symbol is Second child\r\n        if (noPai.op === '*' && o.noFil !== 1) {\r\n          throw new Error('In multiply the variable should be the second parameter');\r\n        }\r\n\r\n        // Symbol: firers '',* => it means there is no exponent above, so it's 1 (cte * var)\r\n        if (o.fire === '' || o.fire === '*') {\r\n          if (maxExpo < 1) coefficients[1] = 0;\r\n          coefficients[1] += o.cte * (o.oper === '+' ? 1 : -1);\r\n          maxExpo = Math.max(1, maxExpo);\r\n        }\r\n      } else if (tp === 'ConstantNode') {\r\n        var valor = parseFloat(node.value);\r\n        if (noPai === null) {\r\n          coefficients[0] = valor;\r\n          return;\r\n        }\r\n        if (noPai.op === '^') {\r\n          // cte: second  child of power\r\n          if (o.noFil !== 1) throw new Error('Constant cannot be powered');\r\n          if (!isInteger(valor) || valor <= 0) {\r\n            throw new Error('Non-integer exponent is not allowed');\r\n          }\r\n          for (var _i2 = maxExpo + 1; _i2 < valor; _i2++) {\r\n            coefficients[_i2] = 0;\r\n          }\r\n          if (valor > maxExpo) coefficients[valor] = 0;\r\n          coefficients[valor] += o.cte * (o.oper === '+' ? 1 : -1);\r\n          maxExpo = Math.max(valor, maxExpo);\r\n          return;\r\n        }\r\n        o.cte = valor;\r\n\r\n        // Cte: firer '' => There is no exponent and no multiplication, so the exponent is 0.\r\n        if (o.fire === '') {\r\n          coefficients[0] += o.cte * (o.oper === '+' ? 1 : -1);\r\n        }\r\n      } else {\r\n        throw new Error('Type ' + tp + ' is not allowed');\r\n      }\r\n    } // End of recurPol\r\n  } // End of polyToCanonical\r\n});"]},"metadata":{},"sourceType":"module"}