{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-inferrable-types */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable jsdoc/require-returns */\nimport { withInRange, getPoint, drawSymbol } from '../../common/utils/helper';\nimport { Size, PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { markerAnimate, appendChildElement, animateRedrawElement } from '../../common/utils/helper';\nimport { pointRender } from '../../common/model/constants';\n/**\r\n * `BubbleSeries` module is used to render the bubble series.\r\n */\n\nvar BubbleSeries =\n/** @class */\nfunction () {\n  function BubbleSeries() {}\n  /**\r\n   * Render the Bubble series.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  BubbleSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n    var marker = series.marker;\n    var visiblePoints = series.points;\n    var shapeOption;\n    var argsData; //let bubbleMode: RadiusMode = bubbleOptions.radiusMode;\n\n    var segmentRadius;\n    var radius;\n    var value = Math.max(series.chart.initialClipRect.height, series.chart.initialClipRect.width);\n    var percentChange = value / 100;\n    var maxRadius = series.maxRadius * percentChange;\n    var minRadius = series.minRadius * percentChange;\n    var maximumSize = null;\n    var maxValue = null;\n    var element;\n    var startLocation;\n    var redraw = series.chart.redraw;\n\n    if (series.maxRadius === null || series.minRadius === null) {\n      for (var _i = 0, _a = series.chart.visibleSeries; _i < _a.length; _i++) {\n        var value_1 = _a[_i];\n\n        if (value_1.type === 'Bubble' && value_1.visible === true && (value_1.maxRadius === null || value_1.minRadius === null)) {\n          maximumSize = value_1.sizeMax > maximumSize ? value_1.sizeMax : maximumSize;\n        }\n      }\n\n      maxValue = value / 5 / 2;\n      minRadius = maxRadius = 1;\n      radius = maxValue * maxRadius;\n    } else {\n      maximumSize = series.sizeMax;\n      radius = maxRadius - minRadius;\n    }\n\n    for (var _b = 0, visiblePoints_1 = visiblePoints; _b < visiblePoints_1.length; _b++) {\n      var bubblePoint = visiblePoints_1[_b];\n      bubblePoint.symbolLocations = [];\n      bubblePoint.regions = [];\n\n      if (bubblePoint.visible && withInRange(visiblePoints[bubblePoint.index - 1], bubblePoint, visiblePoints[bubblePoint.index + 1], series)) {\n        if (series.maxRadius === null || series.minRadius === null) {\n          segmentRadius = radius * Math.abs(+bubblePoint.size / maximumSize);\n        } else {\n          segmentRadius = minRadius + radius * Math.abs(+bubblePoint.size / maximumSize);\n        }\n\n        segmentRadius = segmentRadius || minRadius;\n        argsData = {\n          cancel: false,\n          name: pointRender,\n          series: series,\n          point: bubblePoint,\n          fill: series.setPointColor(bubblePoint, series.interior),\n          border: series.setBorderColor(bubblePoint, {\n            width: series.border.width,\n            color: series.border.color\n          }),\n          height: 2 * segmentRadius,\n          width: 2 * segmentRadius\n        };\n        series.chart.trigger(pointRender, argsData);\n\n        if (!argsData.cancel) {\n          bubblePoint.symbolLocations.push(getPoint(bubblePoint.xValue, bubblePoint.yValue, xAxis, yAxis, isInverted));\n          bubblePoint.color = argsData.fill;\n          shapeOption = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + bubblePoint.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, null);\n          element = drawSymbol(bubblePoint.symbolLocations[0], 'Circle', new Size(argsData.width, argsData.height), marker.imageUrl, shapeOption, bubblePoint.x.toString() + ':' + bubblePoint.yValue.toString(), series.chart.svgRenderer, series.clipRect);\n          appendChildElement(false, series.seriesElement, element, redraw);\n          bubblePoint.regions.push(new Rect(bubblePoint.symbolLocations[0].x - segmentRadius, bubblePoint.symbolLocations[0].y - segmentRadius, 2 * segmentRadius, 2 * segmentRadius));\n          bubblePoint.marker = {\n            border: argsData.border,\n            fill: argsData.fill,\n            height: argsData.height,\n            visible: true,\n            shape: 'Circle',\n            width: argsData.width\n          };\n          startLocation = redraw ? bubblePoint.symbolLocations[0] : null;\n\n          if (redraw) {\n            animateRedrawElement(element, 300, startLocation, bubblePoint.symbolLocations[0], 'cx', 'cy');\n          }\n        } else {\n          bubblePoint.marker = {\n            visible: false\n          };\n        }\n      }\n    }\n  };\n  /**\r\n   * To destroy the Bubble.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  BubbleSeries.prototype.destroy = function () {\n    /**\r\n     * Destroy method calling here\r\n     */\n  };\n  /**\r\n   * Get module name.\r\n   */\n\n\n  BubbleSeries.prototype.getModuleName = function () {\n    /**\r\n     * Returns the module name of the series\r\n     */\n    return 'BubbleSeries';\n  };\n  /**\r\n   * Animates the series.\r\n   *\r\n   * @param  {Series} series - Defines the series to animate.\r\n   * @returns {void}\r\n   */\n\n\n  BubbleSeries.prototype.doAnimation = function (series) {\n    var duration = series.animation.duration;\n    var delay = series.animation.delay;\n    var rectElements = series.seriesElement.childNodes;\n    var count = 1;\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var bubblePoint = _a[_i];\n\n      if (!bubblePoint.symbolLocations.length) {\n        continue;\n      }\n\n      markerAnimate(rectElements[count], delay, duration, series, bubblePoint.index, bubblePoint.symbolLocations[0], false);\n      count++;\n    }\n  };\n\n  return BubbleSeries;\n}();\n\nexport { BubbleSeries };","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/chart/series/bubble-series.js"],"names":["withInRange","getPoint","drawSymbol","Size","PathOption","Rect","markerAnimate","appendChildElement","animateRedrawElement","pointRender","BubbleSeries","prototype","render","series","xAxis","yAxis","isInverted","marker","visiblePoints","points","shapeOption","argsData","segmentRadius","radius","value","Math","max","chart","initialClipRect","height","width","percentChange","maxRadius","minRadius","maximumSize","maxValue","element","startLocation","redraw","_i","_a","visibleSeries","length","value_1","type","visible","sizeMax","_b","visiblePoints_1","bubblePoint","symbolLocations","regions","index","abs","size","cancel","name","point","fill","setPointColor","interior","border","setBorderColor","color","trigger","push","xValue","yValue","id","opacity","imageUrl","x","toString","svgRenderer","clipRect","seriesElement","y","shape","destroy","getModuleName","doAnimation","duration","animation","delay","rectElements","childNodes","count"],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-inferrable-types */\r\n/* eslint-disable valid-jsdoc */\r\n/* eslint-disable jsdoc/require-returns */\r\nimport { withInRange, getPoint, drawSymbol } from '../../common/utils/helper';\r\nimport { Size, PathOption, Rect } from '@syncfusion/ej2-svg-base';\r\nimport { markerAnimate, appendChildElement, animateRedrawElement } from '../../common/utils/helper';\r\nimport { pointRender } from '../../common/model/constants';\r\n/**\r\n * `BubbleSeries` module is used to render the bubble series.\r\n */\r\nvar BubbleSeries = /** @class */ (function () {\r\n    function BubbleSeries() {\r\n    }\r\n    /**\r\n     * Render the Bubble series.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    BubbleSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\r\n        var marker = series.marker;\r\n        var visiblePoints = series.points;\r\n        var shapeOption;\r\n        var argsData;\r\n        //let bubbleMode: RadiusMode = bubbleOptions.radiusMode;\r\n        var segmentRadius;\r\n        var radius;\r\n        var value = Math.max(series.chart.initialClipRect.height, series.chart.initialClipRect.width);\r\n        var percentChange = value / 100;\r\n        var maxRadius = series.maxRadius * percentChange;\r\n        var minRadius = series.minRadius * percentChange;\r\n        var maximumSize = null;\r\n        var maxValue = null;\r\n        var element;\r\n        var startLocation;\r\n        var redraw = series.chart.redraw;\r\n        if ((series.maxRadius === null || series.minRadius === null)) {\r\n            for (var _i = 0, _a = series.chart.visibleSeries; _i < _a.length; _i++) {\r\n                var value_1 = _a[_i];\r\n                if (value_1.type === 'Bubble' && value_1.visible === true && (value_1.maxRadius === null || value_1.minRadius === null)) {\r\n                    maximumSize = value_1.sizeMax > maximumSize ? value_1.sizeMax : maximumSize;\r\n                }\r\n            }\r\n            maxValue = (value / 5) / 2;\r\n            minRadius = maxRadius = 1;\r\n            radius = maxValue * maxRadius;\r\n        }\r\n        else {\r\n            maximumSize = series.sizeMax;\r\n            radius = maxRadius - minRadius;\r\n        }\r\n        for (var _b = 0, visiblePoints_1 = visiblePoints; _b < visiblePoints_1.length; _b++) {\r\n            var bubblePoint = visiblePoints_1[_b];\r\n            bubblePoint.symbolLocations = [];\r\n            bubblePoint.regions = [];\r\n            if (bubblePoint.visible &&\r\n                withInRange(visiblePoints[bubblePoint.index - 1], bubblePoint, visiblePoints[bubblePoint.index + 1], series)) {\r\n                if ((series.maxRadius === null || series.minRadius === null)) {\r\n                    segmentRadius = radius * Math.abs(+bubblePoint.size / maximumSize);\r\n                }\r\n                else {\r\n                    segmentRadius = minRadius + radius * Math.abs(+bubblePoint.size / maximumSize);\r\n                }\r\n                segmentRadius = segmentRadius || minRadius;\r\n                argsData = {\r\n                    cancel: false, name: pointRender, series: series, point: bubblePoint,\r\n                    fill: series.setPointColor(bubblePoint, series.interior),\r\n                    border: series.setBorderColor(bubblePoint, { width: series.border.width, color: series.border.color }),\r\n                    height: 2 * segmentRadius, width: 2 * segmentRadius\r\n                };\r\n                series.chart.trigger(pointRender, argsData);\r\n                if (!argsData.cancel) {\r\n                    bubblePoint.symbolLocations.push(getPoint(bubblePoint.xValue, bubblePoint.yValue, xAxis, yAxis, isInverted));\r\n                    bubblePoint.color = argsData.fill;\r\n                    shapeOption = new PathOption(series.chart.element.id + '_Series_' + series.index + '_Point_' + bubblePoint.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, null);\r\n                    element = drawSymbol(bubblePoint.symbolLocations[0], 'Circle', new Size(argsData.width, argsData.height), marker.imageUrl, shapeOption, bubblePoint.x.toString() + ':' + bubblePoint.yValue.toString(), series.chart.svgRenderer, series.clipRect);\r\n                    appendChildElement(false, series.seriesElement, element, redraw);\r\n                    bubblePoint.regions.push(new Rect(bubblePoint.symbolLocations[0].x - segmentRadius, bubblePoint.symbolLocations[0].y - segmentRadius, 2 * segmentRadius, 2 * segmentRadius));\r\n                    bubblePoint.marker = {\r\n                        border: argsData.border, fill: argsData.fill,\r\n                        height: argsData.height, visible: true,\r\n                        shape: 'Circle', width: argsData.width\r\n                    };\r\n                    startLocation = redraw ? bubblePoint.symbolLocations[0] : null;\r\n                    if (redraw) {\r\n                        animateRedrawElement(element, 300, startLocation, bubblePoint.symbolLocations[0], 'cx', 'cy');\r\n                    }\r\n                }\r\n                else {\r\n                    bubblePoint.marker = { visible: false };\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * To destroy the Bubble.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    BubbleSeries.prototype.destroy = function () {\r\n        /**\r\n         * Destroy method calling here\r\n         */\r\n    };\r\n    /**\r\n     * Get module name.\r\n     */\r\n    BubbleSeries.prototype.getModuleName = function () {\r\n        /**\r\n         * Returns the module name of the series\r\n         */\r\n        return 'BubbleSeries';\r\n    };\r\n    /**\r\n     * Animates the series.\r\n     *\r\n     * @param  {Series} series - Defines the series to animate.\r\n     * @returns {void}\r\n     */\r\n    BubbleSeries.prototype.doAnimation = function (series) {\r\n        var duration = series.animation.duration;\r\n        var delay = series.animation.delay;\r\n        var rectElements = series.seriesElement.childNodes;\r\n        var count = 1;\r\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\r\n            var bubblePoint = _a[_i];\r\n            if (!bubblePoint.symbolLocations.length) {\r\n                continue;\r\n            }\r\n            markerAnimate(rectElements[count], delay, duration, series, bubblePoint.index, bubblePoint.symbolLocations[0], false);\r\n            count++;\r\n        }\r\n    };\r\n    return BubbleSeries;\r\n}());\r\nexport { BubbleSeries };\r\n"]},"metadata":{},"sourceType":"module"}