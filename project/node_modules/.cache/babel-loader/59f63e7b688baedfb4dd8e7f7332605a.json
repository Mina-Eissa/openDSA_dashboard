{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { isMatrix } from '../../utils/is.js';\nimport { arraySize } from '../../utils/array.js';\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\nimport { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js';\nvar name = 'multiply';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar', 'dot'];\nexport var createMultiply = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    addScalar,\n    multiplyScalar,\n    equalScalar,\n    dot\n  } = _ref;\n  var matAlgo11xS0s = createMatAlgo11xS0s({\n    typed,\n    equalScalar\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed\n  });\n\n  function _validateMatrixDimensions(size1, size2) {\n    // check left operand dimensions\n    switch (size1.length) {\n      case 1:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Vector x Vector\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');\n            }\n\n            break;\n\n          case 2:\n            // Vector x Matrix\n            if (size1[0] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');\n            }\n\n            break;\n\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n\n        break;\n\n      case 2:\n        // check size2\n        switch (size2.length) {\n          case 1:\n            // Matrix x Vector\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');\n            }\n\n            break;\n\n          case 2:\n            // Matrix x Matrix\n            if (size1[1] !== size2[0]) {\n              // throw error\n              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');\n            }\n\n            break;\n\n          default:\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\n        }\n\n        break;\n\n      default:\n        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');\n    }\n  }\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Dense Vector   (N)\r\n   * @param {Matrix} b            Dense Vector   (N)\r\n   *\r\n   * @return {number}             Scalar value\r\n   */\n\n\n  function _multiplyVectorVector(a, b, n) {\n    // check empty vector\n    if (n === 0) {\n      throw new Error('Cannot multiply two empty vectors');\n    }\n\n    return dot(a, b);\n  }\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Dense Vector   (M)\r\n   * @param {Matrix} b            Matrix         (MxN)\r\n   *\r\n   * @return {Matrix}             Dense Vector   (N)\r\n   */\n\n\n  function _multiplyVectorMatrix(a, b) {\n    // process storage\n    if (b.storage() !== 'dense') {\n      throw new Error('Support for SparseMatrix not implemented');\n    }\n\n    return _multiplyVectorDenseMatrix(a, b);\n  }\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Dense Vector   (M)\r\n   * @param {Matrix} b            Dense Matrix   (MxN)\r\n   *\r\n   * @return {Matrix}             Dense Vector   (N)\r\n   */\n\n\n  function _multiplyVectorDenseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype; // rows & columns\n\n    var alength = asize[0];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix columns\n\n    for (var j = 0; j < bcolumns; j++) {\n      // sum (do not initialize it with zero)\n      var sum = mf(adata[0], bdata[0][j]); // loop vector\n\n      for (var i = 1; i < alength; i++) {\n        // multiply & accumulate\n        sum = af(sum, mf(adata[i], bdata[i][j]));\n      }\n\n      c[j] = sum;\n    } // return matrix\n\n\n    return a.createDenseMatrix({\n      data: c,\n      size: [bcolumns],\n      datatype: dt\n    });\n  }\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Matrix         (MxN)\r\n   * @param {Matrix} b            Dense Vector   (N)\r\n   *\r\n   * @return {Matrix}             Dense Vector   (M)\r\n   */\n\n\n  var _multiplyMatrixVector = typed('_multiplyMatrixVector', {\n    'DenseMatrix, any': _multiplyDenseMatrixVector,\n    'SparseMatrix, any': _multiplySparseMatrixVector\n  });\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Matrix         (MxN)\r\n   * @param {Matrix} b            Matrix         (NxC)\r\n   *\r\n   * @return {Matrix}             Matrix         (MxC)\r\n   */\n\n\n  var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {\n    'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,\n    'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,\n    'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,\n    'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix\n  });\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            DenseMatrix  (MxN)\r\n   * @param {Matrix} b            Dense Vector (N)\r\n   *\r\n   * @return {Matrix}             Dense Vector (M)\r\n   */\n\n\n  function _multiplyDenseMatrixVector(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = asize[0];\n    var acolumns = asize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix a rows\n\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i]; // sum (do not initialize it with zero)\n\n      var sum = mf(row[0], bdata[0]); // loop matrix a columns\n\n      for (var j = 1; j < acolumns; j++) {\n        // multiply & accumulate\n        sum = af(sum, mf(row[j], bdata[j]));\n      }\n\n      c[i] = sum;\n    } // return matrix\n\n\n    return a.createDenseMatrix({\n      data: c,\n      size: [arows],\n      datatype: dt\n    });\n  }\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            DenseMatrix    (MxN)\r\n   * @param {Matrix} b            DenseMatrix    (NxC)\r\n   *\r\n   * @return {Matrix}             DenseMatrix    (MxC)\r\n   */\n\n\n  function _multiplyDenseMatrixDenseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b dense\n\n    var bdata = b._data;\n    var bsize = b._size;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = asize[0];\n    var acolumns = asize[1];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var c = []; // loop matrix a rows\n\n    for (var i = 0; i < arows; i++) {\n      // current row\n      var row = adata[i]; // initialize row array\n\n      c[i] = []; // loop matrix b columns\n\n      for (var j = 0; j < bcolumns; j++) {\n        // sum (avoid initializing sum to zero)\n        var sum = mf(row[0], bdata[0][j]); // loop matrix a columns\n\n        for (var x = 1; x < acolumns; x++) {\n          // multiply & accumulate\n          sum = af(sum, mf(row[x], bdata[x][j]));\n        }\n\n        c[i][j] = sum;\n      }\n    } // return matrix\n\n\n    return a.createDenseMatrix({\n      data: c,\n      size: [arows, bcolumns],\n      datatype: dt\n    });\n  }\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            DenseMatrix    (MxN)\r\n   * @param {Matrix} b            SparseMatrix   (NxC)\r\n   *\r\n   * @return {Matrix}             SparseMatrix   (MxC)\r\n   */\n\n\n  function _multiplyDenseMatrixSparseMatrix(a, b) {\n    // a dense\n    var adata = a._data;\n    var asize = a._size;\n    var adt = a._datatype; // b sparse\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bsize = b._size;\n    var bdt = b._datatype; // validate b matrix\n\n    if (!bvalues) {\n      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');\n    } // rows & columns\n\n\n    var arows = asize[0];\n    var bcolumns = bsize[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // result\n\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = b.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // indeces in column jb\n\n      var kb0 = bptr[jb];\n      var kb1 = bptr[jb + 1]; // do not process column jb if no data exists\n\n      if (kb1 > kb0) {\n        // last row mark processed\n        var last = 0; // loop a rows\n\n        for (var i = 0; i < arows; i++) {\n          // column mark\n          var mark = i + 1; // C[i, jb]\n\n          var cij = void 0; // values in b column j\n\n          for (var kb = kb0; kb < kb1; kb++) {\n            // row\n            var ib = bindex[kb]; // check value has been initialized\n\n            if (last !== mark) {\n              // first value in column jb\n              cij = mf(adata[i][ib], bvalues[kb]); // update mark\n\n              last = mark;\n            } else {\n              // accumulate value\n              cij = af(cij, mf(adata[i][ib], bvalues[kb]));\n            }\n          } // check column has been processed and value != 0\n\n\n          if (last === mark && !eq(cij, zero)) {\n            // push row & value\n            cindex.push(i);\n            cvalues.push(cij);\n          }\n        }\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            SparseMatrix    (MxN)\r\n   * @param {Matrix} b            Dense Vector (N)\r\n   *\r\n   * @return {Matrix}             SparseMatrix    (M, 1)\r\n   */\n\n\n  function _multiplySparseMatrixVector(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // validate a matrix\n\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    } // b dense\n\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var brows = b._size[0]; // result\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // workspace\n\n\n    var x = []; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // update ptr\n\n    cptr[0] = 0; // rows in b\n\n    for (var ib = 0; ib < brows; ib++) {\n      // b[ib]\n      var vbi = bdata[ib]; // check b[ib] != 0, avoid loops\n\n      if (!eq(vbi, zero)) {\n        // A values & index in ib column\n        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n          // a row\n          var ia = aindex[ka]; // check value exists in current j\n\n          if (!w[ia]) {\n            // ia is new entry in j\n            w[ia] = true; // add i to pattern of C\n\n            cindex.push(ia); // x(ia) = A\n\n            x[ia] = mf(vbi, avalues[ka]);\n          } else {\n            // i exists in C already\n            x[ia] = af(x[ia], mf(vbi, avalues[ka]));\n          }\n        }\n      }\n    } // copy values from x to column jb of c\n\n\n    for (var p1 = cindex.length, p = 0; p < p1; p++) {\n      // row\n      var ic = cindex[p]; // copy value\n\n      cvalues[p] = x[ic];\n    } // update ptr\n\n\n    cptr[1] = cindex.length; // return sparse matrix\n\n    return a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, 1],\n      datatype: dt\n    });\n  }\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            SparseMatrix      (MxN)\r\n   * @param {Matrix} b            DenseMatrix       (NxC)\r\n   *\r\n   * @return {Matrix}             SparseMatrix      (MxC)\r\n   */\n\n\n  function _multiplySparseMatrixDenseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // validate a matrix\n\n    if (!avalues) {\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\n    } // b dense\n\n\n    var bdata = b._data;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var brows = b._size[0];\n    var bcolumns = b._size[1]; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // equalScalar signature to use\n\n    var eq = equalScalar; // zero value\n\n    var zero = 0; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n      eq = typed.find(equalScalar, [dt, dt]); // convert 0 to the same datatype\n\n      zero = typed.convert(0, dt);\n    } // result\n\n\n    var cvalues = [];\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // workspace\n\n    var x = []; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // mark in workspace for current column\n\n      var mark = jb + 1; // rows in jb\n\n      for (var ib = 0; ib < brows; ib++) {\n        // b[ib, jb]\n        var vbij = bdata[ib][jb]; // check b[ib, jb] != 0, avoid loops\n\n        if (!eq(vbij, zero)) {\n          // A values & index in ib column\n          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // a row\n            var ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia); // x(ia) = A\n\n              x[ia] = mf(vbij, avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(vbij, avalues[ka]));\n            }\n          }\n        }\n      } // copy values from x to column jb of c\n\n\n      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n        // row\n        var ic = cindex[p]; // copy value\n\n        cvalues[p] = x[ic];\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            SparseMatrix      (MxN)\r\n   * @param {Matrix} b            SparseMatrix      (NxC)\r\n   *\r\n   * @return {Matrix}             SparseMatrix      (MxC)\r\n   */\n\n\n  function _multiplySparseMatrixSparseMatrix(a, b) {\n    // a sparse\n    var avalues = a._values;\n    var aindex = a._index;\n    var aptr = a._ptr;\n    var adt = a._datatype; // b sparse\n\n    var bvalues = b._values;\n    var bindex = b._index;\n    var bptr = b._ptr;\n    var bdt = b._datatype; // rows & columns\n\n    var arows = a._size[0];\n    var bcolumns = b._size[1]; // flag indicating both matrices (a & b) contain data\n\n    var values = avalues && bvalues; // datatype\n\n    var dt; // addScalar signature to use\n\n    var af = addScalar; // multiplyScalar signature to use\n\n    var mf = multiplyScalar; // process data types\n\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\n      // datatype\n      dt = adt; // find signatures that matches (dt, dt)\n\n      af = typed.find(addScalar, [dt, dt]);\n      mf = typed.find(multiplyScalar, [dt, dt]);\n    } // result\n\n\n    var cvalues = values ? [] : undefined;\n    var cindex = [];\n    var cptr = []; // c matrix\n\n    var c = a.createSparseMatrix({\n      values: cvalues,\n      index: cindex,\n      ptr: cptr,\n      size: [arows, bcolumns],\n      datatype: dt\n    }); // workspace\n\n    var x = values ? [] : undefined; // vector with marks indicating a value x[i] exists in a given column\n\n    var w = []; // variables\n\n    var ka, ka0, ka1, kb, kb0, kb1, ia, ib; // loop b columns\n\n    for (var jb = 0; jb < bcolumns; jb++) {\n      // update ptr\n      cptr[jb] = cindex.length; // mark in workspace for current column\n\n      var mark = jb + 1; // B values & index in j\n\n      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {\n        // b row\n        ib = bindex[kb]; // check we need to process values\n\n        if (values) {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia); // x(ia) = A\n\n              x[ia] = mf(bvalues[kb], avalues[ka]);\n            } else {\n              // i exists in C already\n              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));\n            }\n          }\n        } else {\n          // loop values in a[:,ib]\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\n            // row\n            ia = aindex[ka]; // check value exists in current j\n\n            if (w[ia] !== mark) {\n              // ia is new entry in j\n              w[ia] = mark; // add i to pattern of C\n\n              cindex.push(ia);\n            }\n          }\n        }\n      } // check we need to process matrix values (pattern matrix)\n\n\n      if (values) {\n        // copy values from x to column jb of c\n        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\n          // row\n          var ic = cindex[p]; // copy value\n\n          cvalues[p] = x[ic];\n        }\n      }\n    } // update ptr\n\n\n    cptr[bcolumns] = cindex.length; // return sparse matrix\n\n    return c;\n  }\n  /**\r\n   * Multiply two or more values, `x * y`.\r\n   * For matrices, the matrix product is calculated.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.multiply(x, y)\r\n   *    math.multiply(x, y, z, ...)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.multiply(4, 5.2)        // returns number 20.8\r\n   *    math.multiply(2, 3, 4)       // returns number 24\r\n   *\r\n   *    const a = math.complex(2, 3)\r\n   *    const b = math.complex(4, 1)\r\n   *    math.multiply(a, b)          // returns Complex 5 + 14i\r\n   *\r\n   *    const c = [[1, 2], [4, 3]]\r\n   *    const d = [[1, 2, 3], [3, -4, 7]]\r\n   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]\r\n   *\r\n   *    const e = math.unit('2.1 km')\r\n   *    math.multiply(3, e)          // returns Unit 6.3 km\r\n   *\r\n   * See also:\r\n   *\r\n   *    divide, prod, cross, dot\r\n   *\r\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply\r\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply\r\n   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`\r\n   */\n\n\n  return typed(name, multiplyScalar, {\n    // we extend the signatures of multiplyScalar with signatures dealing with matrices\n    'Array, Array': typed.referTo('Matrix, Matrix', selfMM => (x, y) => {\n      // check dimensions\n      _validateMatrixDimensions(arraySize(x), arraySize(y)); // use dense matrix implementation\n\n\n      var m = selfMM(matrix(x), matrix(y)); // return array or scalar\n\n      return isMatrix(m) ? m.valueOf() : m;\n    }),\n    'Matrix, Matrix': function MatrixMatrix(x, y) {\n      // dimensions\n      var xsize = x.size();\n      var ysize = y.size(); // check dimensions\n\n      _validateMatrixDimensions(xsize, ysize); // process dimensions\n\n\n      if (xsize.length === 1) {\n        // process y dimensions\n        if (ysize.length === 1) {\n          // Vector * Vector\n          return _multiplyVectorVector(x, y, xsize[0]);\n        } // Vector * Matrix\n\n\n        return _multiplyVectorMatrix(x, y);\n      } // process y dimensions\n\n\n      if (ysize.length === 1) {\n        // Matrix * Vector\n        return _multiplyMatrixVector(x, y);\n      } // Matrix * Matrix\n\n\n      return _multiplyMatrixMatrix(x, y);\n    },\n    'Matrix, Array': typed.referTo('Matrix,Matrix', selfMM => (x, y) => selfMM(x, matrix(y))),\n    'Array, Matrix': typed.referToSelf(self => (x, y) => {\n      // use Matrix * Matrix implementation\n      return self(matrix(x, y.storage()), y);\n    }),\n    'SparseMatrix, any': function SparseMatrixAny(x, y) {\n      return matAlgo11xS0s(x, y, multiplyScalar, false);\n    },\n    'DenseMatrix, any': function DenseMatrixAny(x, y) {\n      return matAlgo14xDs(x, y, multiplyScalar, false);\n    },\n    'any, SparseMatrix': function anySparseMatrix(x, y) {\n      return matAlgo11xS0s(y, x, multiplyScalar, true);\n    },\n    'any, DenseMatrix': function anyDenseMatrix(x, y) {\n      return matAlgo14xDs(y, x, multiplyScalar, true);\n    },\n    'Array, any': function ArrayAny(x, y) {\n      // use matrix implementation\n      return matAlgo14xDs(matrix(x), y, multiplyScalar, false).valueOf();\n    },\n    'any, Array': function anyArray(x, y) {\n      // use matrix implementation\n      return matAlgo14xDs(matrix(y), x, multiplyScalar, true).valueOf();\n    },\n    'any, any': multiplyScalar,\n    'any, any, ...any': typed.referToSelf(self => (x, y, rest) => {\n      var result = self(x, y);\n\n      for (var i = 0; i < rest.length; i++) {\n        result = self(result, rest[i]);\n      }\n\n      return result;\n    })\n  });\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/arithmetic/multiply.js"],"names":["factory","isMatrix","arraySize","createMatAlgo11xS0s","createMatAlgo14xDs","name","dependencies","createMultiply","_ref","typed","matrix","addScalar","multiplyScalar","equalScalar","dot","matAlgo11xS0s","matAlgo14xDs","_validateMatrixDimensions","size1","size2","length","RangeError","Error","_multiplyVectorVector","a","b","n","_multiplyVectorMatrix","storage","_multiplyVectorDenseMatrix","adata","_data","asize","_size","adt","_datatype","bdata","bsize","bdt","alength","bcolumns","dt","af","mf","find","c","j","sum","i","createDenseMatrix","data","size","datatype","_multiplyMatrixVector","_multiplyDenseMatrixVector","_multiplySparseMatrixVector","_multiplyMatrixMatrix","_multiplyDenseMatrixDenseMatrix","_multiplyDenseMatrixSparseMatrix","_multiplySparseMatrixDenseMatrix","_multiplySparseMatrixSparseMatrix","arows","acolumns","row","x","bvalues","_values","bindex","_index","bptr","_ptr","eq","zero","convert","cvalues","cindex","cptr","createSparseMatrix","values","index","ptr","jb","kb0","kb1","last","mark","cij","kb","ib","push","avalues","aindex","aptr","brows","w","vbi","ka0","ka1","ka","ia","p1","p","ic","vbij","p0","undefined","referTo","selfMM","y","m","valueOf","MatrixMatrix","xsize","ysize","referToSelf","self","SparseMatrixAny","DenseMatrixAny","anySparseMatrix","anyDenseMatrix","ArrayAny","anyArray","rest","result"],"mappings":"AAAA,SAASA,OAAT,QAAwB,wBAAxB;AACA,SAASC,QAAT,QAAyB,mBAAzB;AACA,SAASC,SAAT,QAA0B,sBAA1B;AACA,SAASC,mBAAT,QAAoC,0CAApC;AACA,SAASC,kBAAT,QAAmC,yCAAnC;AACA,IAAIC,IAAI,GAAG,UAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,QAAV,EAAoB,WAApB,EAAiC,gBAAjC,EAAmD,aAAnD,EAAkE,KAAlE,CAAnB;AACA,OAAO,IAAIC,cAAc,GAAG,eAAeP,OAAO,CAACK,IAAD,EAAOC,YAAP,EAAqBE,IAAI,IAAI;AAC7E,MAAI;AACFC,IAAAA,KADE;AAEFC,IAAAA,MAFE;AAGFC,IAAAA,SAHE;AAIFC,IAAAA,cAJE;AAKFC,IAAAA,WALE;AAMFC,IAAAA;AANE,MAOAN,IAPJ;AAQA,MAAIO,aAAa,GAAGZ,mBAAmB,CAAC;AACtCM,IAAAA,KADsC;AAEtCI,IAAAA;AAFsC,GAAD,CAAvC;AAIA,MAAIG,YAAY,GAAGZ,kBAAkB,CAAC;AACpCK,IAAAA;AADoC,GAAD,CAArC;;AAGA,WAASQ,yBAAT,CAAmCC,KAAnC,EAA0CC,KAA1C,EAAiD;AAC/C;AACA,YAAQD,KAAK,CAACE,MAAd;AACE,WAAK,CAAL;AACE;AACA,gBAAQD,KAAK,CAACC,MAAd;AACE,eAAK,CAAL;AACE;AACA,gBAAIF,KAAK,CAAC,CAAD,CAAL,KAAaC,KAAK,CAAC,CAAD,CAAtB,EAA2B;AACzB;AACA,oBAAM,IAAIE,UAAJ,CAAe,yEAAf,CAAN;AACD;;AACD;;AACF,eAAK,CAAL;AACE;AACA,gBAAIH,KAAK,CAAC,CAAD,CAAL,KAAaC,KAAK,CAAC,CAAD,CAAtB,EAA2B;AACzB;AACA,oBAAM,IAAIE,UAAJ,CAAe,0DAA0DH,KAAK,CAAC,CAAD,CAA/D,GAAqE,4BAArE,GAAoGC,KAAK,CAAC,CAAD,CAAzG,GAA+G,GAA9H,CAAN;AACD;;AACD;;AACF;AACE,kBAAM,IAAIG,KAAJ,CAAU,iEAAiEH,KAAK,CAACC,MAAvE,GAAgF,cAA1F,CAAN;AAhBJ;;AAkBA;;AACF,WAAK,CAAL;AACE;AACA,gBAAQD,KAAK,CAACC,MAAd;AACE,eAAK,CAAL;AACE;AACA,gBAAIF,KAAK,CAAC,CAAD,CAAL,KAAaC,KAAK,CAAC,CAAD,CAAtB,EAA2B;AACzB;AACA,oBAAM,IAAIE,UAAJ,CAAe,2DAA2DH,KAAK,CAAC,CAAD,CAAhE,GAAsE,8BAAtE,GAAuGC,KAAK,CAAC,CAAD,CAA5G,GAAkH,GAAjI,CAAN;AACD;;AACD;;AACF,eAAK,CAAL;AACE;AACA,gBAAID,KAAK,CAAC,CAAD,CAAL,KAAaC,KAAK,CAAC,CAAD,CAAtB,EAA2B;AACzB;AACA,oBAAM,IAAIE,UAAJ,CAAe,6DAA6DH,KAAK,CAAC,CAAD,CAAlE,GAAwE,8BAAxE,GAAyGC,KAAK,CAAC,CAAD,CAA9G,GAAoH,GAAnI,CAAN;AACD;;AACD;;AACF;AACE,kBAAM,IAAIG,KAAJ,CAAU,iEAAiEH,KAAK,CAACC,MAAvE,GAAgF,cAA1F,CAAN;AAhBJ;;AAkBA;;AACF;AACE,cAAM,IAAIE,KAAJ,CAAU,iEAAiEJ,KAAK,CAACE,MAAvE,GAAgF,cAA1F,CAAN;AA5CJ;AA8CD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASG,qBAAT,CAA+BC,CAA/B,EAAkCC,CAAlC,EAAqCC,CAArC,EAAwC;AACtC;AACA,QAAIA,CAAC,KAAK,CAAV,EAAa;AACX,YAAM,IAAIJ,KAAJ,CAAU,mCAAV,CAAN;AACD;;AACD,WAAOR,GAAG,CAACU,CAAD,EAAIC,CAAJ,CAAV;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASE,qBAAT,CAA+BH,CAA/B,EAAkCC,CAAlC,EAAqC;AACnC;AACA,QAAIA,CAAC,CAACG,OAAF,OAAgB,OAApB,EAA6B;AAC3B,YAAM,IAAIN,KAAJ,CAAU,0CAAV,CAAN;AACD;;AACD,WAAOO,0BAA0B,CAACL,CAAD,EAAIC,CAAJ,CAAjC;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASI,0BAAT,CAAoCL,CAApC,EAAuCC,CAAvC,EAA0C;AACxC;AACA,QAAIK,KAAK,GAAGN,CAAC,CAACO,KAAd;AACA,QAAIC,KAAK,GAAGR,CAAC,CAACS,KAAd;AACA,QAAIC,GAAG,GAAGV,CAAC,CAACW,SAAZ,CAJwC,CAKxC;;AACA,QAAIC,KAAK,GAAGX,CAAC,CAACM,KAAd;AACA,QAAIM,KAAK,GAAGZ,CAAC,CAACQ,KAAd;AACA,QAAIK,GAAG,GAAGb,CAAC,CAACU,SAAZ,CARwC,CASxC;;AACA,QAAII,OAAO,GAAGP,KAAK,CAAC,CAAD,CAAnB;AACA,QAAIQ,QAAQ,GAAGH,KAAK,CAAC,CAAD,CAApB,CAXwC,CAaxC;;AACA,QAAII,EAAJ,CAdwC,CAexC;;AACA,QAAIC,EAAE,GAAG/B,SAAT,CAhBwC,CAiBxC;;AACA,QAAIgC,EAAE,GAAG/B,cAAT,CAlBwC,CAoBxC;;AACA,QAAIsB,GAAG,IAAII,GAAP,IAAcJ,GAAG,KAAKI,GAAtB,IAA6B,OAAOJ,GAAP,KAAe,QAAhD,EAA0D;AACxD;AACAO,MAAAA,EAAE,GAAGP,GAAL,CAFwD,CAGxD;;AACAQ,MAAAA,EAAE,GAAGjC,KAAK,CAACmC,IAAN,CAAWjC,SAAX,EAAsB,CAAC8B,EAAD,EAAKA,EAAL,CAAtB,CAAL;AACAE,MAAAA,EAAE,GAAGlC,KAAK,CAACmC,IAAN,CAAWhC,cAAX,EAA2B,CAAC6B,EAAD,EAAKA,EAAL,CAA3B,CAAL;AACD,KA3BuC,CA6BxC;;;AACA,QAAII,CAAC,GAAG,EAAR,CA9BwC,CAgCxC;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,QAApB,EAA8BM,CAAC,EAA/B,EAAmC;AACjC;AACA,UAAIC,GAAG,GAAGJ,EAAE,CAACb,KAAK,CAAC,CAAD,CAAN,EAAWM,KAAK,CAAC,CAAD,CAAL,CAASU,CAAT,CAAX,CAAZ,CAFiC,CAGjC;;AACA,WAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,OAApB,EAA6BS,CAAC,EAA9B,EAAkC;AAChC;AACAD,QAAAA,GAAG,GAAGL,EAAE,CAACK,GAAD,EAAMJ,EAAE,CAACb,KAAK,CAACkB,CAAD,CAAN,EAAWZ,KAAK,CAACY,CAAD,CAAL,CAASF,CAAT,CAAX,CAAR,CAAR;AACD;;AACDD,MAAAA,CAAC,CAACC,CAAD,CAAD,GAAOC,GAAP;AACD,KA1CuC,CA4CxC;;;AACA,WAAOvB,CAAC,CAACyB,iBAAF,CAAoB;AACzBC,MAAAA,IAAI,EAAEL,CADmB;AAEzBM,MAAAA,IAAI,EAAE,CAACX,QAAD,CAFmB;AAGzBY,MAAAA,QAAQ,EAAEX;AAHe,KAApB,CAAP;AAKD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,MAAIY,qBAAqB,GAAG5C,KAAK,CAAC,uBAAD,EAA0B;AACzD,wBAAoB6C,0BADqC;AAEzD,yBAAqBC;AAFoC,GAA1B,CAAjC;AAKA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,MAAIC,qBAAqB,GAAG/C,KAAK,CAAC,uBAAD,EAA0B;AACzD,gCAA4BgD,+BAD6B;AAEzD,iCAA6BC,gCAF4B;AAGzD,iCAA6BC,gCAH4B;AAIzD,kCAA8BC;AAJ2B,GAA1B,CAAjC;AAOA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASN,0BAAT,CAAoC9B,CAApC,EAAuCC,CAAvC,EAA0C;AACxC;AACA,QAAIK,KAAK,GAAGN,CAAC,CAACO,KAAd;AACA,QAAIC,KAAK,GAAGR,CAAC,CAACS,KAAd;AACA,QAAIC,GAAG,GAAGV,CAAC,CAACW,SAAZ,CAJwC,CAKxC;;AACA,QAAIC,KAAK,GAAGX,CAAC,CAACM,KAAd;AACA,QAAIO,GAAG,GAAGb,CAAC,CAACU,SAAZ,CAPwC,CAQxC;;AACA,QAAI0B,KAAK,GAAG7B,KAAK,CAAC,CAAD,CAAjB;AACA,QAAI8B,QAAQ,GAAG9B,KAAK,CAAC,CAAD,CAApB,CAVwC,CAYxC;;AACA,QAAIS,EAAJ,CAbwC,CAcxC;;AACA,QAAIC,EAAE,GAAG/B,SAAT,CAfwC,CAgBxC;;AACA,QAAIgC,EAAE,GAAG/B,cAAT,CAjBwC,CAmBxC;;AACA,QAAIsB,GAAG,IAAII,GAAP,IAAcJ,GAAG,KAAKI,GAAtB,IAA6B,OAAOJ,GAAP,KAAe,QAAhD,EAA0D;AACxD;AACAO,MAAAA,EAAE,GAAGP,GAAL,CAFwD,CAGxD;;AACAQ,MAAAA,EAAE,GAAGjC,KAAK,CAACmC,IAAN,CAAWjC,SAAX,EAAsB,CAAC8B,EAAD,EAAKA,EAAL,CAAtB,CAAL;AACAE,MAAAA,EAAE,GAAGlC,KAAK,CAACmC,IAAN,CAAWhC,cAAX,EAA2B,CAAC6B,EAAD,EAAKA,EAAL,CAA3B,CAAL;AACD,KA1BuC,CA4BxC;;;AACA,QAAII,CAAC,GAAG,EAAR,CA7BwC,CA+BxC;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGa,KAApB,EAA2Bb,CAAC,EAA5B,EAAgC;AAC9B;AACA,UAAIe,GAAG,GAAGjC,KAAK,CAACkB,CAAD,CAAf,CAF8B,CAG9B;;AACA,UAAID,GAAG,GAAGJ,EAAE,CAACoB,GAAG,CAAC,CAAD,CAAJ,EAAS3B,KAAK,CAAC,CAAD,CAAd,CAAZ,CAJ8B,CAK9B;;AACA,WAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgB,QAApB,EAA8BhB,CAAC,EAA/B,EAAmC;AACjC;AACAC,QAAAA,GAAG,GAAGL,EAAE,CAACK,GAAD,EAAMJ,EAAE,CAACoB,GAAG,CAACjB,CAAD,CAAJ,EAASV,KAAK,CAACU,CAAD,CAAd,CAAR,CAAR;AACD;;AACDD,MAAAA,CAAC,CAACG,CAAD,CAAD,GAAOD,GAAP;AACD,KA3CuC,CA6CxC;;;AACA,WAAOvB,CAAC,CAACyB,iBAAF,CAAoB;AACzBC,MAAAA,IAAI,EAAEL,CADmB;AAEzBM,MAAAA,IAAI,EAAE,CAACU,KAAD,CAFmB;AAGzBT,MAAAA,QAAQ,EAAEX;AAHe,KAApB,CAAP;AAKD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASgB,+BAAT,CAAyCjC,CAAzC,EAA4CC,CAA5C,EAA+C;AAC7C;AACA,QAAIK,KAAK,GAAGN,CAAC,CAACO,KAAd;AACA,QAAIC,KAAK,GAAGR,CAAC,CAACS,KAAd;AACA,QAAIC,GAAG,GAAGV,CAAC,CAACW,SAAZ,CAJ6C,CAK7C;;AACA,QAAIC,KAAK,GAAGX,CAAC,CAACM,KAAd;AACA,QAAIM,KAAK,GAAGZ,CAAC,CAACQ,KAAd;AACA,QAAIK,GAAG,GAAGb,CAAC,CAACU,SAAZ,CAR6C,CAS7C;;AACA,QAAI0B,KAAK,GAAG7B,KAAK,CAAC,CAAD,CAAjB;AACA,QAAI8B,QAAQ,GAAG9B,KAAK,CAAC,CAAD,CAApB;AACA,QAAIQ,QAAQ,GAAGH,KAAK,CAAC,CAAD,CAApB,CAZ6C,CAc7C;;AACA,QAAII,EAAJ,CAf6C,CAgB7C;;AACA,QAAIC,EAAE,GAAG/B,SAAT,CAjB6C,CAkB7C;;AACA,QAAIgC,EAAE,GAAG/B,cAAT,CAnB6C,CAqB7C;;AACA,QAAIsB,GAAG,IAAII,GAAP,IAAcJ,GAAG,KAAKI,GAAtB,IAA6B,OAAOJ,GAAP,KAAe,QAAhD,EAA0D;AACxD;AACAO,MAAAA,EAAE,GAAGP,GAAL,CAFwD,CAGxD;;AACAQ,MAAAA,EAAE,GAAGjC,KAAK,CAACmC,IAAN,CAAWjC,SAAX,EAAsB,CAAC8B,EAAD,EAAKA,EAAL,CAAtB,CAAL;AACAE,MAAAA,EAAE,GAAGlC,KAAK,CAACmC,IAAN,CAAWhC,cAAX,EAA2B,CAAC6B,EAAD,EAAKA,EAAL,CAA3B,CAAL;AACD,KA5B4C,CA8B7C;;;AACA,QAAII,CAAC,GAAG,EAAR,CA/B6C,CAiC7C;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGa,KAApB,EAA2Bb,CAAC,EAA5B,EAAgC;AAC9B;AACA,UAAIe,GAAG,GAAGjC,KAAK,CAACkB,CAAD,CAAf,CAF8B,CAG9B;;AACAH,MAAAA,CAAC,CAACG,CAAD,CAAD,GAAO,EAAP,CAJ8B,CAK9B;;AACA,WAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,QAApB,EAA8BM,CAAC,EAA/B,EAAmC;AACjC;AACA,YAAIC,GAAG,GAAGJ,EAAE,CAACoB,GAAG,CAAC,CAAD,CAAJ,EAAS3B,KAAK,CAAC,CAAD,CAAL,CAASU,CAAT,CAAT,CAAZ,CAFiC,CAGjC;;AACA,aAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAApB,EAA8BE,CAAC,EAA/B,EAAmC;AACjC;AACAjB,UAAAA,GAAG,GAAGL,EAAE,CAACK,GAAD,EAAMJ,EAAE,CAACoB,GAAG,CAACC,CAAD,CAAJ,EAAS5B,KAAK,CAAC4B,CAAD,CAAL,CAASlB,CAAT,CAAT,CAAR,CAAR;AACD;;AACDD,QAAAA,CAAC,CAACG,CAAD,CAAD,CAAKF,CAAL,IAAUC,GAAV;AACD;AACF,KAlD4C,CAoD7C;;;AACA,WAAOvB,CAAC,CAACyB,iBAAF,CAAoB;AACzBC,MAAAA,IAAI,EAAEL,CADmB;AAEzBM,MAAAA,IAAI,EAAE,CAACU,KAAD,EAAQrB,QAAR,CAFmB;AAGzBY,MAAAA,QAAQ,EAAEX;AAHe,KAApB,CAAP;AAKD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASiB,gCAAT,CAA0ClC,CAA1C,EAA6CC,CAA7C,EAAgD;AAC9C;AACA,QAAIK,KAAK,GAAGN,CAAC,CAACO,KAAd;AACA,QAAIC,KAAK,GAAGR,CAAC,CAACS,KAAd;AACA,QAAIC,GAAG,GAAGV,CAAC,CAACW,SAAZ,CAJ8C,CAK9C;;AACA,QAAI8B,OAAO,GAAGxC,CAAC,CAACyC,OAAhB;AACA,QAAIC,MAAM,GAAG1C,CAAC,CAAC2C,MAAf;AACA,QAAIC,IAAI,GAAG5C,CAAC,CAAC6C,IAAb;AACA,QAAIjC,KAAK,GAAGZ,CAAC,CAACQ,KAAd;AACA,QAAIK,GAAG,GAAGb,CAAC,CAACU,SAAZ,CAV8C,CAW9C;;AACA,QAAI,CAAC8B,OAAL,EAAc;AACZ,YAAM,IAAI3C,KAAJ,CAAU,wDAAV,CAAN;AACD,KAd6C,CAe9C;;;AACA,QAAIuC,KAAK,GAAG7B,KAAK,CAAC,CAAD,CAAjB;AACA,QAAIQ,QAAQ,GAAGH,KAAK,CAAC,CAAD,CAApB,CAjB8C,CAmB9C;;AACA,QAAII,EAAJ,CApB8C,CAqB9C;;AACA,QAAIC,EAAE,GAAG/B,SAAT,CAtB8C,CAuB9C;;AACA,QAAIgC,EAAE,GAAG/B,cAAT,CAxB8C,CAyB9C;;AACA,QAAI2D,EAAE,GAAG1D,WAAT,CA1B8C,CA2B9C;;AACA,QAAI2D,IAAI,GAAG,CAAX,CA5B8C,CA8B9C;;AACA,QAAItC,GAAG,IAAII,GAAP,IAAcJ,GAAG,KAAKI,GAAtB,IAA6B,OAAOJ,GAAP,KAAe,QAAhD,EAA0D;AACxD;AACAO,MAAAA,EAAE,GAAGP,GAAL,CAFwD,CAGxD;;AACAQ,MAAAA,EAAE,GAAGjC,KAAK,CAACmC,IAAN,CAAWjC,SAAX,EAAsB,CAAC8B,EAAD,EAAKA,EAAL,CAAtB,CAAL;AACAE,MAAAA,EAAE,GAAGlC,KAAK,CAACmC,IAAN,CAAWhC,cAAX,EAA2B,CAAC6B,EAAD,EAAKA,EAAL,CAA3B,CAAL;AACA8B,MAAAA,EAAE,GAAG9D,KAAK,CAACmC,IAAN,CAAW/B,WAAX,EAAwB,CAAC4B,EAAD,EAAKA,EAAL,CAAxB,CAAL,CANwD,CAOxD;;AACA+B,MAAAA,IAAI,GAAG/D,KAAK,CAACgE,OAAN,CAAc,CAAd,EAAiBhC,EAAjB,CAAP;AACD,KAxC6C,CA0C9C;;;AACA,QAAIiC,OAAO,GAAG,EAAd;AACA,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,IAAI,GAAG,EAAX,CA7C8C,CA8C9C;;AACA,QAAI/B,CAAC,GAAGpB,CAAC,CAACoD,kBAAF,CAAqB;AAC3BC,MAAAA,MAAM,EAAEJ,OADmB;AAE3BK,MAAAA,KAAK,EAAEJ,MAFoB;AAG3BK,MAAAA,GAAG,EAAEJ,IAHsB;AAI3BzB,MAAAA,IAAI,EAAE,CAACU,KAAD,EAAQrB,QAAR,CAJqB;AAK3BY,MAAAA,QAAQ,EAAEX;AALiB,KAArB,CAAR,CA/C8C,CAuD9C;;AACA,SAAK,IAAIwC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGzC,QAAtB,EAAgCyC,EAAE,EAAlC,EAAsC;AACpC;AACAL,MAAAA,IAAI,CAACK,EAAD,CAAJ,GAAWN,MAAM,CAACvD,MAAlB,CAFoC,CAGpC;;AACA,UAAI8D,GAAG,GAAGb,IAAI,CAACY,EAAD,CAAd;AACA,UAAIE,GAAG,GAAGd,IAAI,CAACY,EAAE,GAAG,CAAN,CAAd,CALoC,CAMpC;;AACA,UAAIE,GAAG,GAAGD,GAAV,EAAe;AACb;AACA,YAAIE,IAAI,GAAG,CAAX,CAFa,CAGb;;AACA,aAAK,IAAIpC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGa,KAApB,EAA2Bb,CAAC,EAA5B,EAAgC;AAC9B;AACA,cAAIqC,IAAI,GAAGrC,CAAC,GAAG,CAAf,CAF8B,CAG9B;;AACA,cAAIsC,GAAG,GAAG,KAAK,CAAf,CAJ8B,CAK9B;;AACA,eAAK,IAAIC,EAAE,GAAGL,GAAd,EAAmBK,EAAE,GAAGJ,GAAxB,EAA6BI,EAAE,EAA/B,EAAmC;AACjC;AACA,gBAAIC,EAAE,GAAGrB,MAAM,CAACoB,EAAD,CAAf,CAFiC,CAGjC;;AACA,gBAAIH,IAAI,KAAKC,IAAb,EAAmB;AACjB;AACAC,cAAAA,GAAG,GAAG3C,EAAE,CAACb,KAAK,CAACkB,CAAD,CAAL,CAASwC,EAAT,CAAD,EAAevB,OAAO,CAACsB,EAAD,CAAtB,CAAR,CAFiB,CAGjB;;AACAH,cAAAA,IAAI,GAAGC,IAAP;AACD,aALD,MAKO;AACL;AACAC,cAAAA,GAAG,GAAG5C,EAAE,CAAC4C,GAAD,EAAM3C,EAAE,CAACb,KAAK,CAACkB,CAAD,CAAL,CAASwC,EAAT,CAAD,EAAevB,OAAO,CAACsB,EAAD,CAAtB,CAAR,CAAR;AACD;AACF,WAnB6B,CAoB9B;;;AACA,cAAIH,IAAI,KAAKC,IAAT,IAAiB,CAACd,EAAE,CAACe,GAAD,EAAMd,IAAN,CAAxB,EAAqC;AACnC;AACAG,YAAAA,MAAM,CAACc,IAAP,CAAYzC,CAAZ;AACA0B,YAAAA,OAAO,CAACe,IAAR,CAAaH,GAAb;AACD;AACF;AACF;AACF,KA/F6C,CAgG9C;;;AACAV,IAAAA,IAAI,CAACpC,QAAD,CAAJ,GAAiBmC,MAAM,CAACvD,MAAxB,CAjG8C,CAmG9C;;AACA,WAAOyB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASU,2BAAT,CAAqC/B,CAArC,EAAwCC,CAAxC,EAA2C;AACzC;AACA,QAAIiE,OAAO,GAAGlE,CAAC,CAAC0C,OAAhB;AACA,QAAIyB,MAAM,GAAGnE,CAAC,CAAC4C,MAAf;AACA,QAAIwB,IAAI,GAAGpE,CAAC,CAAC8C,IAAb;AACA,QAAIpC,GAAG,GAAGV,CAAC,CAACW,SAAZ,CALyC,CAMzC;;AACA,QAAI,CAACuD,OAAL,EAAc;AACZ,YAAM,IAAIpE,KAAJ,CAAU,wDAAV,CAAN;AACD,KATwC,CAUzC;;;AACA,QAAIc,KAAK,GAAGX,CAAC,CAACM,KAAd;AACA,QAAIO,GAAG,GAAGb,CAAC,CAACU,SAAZ,CAZyC,CAazC;;AACA,QAAI0B,KAAK,GAAGrC,CAAC,CAACS,KAAF,CAAQ,CAAR,CAAZ;AACA,QAAI4D,KAAK,GAAGpE,CAAC,CAACQ,KAAF,CAAQ,CAAR,CAAZ,CAfyC,CAgBzC;;AACA,QAAIyC,OAAO,GAAG,EAAd;AACA,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,IAAI,GAAG,EAAX,CAnByC,CAqBzC;;AACA,QAAInC,EAAJ,CAtByC,CAuBzC;;AACA,QAAIC,EAAE,GAAG/B,SAAT,CAxByC,CAyBzC;;AACA,QAAIgC,EAAE,GAAG/B,cAAT,CA1ByC,CA2BzC;;AACA,QAAI2D,EAAE,GAAG1D,WAAT,CA5ByC,CA6BzC;;AACA,QAAI2D,IAAI,GAAG,CAAX,CA9ByC,CAgCzC;;AACA,QAAItC,GAAG,IAAII,GAAP,IAAcJ,GAAG,KAAKI,GAAtB,IAA6B,OAAOJ,GAAP,KAAe,QAAhD,EAA0D;AACxD;AACAO,MAAAA,EAAE,GAAGP,GAAL,CAFwD,CAGxD;;AACAQ,MAAAA,EAAE,GAAGjC,KAAK,CAACmC,IAAN,CAAWjC,SAAX,EAAsB,CAAC8B,EAAD,EAAKA,EAAL,CAAtB,CAAL;AACAE,MAAAA,EAAE,GAAGlC,KAAK,CAACmC,IAAN,CAAWhC,cAAX,EAA2B,CAAC6B,EAAD,EAAKA,EAAL,CAA3B,CAAL;AACA8B,MAAAA,EAAE,GAAG9D,KAAK,CAACmC,IAAN,CAAW/B,WAAX,EAAwB,CAAC4B,EAAD,EAAKA,EAAL,CAAxB,CAAL,CANwD,CAOxD;;AACA+B,MAAAA,IAAI,GAAG/D,KAAK,CAACgE,OAAN,CAAc,CAAd,EAAiBhC,EAAjB,CAAP;AACD,KA1CwC,CA4CzC;;;AACA,QAAIuB,CAAC,GAAG,EAAR,CA7CyC,CA8CzC;;AACA,QAAI8B,CAAC,GAAG,EAAR,CA/CyC,CAiDzC;;AACAlB,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAV,CAlDyC,CAmDzC;;AACA,SAAK,IAAIY,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGK,KAAtB,EAA6BL,EAAE,EAA/B,EAAmC;AACjC;AACA,UAAIO,GAAG,GAAG3D,KAAK,CAACoD,EAAD,CAAf,CAFiC,CAGjC;;AACA,UAAI,CAACjB,EAAE,CAACwB,GAAD,EAAMvB,IAAN,CAAP,EAAoB;AAClB;AACA,aAAK,IAAIwB,GAAG,GAAGJ,IAAI,CAACJ,EAAD,CAAd,EAAoBS,GAAG,GAAGL,IAAI,CAACJ,EAAE,GAAG,CAAN,CAA9B,EAAwCU,EAAE,GAAGF,GAAlD,EAAuDE,EAAE,GAAGD,GAA5D,EAAiEC,EAAE,EAAnE,EAAuE;AACrE;AACA,cAAIC,EAAE,GAAGR,MAAM,CAACO,EAAD,CAAf,CAFqE,CAGrE;;AACA,cAAI,CAACJ,CAAC,CAACK,EAAD,CAAN,EAAY;AACV;AACAL,YAAAA,CAAC,CAACK,EAAD,CAAD,GAAQ,IAAR,CAFU,CAGV;;AACAxB,YAAAA,MAAM,CAACc,IAAP,CAAYU,EAAZ,EAJU,CAKV;;AACAnC,YAAAA,CAAC,CAACmC,EAAD,CAAD,GAAQxD,EAAE,CAACoD,GAAD,EAAML,OAAO,CAACQ,EAAD,CAAb,CAAV;AACD,WAPD,MAOO;AACL;AACAlC,YAAAA,CAAC,CAACmC,EAAD,CAAD,GAAQzD,EAAE,CAACsB,CAAC,CAACmC,EAAD,CAAF,EAAQxD,EAAE,CAACoD,GAAD,EAAML,OAAO,CAACQ,EAAD,CAAb,CAAV,CAAV;AACD;AACF;AACF;AACF,KA3EwC,CA4EzC;;;AACA,SAAK,IAAIE,EAAE,GAAGzB,MAAM,CAACvD,MAAhB,EAAwBiF,CAAC,GAAG,CAAjC,EAAoCA,CAAC,GAAGD,EAAxC,EAA4CC,CAAC,EAA7C,EAAiD;AAC/C;AACA,UAAIC,EAAE,GAAG3B,MAAM,CAAC0B,CAAD,CAAf,CAF+C,CAG/C;;AACA3B,MAAAA,OAAO,CAAC2B,CAAD,CAAP,GAAarC,CAAC,CAACsC,EAAD,CAAd;AACD,KAlFwC,CAmFzC;;;AACA1B,IAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUD,MAAM,CAACvD,MAAjB,CApFyC,CAsFzC;;AACA,WAAOI,CAAC,CAACqD,kBAAF,CAAqB;AAC1BC,MAAAA,MAAM,EAAEJ,OADkB;AAE1BK,MAAAA,KAAK,EAAEJ,MAFmB;AAG1BK,MAAAA,GAAG,EAAEJ,IAHqB;AAI1BzB,MAAAA,IAAI,EAAE,CAACU,KAAD,EAAQ,CAAR,CAJoB;AAK1BT,MAAAA,QAAQ,EAAEX;AALgB,KAArB,CAAP;AAOD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASkB,gCAAT,CAA0CnC,CAA1C,EAA6CC,CAA7C,EAAgD;AAC9C;AACA,QAAIiE,OAAO,GAAGlE,CAAC,CAAC0C,OAAhB;AACA,QAAIyB,MAAM,GAAGnE,CAAC,CAAC4C,MAAf;AACA,QAAIwB,IAAI,GAAGpE,CAAC,CAAC8C,IAAb;AACA,QAAIpC,GAAG,GAAGV,CAAC,CAACW,SAAZ,CAL8C,CAM9C;;AACA,QAAI,CAACuD,OAAL,EAAc;AACZ,YAAM,IAAIpE,KAAJ,CAAU,wDAAV,CAAN;AACD,KAT6C,CAU9C;;;AACA,QAAIc,KAAK,GAAGX,CAAC,CAACM,KAAd;AACA,QAAIO,GAAG,GAAGb,CAAC,CAACU,SAAZ,CAZ8C,CAa9C;;AACA,QAAI0B,KAAK,GAAGrC,CAAC,CAACS,KAAF,CAAQ,CAAR,CAAZ;AACA,QAAI4D,KAAK,GAAGpE,CAAC,CAACQ,KAAF,CAAQ,CAAR,CAAZ;AACA,QAAIO,QAAQ,GAAGf,CAAC,CAACQ,KAAF,CAAQ,CAAR,CAAf,CAhB8C,CAkB9C;;AACA,QAAIQ,EAAJ,CAnB8C,CAoB9C;;AACA,QAAIC,EAAE,GAAG/B,SAAT,CArB8C,CAsB9C;;AACA,QAAIgC,EAAE,GAAG/B,cAAT,CAvB8C,CAwB9C;;AACA,QAAI2D,EAAE,GAAG1D,WAAT,CAzB8C,CA0B9C;;AACA,QAAI2D,IAAI,GAAG,CAAX,CA3B8C,CA6B9C;;AACA,QAAItC,GAAG,IAAII,GAAP,IAAcJ,GAAG,KAAKI,GAAtB,IAA6B,OAAOJ,GAAP,KAAe,QAAhD,EAA0D;AACxD;AACAO,MAAAA,EAAE,GAAGP,GAAL,CAFwD,CAGxD;;AACAQ,MAAAA,EAAE,GAAGjC,KAAK,CAACmC,IAAN,CAAWjC,SAAX,EAAsB,CAAC8B,EAAD,EAAKA,EAAL,CAAtB,CAAL;AACAE,MAAAA,EAAE,GAAGlC,KAAK,CAACmC,IAAN,CAAWhC,cAAX,EAA2B,CAAC6B,EAAD,EAAKA,EAAL,CAA3B,CAAL;AACA8B,MAAAA,EAAE,GAAG9D,KAAK,CAACmC,IAAN,CAAW/B,WAAX,EAAwB,CAAC4B,EAAD,EAAKA,EAAL,CAAxB,CAAL,CANwD,CAOxD;;AACA+B,MAAAA,IAAI,GAAG/D,KAAK,CAACgE,OAAN,CAAc,CAAd,EAAiBhC,EAAjB,CAAP;AACD,KAvC6C,CAyC9C;;;AACA,QAAIiC,OAAO,GAAG,EAAd;AACA,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,IAAI,GAAG,EAAX,CA5C8C,CA6C9C;;AACA,QAAI/B,CAAC,GAAGrB,CAAC,CAACqD,kBAAF,CAAqB;AAC3BC,MAAAA,MAAM,EAAEJ,OADmB;AAE3BK,MAAAA,KAAK,EAAEJ,MAFoB;AAG3BK,MAAAA,GAAG,EAAEJ,IAHsB;AAI3BzB,MAAAA,IAAI,EAAE,CAACU,KAAD,EAAQrB,QAAR,CAJqB;AAK3BY,MAAAA,QAAQ,EAAEX;AALiB,KAArB,CAAR,CA9C8C,CAsD9C;;AACA,QAAIuB,CAAC,GAAG,EAAR,CAvD8C,CAwD9C;;AACA,QAAI8B,CAAC,GAAG,EAAR,CAzD8C,CA2D9C;;AACA,SAAK,IAAIb,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGzC,QAAtB,EAAgCyC,EAAE,EAAlC,EAAsC;AACpC;AACAL,MAAAA,IAAI,CAACK,EAAD,CAAJ,GAAWN,MAAM,CAACvD,MAAlB,CAFoC,CAGpC;;AACA,UAAIiE,IAAI,GAAGJ,EAAE,GAAG,CAAhB,CAJoC,CAKpC;;AACA,WAAK,IAAIO,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGK,KAAtB,EAA6BL,EAAE,EAA/B,EAAmC;AACjC;AACA,YAAIe,IAAI,GAAGnE,KAAK,CAACoD,EAAD,CAAL,CAAUP,EAAV,CAAX,CAFiC,CAGjC;;AACA,YAAI,CAACV,EAAE,CAACgC,IAAD,EAAO/B,IAAP,CAAP,EAAqB;AACnB;AACA,eAAK,IAAIwB,GAAG,GAAGJ,IAAI,CAACJ,EAAD,CAAd,EAAoBS,GAAG,GAAGL,IAAI,CAACJ,EAAE,GAAG,CAAN,CAA9B,EAAwCU,EAAE,GAAGF,GAAlD,EAAuDE,EAAE,GAAGD,GAA5D,EAAiEC,EAAE,EAAnE,EAAuE;AACrE;AACA,gBAAIC,EAAE,GAAGR,MAAM,CAACO,EAAD,CAAf,CAFqE,CAGrE;;AACA,gBAAIJ,CAAC,CAACK,EAAD,CAAD,KAAUd,IAAd,EAAoB;AAClB;AACAS,cAAAA,CAAC,CAACK,EAAD,CAAD,GAAQd,IAAR,CAFkB,CAGlB;;AACAV,cAAAA,MAAM,CAACc,IAAP,CAAYU,EAAZ,EAJkB,CAKlB;;AACAnC,cAAAA,CAAC,CAACmC,EAAD,CAAD,GAAQxD,EAAE,CAAC4D,IAAD,EAAOb,OAAO,CAACQ,EAAD,CAAd,CAAV;AACD,aAPD,MAOO;AACL;AACAlC,cAAAA,CAAC,CAACmC,EAAD,CAAD,GAAQzD,EAAE,CAACsB,CAAC,CAACmC,EAAD,CAAF,EAAQxD,EAAE,CAAC4D,IAAD,EAAOb,OAAO,CAACQ,EAAD,CAAd,CAAV,CAAV;AACD;AACF;AACF;AACF,OA7BmC,CA8BpC;;;AACA,WAAK,IAAIM,EAAE,GAAG5B,IAAI,CAACK,EAAD,CAAb,EAAmBmB,EAAE,GAAGzB,MAAM,CAACvD,MAA/B,EAAuCiF,CAAC,GAAGG,EAAhD,EAAoDH,CAAC,GAAGD,EAAxD,EAA4DC,CAAC,EAA7D,EAAiE;AAC/D;AACA,YAAIC,EAAE,GAAG3B,MAAM,CAAC0B,CAAD,CAAf,CAF+D,CAG/D;;AACA3B,QAAAA,OAAO,CAAC2B,CAAD,CAAP,GAAarC,CAAC,CAACsC,EAAD,CAAd;AACD;AACF,KAjG6C,CAkG9C;;;AACA1B,IAAAA,IAAI,CAACpC,QAAD,CAAJ,GAAiBmC,MAAM,CAACvD,MAAxB,CAnG8C,CAqG9C;;AACA,WAAOyB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,WAASe,iCAAT,CAA2CpC,CAA3C,EAA8CC,CAA9C,EAAiD;AAC/C;AACA,QAAIiE,OAAO,GAAGlE,CAAC,CAAC0C,OAAhB;AACA,QAAIyB,MAAM,GAAGnE,CAAC,CAAC4C,MAAf;AACA,QAAIwB,IAAI,GAAGpE,CAAC,CAAC8C,IAAb;AACA,QAAIpC,GAAG,GAAGV,CAAC,CAACW,SAAZ,CAL+C,CAM/C;;AACA,QAAI8B,OAAO,GAAGxC,CAAC,CAACyC,OAAhB;AACA,QAAIC,MAAM,GAAG1C,CAAC,CAAC2C,MAAf;AACA,QAAIC,IAAI,GAAG5C,CAAC,CAAC6C,IAAb;AACA,QAAIhC,GAAG,GAAGb,CAAC,CAACU,SAAZ,CAV+C,CAY/C;;AACA,QAAI0B,KAAK,GAAGrC,CAAC,CAACS,KAAF,CAAQ,CAAR,CAAZ;AACA,QAAIO,QAAQ,GAAGf,CAAC,CAACQ,KAAF,CAAQ,CAAR,CAAf,CAd+C,CAe/C;;AACA,QAAI6C,MAAM,GAAGY,OAAO,IAAIzB,OAAxB,CAhB+C,CAkB/C;;AACA,QAAIxB,EAAJ,CAnB+C,CAoB/C;;AACA,QAAIC,EAAE,GAAG/B,SAAT,CArB+C,CAsB/C;;AACA,QAAIgC,EAAE,GAAG/B,cAAT,CAvB+C,CAyB/C;;AACA,QAAIsB,GAAG,IAAII,GAAP,IAAcJ,GAAG,KAAKI,GAAtB,IAA6B,OAAOJ,GAAP,KAAe,QAAhD,EAA0D;AACxD;AACAO,MAAAA,EAAE,GAAGP,GAAL,CAFwD,CAGxD;;AACAQ,MAAAA,EAAE,GAAGjC,KAAK,CAACmC,IAAN,CAAWjC,SAAX,EAAsB,CAAC8B,EAAD,EAAKA,EAAL,CAAtB,CAAL;AACAE,MAAAA,EAAE,GAAGlC,KAAK,CAACmC,IAAN,CAAWhC,cAAX,EAA2B,CAAC6B,EAAD,EAAKA,EAAL,CAA3B,CAAL;AACD,KAhC8C,CAkC/C;;;AACA,QAAIiC,OAAO,GAAGI,MAAM,GAAG,EAAH,GAAQ2B,SAA5B;AACA,QAAI9B,MAAM,GAAG,EAAb;AACA,QAAIC,IAAI,GAAG,EAAX,CArC+C,CAsC/C;;AACA,QAAI/B,CAAC,GAAGrB,CAAC,CAACqD,kBAAF,CAAqB;AAC3BC,MAAAA,MAAM,EAAEJ,OADmB;AAE3BK,MAAAA,KAAK,EAAEJ,MAFoB;AAG3BK,MAAAA,GAAG,EAAEJ,IAHsB;AAI3BzB,MAAAA,IAAI,EAAE,CAACU,KAAD,EAAQrB,QAAR,CAJqB;AAK3BY,MAAAA,QAAQ,EAAEX;AALiB,KAArB,CAAR,CAvC+C,CA+C/C;;AACA,QAAIuB,CAAC,GAAGc,MAAM,GAAG,EAAH,GAAQ2B,SAAtB,CAhD+C,CAiD/C;;AACA,QAAIX,CAAC,GAAG,EAAR,CAlD+C,CAmD/C;;AACA,QAAII,EAAJ,EAAQF,GAAR,EAAaC,GAAb,EAAkBV,EAAlB,EAAsBL,GAAtB,EAA2BC,GAA3B,EAAgCgB,EAAhC,EAAoCX,EAApC,CApD+C,CAqD/C;;AACA,SAAK,IAAIP,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGzC,QAAtB,EAAgCyC,EAAE,EAAlC,EAAsC;AACpC;AACAL,MAAAA,IAAI,CAACK,EAAD,CAAJ,GAAWN,MAAM,CAACvD,MAAlB,CAFoC,CAGpC;;AACA,UAAIiE,IAAI,GAAGJ,EAAE,GAAG,CAAhB,CAJoC,CAKpC;;AACA,WAAKC,GAAG,GAAGb,IAAI,CAACY,EAAD,CAAV,EAAgBE,GAAG,GAAGd,IAAI,CAACY,EAAE,GAAG,CAAN,CAA1B,EAAoCM,EAAE,GAAGL,GAA9C,EAAmDK,EAAE,GAAGJ,GAAxD,EAA6DI,EAAE,EAA/D,EAAmE;AACjE;AACAC,QAAAA,EAAE,GAAGrB,MAAM,CAACoB,EAAD,CAAX,CAFiE,CAGjE;;AACA,YAAIT,MAAJ,EAAY;AACV;AACA,eAAKkB,GAAG,GAAGJ,IAAI,CAACJ,EAAD,CAAV,EAAgBS,GAAG,GAAGL,IAAI,CAACJ,EAAE,GAAG,CAAN,CAA1B,EAAoCU,EAAE,GAAGF,GAA9C,EAAmDE,EAAE,GAAGD,GAAxD,EAA6DC,EAAE,EAA/D,EAAmE;AACjE;AACAC,YAAAA,EAAE,GAAGR,MAAM,CAACO,EAAD,CAAX,CAFiE,CAGjE;;AACA,gBAAIJ,CAAC,CAACK,EAAD,CAAD,KAAUd,IAAd,EAAoB;AAClB;AACAS,cAAAA,CAAC,CAACK,EAAD,CAAD,GAAQd,IAAR,CAFkB,CAGlB;;AACAV,cAAAA,MAAM,CAACc,IAAP,CAAYU,EAAZ,EAJkB,CAKlB;;AACAnC,cAAAA,CAAC,CAACmC,EAAD,CAAD,GAAQxD,EAAE,CAACsB,OAAO,CAACsB,EAAD,CAAR,EAAcG,OAAO,CAACQ,EAAD,CAArB,CAAV;AACD,aAPD,MAOO;AACL;AACAlC,cAAAA,CAAC,CAACmC,EAAD,CAAD,GAAQzD,EAAE,CAACsB,CAAC,CAACmC,EAAD,CAAF,EAAQxD,EAAE,CAACsB,OAAO,CAACsB,EAAD,CAAR,EAAcG,OAAO,CAACQ,EAAD,CAArB,CAAV,CAAV;AACD;AACF;AACF,SAlBD,MAkBO;AACL;AACA,eAAKF,GAAG,GAAGJ,IAAI,CAACJ,EAAD,CAAV,EAAgBS,GAAG,GAAGL,IAAI,CAACJ,EAAE,GAAG,CAAN,CAA1B,EAAoCU,EAAE,GAAGF,GAA9C,EAAmDE,EAAE,GAAGD,GAAxD,EAA6DC,EAAE,EAA/D,EAAmE;AACjE;AACAC,YAAAA,EAAE,GAAGR,MAAM,CAACO,EAAD,CAAX,CAFiE,CAGjE;;AACA,gBAAIJ,CAAC,CAACK,EAAD,CAAD,KAAUd,IAAd,EAAoB;AAClB;AACAS,cAAAA,CAAC,CAACK,EAAD,CAAD,GAAQd,IAAR,CAFkB,CAGlB;;AACAV,cAAAA,MAAM,CAACc,IAAP,CAAYU,EAAZ;AACD;AACF;AACF;AACF,OA1CmC,CA2CpC;;;AACA,UAAIrB,MAAJ,EAAY;AACV;AACA,aAAK,IAAI0B,EAAE,GAAG5B,IAAI,CAACK,EAAD,CAAb,EAAmBmB,EAAE,GAAGzB,MAAM,CAACvD,MAA/B,EAAuCiF,CAAC,GAAGG,EAAhD,EAAoDH,CAAC,GAAGD,EAAxD,EAA4DC,CAAC,EAA7D,EAAiE;AAC/D;AACA,cAAIC,EAAE,GAAG3B,MAAM,CAAC0B,CAAD,CAAf,CAF+D,CAG/D;;AACA3B,UAAAA,OAAO,CAAC2B,CAAD,CAAP,GAAarC,CAAC,CAACsC,EAAD,CAAd;AACD;AACF;AACF,KA3G8C,CA4G/C;;;AACA1B,IAAAA,IAAI,CAACpC,QAAD,CAAJ,GAAiBmC,MAAM,CAACvD,MAAxB,CA7G+C,CA+G/C;;AACA,WAAOyB,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACE,SAAOpC,KAAK,CAACJ,IAAD,EAAOO,cAAP,EAAuB;AACjC;AAEA,oBAAgBH,KAAK,CAACiG,OAAN,CAAc,gBAAd,EAAgCC,MAAM,IAAI,CAAC3C,CAAD,EAAI4C,CAAJ,KAAU;AAClE;AACA3F,MAAAA,yBAAyB,CAACf,SAAS,CAAC8D,CAAD,CAAV,EAAe9D,SAAS,CAAC0G,CAAD,CAAxB,CAAzB,CAFkE,CAIlE;;;AACA,UAAIC,CAAC,GAAGF,MAAM,CAACjG,MAAM,CAACsD,CAAD,CAAP,EAAYtD,MAAM,CAACkG,CAAD,CAAlB,CAAd,CALkE,CAMlE;;AACA,aAAO3G,QAAQ,CAAC4G,CAAD,CAAR,GAAcA,CAAC,CAACC,OAAF,EAAd,GAA4BD,CAAnC;AACD,KARe,CAHiB;AAYjC,sBAAkB,SAASE,YAAT,CAAsB/C,CAAtB,EAAyB4C,CAAzB,EAA4B;AAC5C;AACA,UAAII,KAAK,GAAGhD,CAAC,CAACb,IAAF,EAAZ;AACA,UAAI8D,KAAK,GAAGL,CAAC,CAACzD,IAAF,EAAZ,CAH4C,CAK5C;;AACAlC,MAAAA,yBAAyB,CAAC+F,KAAD,EAAQC,KAAR,CAAzB,CAN4C,CAQ5C;;;AACA,UAAID,KAAK,CAAC5F,MAAN,KAAiB,CAArB,EAAwB;AACtB;AACA,YAAI6F,KAAK,CAAC7F,MAAN,KAAiB,CAArB,EAAwB;AACtB;AACA,iBAAOG,qBAAqB,CAACyC,CAAD,EAAI4C,CAAJ,EAAOI,KAAK,CAAC,CAAD,CAAZ,CAA5B;AACD,SALqB,CAMtB;;;AACA,eAAOrF,qBAAqB,CAACqC,CAAD,EAAI4C,CAAJ,CAA5B;AACD,OAjB2C,CAkB5C;;;AACA,UAAIK,KAAK,CAAC7F,MAAN,KAAiB,CAArB,EAAwB;AACtB;AACA,eAAOiC,qBAAqB,CAACW,CAAD,EAAI4C,CAAJ,CAA5B;AACD,OAtB2C,CAuB5C;;;AACA,aAAOpD,qBAAqB,CAACQ,CAAD,EAAI4C,CAAJ,CAA5B;AACD,KArCgC;AAsCjC,qBAAiBnG,KAAK,CAACiG,OAAN,CAAc,eAAd,EAA+BC,MAAM,IAAI,CAAC3C,CAAD,EAAI4C,CAAJ,KAAUD,MAAM,CAAC3C,CAAD,EAAItD,MAAM,CAACkG,CAAD,CAAV,CAAzD,CAtCgB;AAuCjC,qBAAiBnG,KAAK,CAACyG,WAAN,CAAkBC,IAAI,IAAI,CAACnD,CAAD,EAAI4C,CAAJ,KAAU;AACnD;AACA,aAAOO,IAAI,CAACzG,MAAM,CAACsD,CAAD,EAAI4C,CAAC,CAAChF,OAAF,EAAJ,CAAP,EAAyBgF,CAAzB,CAAX;AACD,KAHgB,CAvCgB;AA2CjC,yBAAqB,SAASQ,eAAT,CAAyBpD,CAAzB,EAA4B4C,CAA5B,EAA+B;AAClD,aAAO7F,aAAa,CAACiD,CAAD,EAAI4C,CAAJ,EAAOhG,cAAP,EAAuB,KAAvB,CAApB;AACD,KA7CgC;AA8CjC,wBAAoB,SAASyG,cAAT,CAAwBrD,CAAxB,EAA2B4C,CAA3B,EAA8B;AAChD,aAAO5F,YAAY,CAACgD,CAAD,EAAI4C,CAAJ,EAAOhG,cAAP,EAAuB,KAAvB,CAAnB;AACD,KAhDgC;AAiDjC,yBAAqB,SAAS0G,eAAT,CAAyBtD,CAAzB,EAA4B4C,CAA5B,EAA+B;AAClD,aAAO7F,aAAa,CAAC6F,CAAD,EAAI5C,CAAJ,EAAOpD,cAAP,EAAuB,IAAvB,CAApB;AACD,KAnDgC;AAoDjC,wBAAoB,SAAS2G,cAAT,CAAwBvD,CAAxB,EAA2B4C,CAA3B,EAA8B;AAChD,aAAO5F,YAAY,CAAC4F,CAAD,EAAI5C,CAAJ,EAAOpD,cAAP,EAAuB,IAAvB,CAAnB;AACD,KAtDgC;AAuDjC,kBAAc,SAAS4G,QAAT,CAAkBxD,CAAlB,EAAqB4C,CAArB,EAAwB;AACpC;AACA,aAAO5F,YAAY,CAACN,MAAM,CAACsD,CAAD,CAAP,EAAY4C,CAAZ,EAAehG,cAAf,EAA+B,KAA/B,CAAZ,CAAkDkG,OAAlD,EAAP;AACD,KA1DgC;AA2DjC,kBAAc,SAASW,QAAT,CAAkBzD,CAAlB,EAAqB4C,CAArB,EAAwB;AACpC;AACA,aAAO5F,YAAY,CAACN,MAAM,CAACkG,CAAD,CAAP,EAAY5C,CAAZ,EAAepD,cAAf,EAA+B,IAA/B,CAAZ,CAAiDkG,OAAjD,EAAP;AACD,KA9DgC;AA+DjC,gBAAYlG,cA/DqB;AAgEjC,wBAAoBH,KAAK,CAACyG,WAAN,CAAkBC,IAAI,IAAI,CAACnD,CAAD,EAAI4C,CAAJ,EAAOc,IAAP,KAAgB;AAC5D,UAAIC,MAAM,GAAGR,IAAI,CAACnD,CAAD,EAAI4C,CAAJ,CAAjB;;AACA,WAAK,IAAI5D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0E,IAAI,CAACtG,MAAzB,EAAiC4B,CAAC,EAAlC,EAAsC;AACpC2E,QAAAA,MAAM,GAAGR,IAAI,CAACQ,MAAD,EAASD,IAAI,CAAC1E,CAAD,CAAb,CAAb;AACD;;AACD,aAAO2E,MAAP;AACD,KANmB;AAhEa,GAAvB,CAAZ;AAwED,CAv2BiD,CAA3C","sourcesContent":["import { factory } from '../../utils/factory.js';\r\nimport { isMatrix } from '../../utils/is.js';\r\nimport { arraySize } from '../../utils/array.js';\r\nimport { createMatAlgo11xS0s } from '../../type/matrix/utils/matAlgo11xS0s.js';\r\nimport { createMatAlgo14xDs } from '../../type/matrix/utils/matAlgo14xDs.js';\r\nvar name = 'multiply';\r\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'equalScalar', 'dot'];\r\nexport var createMultiply = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    addScalar,\r\n    multiplyScalar,\r\n    equalScalar,\r\n    dot\r\n  } = _ref;\r\n  var matAlgo11xS0s = createMatAlgo11xS0s({\r\n    typed,\r\n    equalScalar\r\n  });\r\n  var matAlgo14xDs = createMatAlgo14xDs({\r\n    typed\r\n  });\r\n  function _validateMatrixDimensions(size1, size2) {\r\n    // check left operand dimensions\r\n    switch (size1.length) {\r\n      case 1:\r\n        // check size2\r\n        switch (size2.length) {\r\n          case 1:\r\n            // Vector x Vector\r\n            if (size1[0] !== size2[0]) {\r\n              // throw error\r\n              throw new RangeError('Dimension mismatch in multiplication. Vectors must have the same length');\r\n            }\r\n            break;\r\n          case 2:\r\n            // Vector x Matrix\r\n            if (size1[0] !== size2[0]) {\r\n              // throw error\r\n              throw new RangeError('Dimension mismatch in multiplication. Vector length (' + size1[0] + ') must match Matrix rows (' + size2[0] + ')');\r\n            }\r\n            break;\r\n          default:\r\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\r\n        }\r\n        break;\r\n      case 2:\r\n        // check size2\r\n        switch (size2.length) {\r\n          case 1:\r\n            // Matrix x Vector\r\n            if (size1[1] !== size2[0]) {\r\n              // throw error\r\n              throw new RangeError('Dimension mismatch in multiplication. Matrix columns (' + size1[1] + ') must match Vector length (' + size2[0] + ')');\r\n            }\r\n            break;\r\n          case 2:\r\n            // Matrix x Matrix\r\n            if (size1[1] !== size2[0]) {\r\n              // throw error\r\n              throw new RangeError('Dimension mismatch in multiplication. Matrix A columns (' + size1[1] + ') must match Matrix B rows (' + size2[0] + ')');\r\n            }\r\n            break;\r\n          default:\r\n            throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix B has ' + size2.length + ' dimensions)');\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error('Can only multiply a 1 or 2 dimensional matrix (Matrix A has ' + size1.length + ' dimensions)');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Dense Vector   (N)\r\n   * @param {Matrix} b            Dense Vector   (N)\r\n   *\r\n   * @return {number}             Scalar value\r\n   */\r\n  function _multiplyVectorVector(a, b, n) {\r\n    // check empty vector\r\n    if (n === 0) {\r\n      throw new Error('Cannot multiply two empty vectors');\r\n    }\r\n    return dot(a, b);\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Dense Vector   (M)\r\n   * @param {Matrix} b            Matrix         (MxN)\r\n   *\r\n   * @return {Matrix}             Dense Vector   (N)\r\n   */\r\n  function _multiplyVectorMatrix(a, b) {\r\n    // process storage\r\n    if (b.storage() !== 'dense') {\r\n      throw new Error('Support for SparseMatrix not implemented');\r\n    }\r\n    return _multiplyVectorDenseMatrix(a, b);\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Dense Vector   (M)\r\n   * @param {Matrix} b            Dense Matrix   (MxN)\r\n   *\r\n   * @return {Matrix}             Dense Vector   (N)\r\n   */\r\n  function _multiplyVectorDenseMatrix(a, b) {\r\n    // a dense\r\n    var adata = a._data;\r\n    var asize = a._size;\r\n    var adt = a._datatype;\r\n    // b dense\r\n    var bdata = b._data;\r\n    var bsize = b._size;\r\n    var bdt = b._datatype;\r\n    // rows & columns\r\n    var alength = asize[0];\r\n    var bcolumns = bsize[1];\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n    }\r\n\r\n    // result\r\n    var c = [];\r\n\r\n    // loop matrix columns\r\n    for (var j = 0; j < bcolumns; j++) {\r\n      // sum (do not initialize it with zero)\r\n      var sum = mf(adata[0], bdata[0][j]);\r\n      // loop vector\r\n      for (var i = 1; i < alength; i++) {\r\n        // multiply & accumulate\r\n        sum = af(sum, mf(adata[i], bdata[i][j]));\r\n      }\r\n      c[j] = sum;\r\n    }\r\n\r\n    // return matrix\r\n    return a.createDenseMatrix({\r\n      data: c,\r\n      size: [bcolumns],\r\n      datatype: dt\r\n    });\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Matrix         (MxN)\r\n   * @param {Matrix} b            Dense Vector   (N)\r\n   *\r\n   * @return {Matrix}             Dense Vector   (M)\r\n   */\r\n  var _multiplyMatrixVector = typed('_multiplyMatrixVector', {\r\n    'DenseMatrix, any': _multiplyDenseMatrixVector,\r\n    'SparseMatrix, any': _multiplySparseMatrixVector\r\n  });\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            Matrix         (MxN)\r\n   * @param {Matrix} b            Matrix         (NxC)\r\n   *\r\n   * @return {Matrix}             Matrix         (MxC)\r\n   */\r\n  var _multiplyMatrixMatrix = typed('_multiplyMatrixMatrix', {\r\n    'DenseMatrix, DenseMatrix': _multiplyDenseMatrixDenseMatrix,\r\n    'DenseMatrix, SparseMatrix': _multiplyDenseMatrixSparseMatrix,\r\n    'SparseMatrix, DenseMatrix': _multiplySparseMatrixDenseMatrix,\r\n    'SparseMatrix, SparseMatrix': _multiplySparseMatrixSparseMatrix\r\n  });\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            DenseMatrix  (MxN)\r\n   * @param {Matrix} b            Dense Vector (N)\r\n   *\r\n   * @return {Matrix}             Dense Vector (M)\r\n   */\r\n  function _multiplyDenseMatrixVector(a, b) {\r\n    // a dense\r\n    var adata = a._data;\r\n    var asize = a._size;\r\n    var adt = a._datatype;\r\n    // b dense\r\n    var bdata = b._data;\r\n    var bdt = b._datatype;\r\n    // rows & columns\r\n    var arows = asize[0];\r\n    var acolumns = asize[1];\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n    }\r\n\r\n    // result\r\n    var c = [];\r\n\r\n    // loop matrix a rows\r\n    for (var i = 0; i < arows; i++) {\r\n      // current row\r\n      var row = adata[i];\r\n      // sum (do not initialize it with zero)\r\n      var sum = mf(row[0], bdata[0]);\r\n      // loop matrix a columns\r\n      for (var j = 1; j < acolumns; j++) {\r\n        // multiply & accumulate\r\n        sum = af(sum, mf(row[j], bdata[j]));\r\n      }\r\n      c[i] = sum;\r\n    }\r\n\r\n    // return matrix\r\n    return a.createDenseMatrix({\r\n      data: c,\r\n      size: [arows],\r\n      datatype: dt\r\n    });\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            DenseMatrix    (MxN)\r\n   * @param {Matrix} b            DenseMatrix    (NxC)\r\n   *\r\n   * @return {Matrix}             DenseMatrix    (MxC)\r\n   */\r\n  function _multiplyDenseMatrixDenseMatrix(a, b) {\r\n    // a dense\r\n    var adata = a._data;\r\n    var asize = a._size;\r\n    var adt = a._datatype;\r\n    // b dense\r\n    var bdata = b._data;\r\n    var bsize = b._size;\r\n    var bdt = b._datatype;\r\n    // rows & columns\r\n    var arows = asize[0];\r\n    var acolumns = asize[1];\r\n    var bcolumns = bsize[1];\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n    }\r\n\r\n    // result\r\n    var c = [];\r\n\r\n    // loop matrix a rows\r\n    for (var i = 0; i < arows; i++) {\r\n      // current row\r\n      var row = adata[i];\r\n      // initialize row array\r\n      c[i] = [];\r\n      // loop matrix b columns\r\n      for (var j = 0; j < bcolumns; j++) {\r\n        // sum (avoid initializing sum to zero)\r\n        var sum = mf(row[0], bdata[0][j]);\r\n        // loop matrix a columns\r\n        for (var x = 1; x < acolumns; x++) {\r\n          // multiply & accumulate\r\n          sum = af(sum, mf(row[x], bdata[x][j]));\r\n        }\r\n        c[i][j] = sum;\r\n      }\r\n    }\r\n\r\n    // return matrix\r\n    return a.createDenseMatrix({\r\n      data: c,\r\n      size: [arows, bcolumns],\r\n      datatype: dt\r\n    });\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            DenseMatrix    (MxN)\r\n   * @param {Matrix} b            SparseMatrix   (NxC)\r\n   *\r\n   * @return {Matrix}             SparseMatrix   (MxC)\r\n   */\r\n  function _multiplyDenseMatrixSparseMatrix(a, b) {\r\n    // a dense\r\n    var adata = a._data;\r\n    var asize = a._size;\r\n    var adt = a._datatype;\r\n    // b sparse\r\n    var bvalues = b._values;\r\n    var bindex = b._index;\r\n    var bptr = b._ptr;\r\n    var bsize = b._size;\r\n    var bdt = b._datatype;\r\n    // validate b matrix\r\n    if (!bvalues) {\r\n      throw new Error('Cannot multiply Dense Matrix times Pattern only Matrix');\r\n    }\r\n    // rows & columns\r\n    var arows = asize[0];\r\n    var bcolumns = bsize[1];\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n    // equalScalar signature to use\r\n    var eq = equalScalar;\r\n    // zero value\r\n    var zero = 0;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n      eq = typed.find(equalScalar, [dt, dt]);\r\n      // convert 0 to the same datatype\r\n      zero = typed.convert(0, dt);\r\n    }\r\n\r\n    // result\r\n    var cvalues = [];\r\n    var cindex = [];\r\n    var cptr = [];\r\n    // c matrix\r\n    var c = b.createSparseMatrix({\r\n      values: cvalues,\r\n      index: cindex,\r\n      ptr: cptr,\r\n      size: [arows, bcolumns],\r\n      datatype: dt\r\n    });\r\n\r\n    // loop b columns\r\n    for (var jb = 0; jb < bcolumns; jb++) {\r\n      // update ptr\r\n      cptr[jb] = cindex.length;\r\n      // indeces in column jb\r\n      var kb0 = bptr[jb];\r\n      var kb1 = bptr[jb + 1];\r\n      // do not process column jb if no data exists\r\n      if (kb1 > kb0) {\r\n        // last row mark processed\r\n        var last = 0;\r\n        // loop a rows\r\n        for (var i = 0; i < arows; i++) {\r\n          // column mark\r\n          var mark = i + 1;\r\n          // C[i, jb]\r\n          var cij = void 0;\r\n          // values in b column j\r\n          for (var kb = kb0; kb < kb1; kb++) {\r\n            // row\r\n            var ib = bindex[kb];\r\n            // check value has been initialized\r\n            if (last !== mark) {\r\n              // first value in column jb\r\n              cij = mf(adata[i][ib], bvalues[kb]);\r\n              // update mark\r\n              last = mark;\r\n            } else {\r\n              // accumulate value\r\n              cij = af(cij, mf(adata[i][ib], bvalues[kb]));\r\n            }\r\n          }\r\n          // check column has been processed and value != 0\r\n          if (last === mark && !eq(cij, zero)) {\r\n            // push row & value\r\n            cindex.push(i);\r\n            cvalues.push(cij);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // update ptr\r\n    cptr[bcolumns] = cindex.length;\r\n\r\n    // return sparse matrix\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            SparseMatrix    (MxN)\r\n   * @param {Matrix} b            Dense Vector (N)\r\n   *\r\n   * @return {Matrix}             SparseMatrix    (M, 1)\r\n   */\r\n  function _multiplySparseMatrixVector(a, b) {\r\n    // a sparse\r\n    var avalues = a._values;\r\n    var aindex = a._index;\r\n    var aptr = a._ptr;\r\n    var adt = a._datatype;\r\n    // validate a matrix\r\n    if (!avalues) {\r\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\r\n    }\r\n    // b dense\r\n    var bdata = b._data;\r\n    var bdt = b._datatype;\r\n    // rows & columns\r\n    var arows = a._size[0];\r\n    var brows = b._size[0];\r\n    // result\r\n    var cvalues = [];\r\n    var cindex = [];\r\n    var cptr = [];\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n    // equalScalar signature to use\r\n    var eq = equalScalar;\r\n    // zero value\r\n    var zero = 0;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n      eq = typed.find(equalScalar, [dt, dt]);\r\n      // convert 0 to the same datatype\r\n      zero = typed.convert(0, dt);\r\n    }\r\n\r\n    // workspace\r\n    var x = [];\r\n    // vector with marks indicating a value x[i] exists in a given column\r\n    var w = [];\r\n\r\n    // update ptr\r\n    cptr[0] = 0;\r\n    // rows in b\r\n    for (var ib = 0; ib < brows; ib++) {\r\n      // b[ib]\r\n      var vbi = bdata[ib];\r\n      // check b[ib] != 0, avoid loops\r\n      if (!eq(vbi, zero)) {\r\n        // A values & index in ib column\r\n        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\r\n          // a row\r\n          var ia = aindex[ka];\r\n          // check value exists in current j\r\n          if (!w[ia]) {\r\n            // ia is new entry in j\r\n            w[ia] = true;\r\n            // add i to pattern of C\r\n            cindex.push(ia);\r\n            // x(ia) = A\r\n            x[ia] = mf(vbi, avalues[ka]);\r\n          } else {\r\n            // i exists in C already\r\n            x[ia] = af(x[ia], mf(vbi, avalues[ka]));\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // copy values from x to column jb of c\r\n    for (var p1 = cindex.length, p = 0; p < p1; p++) {\r\n      // row\r\n      var ic = cindex[p];\r\n      // copy value\r\n      cvalues[p] = x[ic];\r\n    }\r\n    // update ptr\r\n    cptr[1] = cindex.length;\r\n\r\n    // return sparse matrix\r\n    return a.createSparseMatrix({\r\n      values: cvalues,\r\n      index: cindex,\r\n      ptr: cptr,\r\n      size: [arows, 1],\r\n      datatype: dt\r\n    });\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            SparseMatrix      (MxN)\r\n   * @param {Matrix} b            DenseMatrix       (NxC)\r\n   *\r\n   * @return {Matrix}             SparseMatrix      (MxC)\r\n   */\r\n  function _multiplySparseMatrixDenseMatrix(a, b) {\r\n    // a sparse\r\n    var avalues = a._values;\r\n    var aindex = a._index;\r\n    var aptr = a._ptr;\r\n    var adt = a._datatype;\r\n    // validate a matrix\r\n    if (!avalues) {\r\n      throw new Error('Cannot multiply Pattern only Matrix times Dense Matrix');\r\n    }\r\n    // b dense\r\n    var bdata = b._data;\r\n    var bdt = b._datatype;\r\n    // rows & columns\r\n    var arows = a._size[0];\r\n    var brows = b._size[0];\r\n    var bcolumns = b._size[1];\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n    // equalScalar signature to use\r\n    var eq = equalScalar;\r\n    // zero value\r\n    var zero = 0;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n      eq = typed.find(equalScalar, [dt, dt]);\r\n      // convert 0 to the same datatype\r\n      zero = typed.convert(0, dt);\r\n    }\r\n\r\n    // result\r\n    var cvalues = [];\r\n    var cindex = [];\r\n    var cptr = [];\r\n    // c matrix\r\n    var c = a.createSparseMatrix({\r\n      values: cvalues,\r\n      index: cindex,\r\n      ptr: cptr,\r\n      size: [arows, bcolumns],\r\n      datatype: dt\r\n    });\r\n\r\n    // workspace\r\n    var x = [];\r\n    // vector with marks indicating a value x[i] exists in a given column\r\n    var w = [];\r\n\r\n    // loop b columns\r\n    for (var jb = 0; jb < bcolumns; jb++) {\r\n      // update ptr\r\n      cptr[jb] = cindex.length;\r\n      // mark in workspace for current column\r\n      var mark = jb + 1;\r\n      // rows in jb\r\n      for (var ib = 0; ib < brows; ib++) {\r\n        // b[ib, jb]\r\n        var vbij = bdata[ib][jb];\r\n        // check b[ib, jb] != 0, avoid loops\r\n        if (!eq(vbij, zero)) {\r\n          // A values & index in ib column\r\n          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\r\n            // a row\r\n            var ia = aindex[ka];\r\n            // check value exists in current j\r\n            if (w[ia] !== mark) {\r\n              // ia is new entry in j\r\n              w[ia] = mark;\r\n              // add i to pattern of C\r\n              cindex.push(ia);\r\n              // x(ia) = A\r\n              x[ia] = mf(vbij, avalues[ka]);\r\n            } else {\r\n              // i exists in C already\r\n              x[ia] = af(x[ia], mf(vbij, avalues[ka]));\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // copy values from x to column jb of c\r\n      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\r\n        // row\r\n        var ic = cindex[p];\r\n        // copy value\r\n        cvalues[p] = x[ic];\r\n      }\r\n    }\r\n    // update ptr\r\n    cptr[bcolumns] = cindex.length;\r\n\r\n    // return sparse matrix\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * C = A * B\r\n   *\r\n   * @param {Matrix} a            SparseMatrix      (MxN)\r\n   * @param {Matrix} b            SparseMatrix      (NxC)\r\n   *\r\n   * @return {Matrix}             SparseMatrix      (MxC)\r\n   */\r\n  function _multiplySparseMatrixSparseMatrix(a, b) {\r\n    // a sparse\r\n    var avalues = a._values;\r\n    var aindex = a._index;\r\n    var aptr = a._ptr;\r\n    var adt = a._datatype;\r\n    // b sparse\r\n    var bvalues = b._values;\r\n    var bindex = b._index;\r\n    var bptr = b._ptr;\r\n    var bdt = b._datatype;\r\n\r\n    // rows & columns\r\n    var arows = a._size[0];\r\n    var bcolumns = b._size[1];\r\n    // flag indicating both matrices (a & b) contain data\r\n    var values = avalues && bvalues;\r\n\r\n    // datatype\r\n    var dt;\r\n    // addScalar signature to use\r\n    var af = addScalar;\r\n    // multiplyScalar signature to use\r\n    var mf = multiplyScalar;\r\n\r\n    // process data types\r\n    if (adt && bdt && adt === bdt && typeof adt === 'string') {\r\n      // datatype\r\n      dt = adt;\r\n      // find signatures that matches (dt, dt)\r\n      af = typed.find(addScalar, [dt, dt]);\r\n      mf = typed.find(multiplyScalar, [dt, dt]);\r\n    }\r\n\r\n    // result\r\n    var cvalues = values ? [] : undefined;\r\n    var cindex = [];\r\n    var cptr = [];\r\n    // c matrix\r\n    var c = a.createSparseMatrix({\r\n      values: cvalues,\r\n      index: cindex,\r\n      ptr: cptr,\r\n      size: [arows, bcolumns],\r\n      datatype: dt\r\n    });\r\n\r\n    // workspace\r\n    var x = values ? [] : undefined;\r\n    // vector with marks indicating a value x[i] exists in a given column\r\n    var w = [];\r\n    // variables\r\n    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;\r\n    // loop b columns\r\n    for (var jb = 0; jb < bcolumns; jb++) {\r\n      // update ptr\r\n      cptr[jb] = cindex.length;\r\n      // mark in workspace for current column\r\n      var mark = jb + 1;\r\n      // B values & index in j\r\n      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {\r\n        // b row\r\n        ib = bindex[kb];\r\n        // check we need to process values\r\n        if (values) {\r\n          // loop values in a[:,ib]\r\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\r\n            // row\r\n            ia = aindex[ka];\r\n            // check value exists in current j\r\n            if (w[ia] !== mark) {\r\n              // ia is new entry in j\r\n              w[ia] = mark;\r\n              // add i to pattern of C\r\n              cindex.push(ia);\r\n              // x(ia) = A\r\n              x[ia] = mf(bvalues[kb], avalues[ka]);\r\n            } else {\r\n              // i exists in C already\r\n              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));\r\n            }\r\n          }\r\n        } else {\r\n          // loop values in a[:,ib]\r\n          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {\r\n            // row\r\n            ia = aindex[ka];\r\n            // check value exists in current j\r\n            if (w[ia] !== mark) {\r\n              // ia is new entry in j\r\n              w[ia] = mark;\r\n              // add i to pattern of C\r\n              cindex.push(ia);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // check we need to process matrix values (pattern matrix)\r\n      if (values) {\r\n        // copy values from x to column jb of c\r\n        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {\r\n          // row\r\n          var ic = cindex[p];\r\n          // copy value\r\n          cvalues[p] = x[ic];\r\n        }\r\n      }\r\n    }\r\n    // update ptr\r\n    cptr[bcolumns] = cindex.length;\r\n\r\n    // return sparse matrix\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * Multiply two or more values, `x * y`.\r\n   * For matrices, the matrix product is calculated.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.multiply(x, y)\r\n   *    math.multiply(x, y, z, ...)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.multiply(4, 5.2)        // returns number 20.8\r\n   *    math.multiply(2, 3, 4)       // returns number 24\r\n   *\r\n   *    const a = math.complex(2, 3)\r\n   *    const b = math.complex(4, 1)\r\n   *    math.multiply(a, b)          // returns Complex 5 + 14i\r\n   *\r\n   *    const c = [[1, 2], [4, 3]]\r\n   *    const d = [[1, 2, 3], [3, -4, 7]]\r\n   *    math.multiply(c, d)          // returns Array [[7, -6, 17], [13, -4, 33]]\r\n   *\r\n   *    const e = math.unit('2.1 km')\r\n   *    math.multiply(3, e)          // returns Unit 6.3 km\r\n   *\r\n   * See also:\r\n   *\r\n   *    divide, prod, cross, dot\r\n   *\r\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} x First value to multiply\r\n   * @param  {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} y Second value to multiply\r\n   * @return {number | BigNumber | Fraction | Complex | Unit | Array | Matrix} Multiplication of `x` and `y`\r\n   */\r\n  return typed(name, multiplyScalar, {\r\n    // we extend the signatures of multiplyScalar with signatures dealing with matrices\r\n\r\n    'Array, Array': typed.referTo('Matrix, Matrix', selfMM => (x, y) => {\r\n      // check dimensions\r\n      _validateMatrixDimensions(arraySize(x), arraySize(y));\r\n\r\n      // use dense matrix implementation\r\n      var m = selfMM(matrix(x), matrix(y));\r\n      // return array or scalar\r\n      return isMatrix(m) ? m.valueOf() : m;\r\n    }),\r\n    'Matrix, Matrix': function MatrixMatrix(x, y) {\r\n      // dimensions\r\n      var xsize = x.size();\r\n      var ysize = y.size();\r\n\r\n      // check dimensions\r\n      _validateMatrixDimensions(xsize, ysize);\r\n\r\n      // process dimensions\r\n      if (xsize.length === 1) {\r\n        // process y dimensions\r\n        if (ysize.length === 1) {\r\n          // Vector * Vector\r\n          return _multiplyVectorVector(x, y, xsize[0]);\r\n        }\r\n        // Vector * Matrix\r\n        return _multiplyVectorMatrix(x, y);\r\n      }\r\n      // process y dimensions\r\n      if (ysize.length === 1) {\r\n        // Matrix * Vector\r\n        return _multiplyMatrixVector(x, y);\r\n      }\r\n      // Matrix * Matrix\r\n      return _multiplyMatrixMatrix(x, y);\r\n    },\r\n    'Matrix, Array': typed.referTo('Matrix,Matrix', selfMM => (x, y) => selfMM(x, matrix(y))),\r\n    'Array, Matrix': typed.referToSelf(self => (x, y) => {\r\n      // use Matrix * Matrix implementation\r\n      return self(matrix(x, y.storage()), y);\r\n    }),\r\n    'SparseMatrix, any': function SparseMatrixAny(x, y) {\r\n      return matAlgo11xS0s(x, y, multiplyScalar, false);\r\n    },\r\n    'DenseMatrix, any': function DenseMatrixAny(x, y) {\r\n      return matAlgo14xDs(x, y, multiplyScalar, false);\r\n    },\r\n    'any, SparseMatrix': function anySparseMatrix(x, y) {\r\n      return matAlgo11xS0s(y, x, multiplyScalar, true);\r\n    },\r\n    'any, DenseMatrix': function anyDenseMatrix(x, y) {\r\n      return matAlgo14xDs(y, x, multiplyScalar, true);\r\n    },\r\n    'Array, any': function ArrayAny(x, y) {\r\n      // use matrix implementation\r\n      return matAlgo14xDs(matrix(x), y, multiplyScalar, false).valueOf();\r\n    },\r\n    'any, Array': function anyArray(x, y) {\r\n      // use matrix implementation\r\n      return matAlgo14xDs(matrix(y), x, multiplyScalar, true).valueOf();\r\n    },\r\n    'any, any': multiplyScalar,\r\n    'any, any, ...any': typed.referToSelf(self => (x, y, rest) => {\r\n      var result = self(x, y);\r\n      for (var i = 0; i < rest.length; i++) {\r\n        result = self(result, rest[i]);\r\n      }\r\n      return result;\r\n    })\r\n  });\r\n});"]},"metadata":{},"sourceType":"module"}