{"ast":null,"code":"import { csMarked } from './csMarked.js';\nimport { csMark } from './csMark.js';\nimport { csDfs } from './csDfs.js';\n/**\r\n * The csReach function computes X = Reach(B), where B is the nonzero pattern of the n-by-1\r\n * sparse column of vector b. The function returns the set of nodes reachable from any node in B. The\r\n * nonzero pattern xi of the solution x to the sparse linear system Lx=b is given by X=Reach(B).\r\n *\r\n * @param {Matrix}  g               The G matrix\r\n * @param {Matrix}  b               The B matrix\r\n * @param {Number}  k               The kth column in B\r\n * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\r\n *                                  The first n entries is the nonzero pattern, the last n entries is the stack\r\n * @param {Array}   pinv            The inverse row permutation vector\r\n *\r\n * @return {Number}                 The index for the nonzero pattern\r\n *\r\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n */\n\nexport function csReach(g, b, k, xi, pinv) {\n  // g arrays\n  var gptr = g._ptr;\n  var gsize = g._size; // b arrays\n\n  var bindex = b._index;\n  var bptr = b._ptr; // columns\n\n  var n = gsize[1]; // vars\n\n  var p, p0, p1; // initialize top\n\n  var top = n; // loop column indeces in B\n\n  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\n    // node i\n    var i = bindex[p]; // check node i is marked\n\n    if (!csMarked(gptr, i)) {\n      // start a dfs at unmarked node i\n      top = csDfs(i, g, top, xi, pinv);\n    }\n  } // loop columns from top -> n - 1\n\n\n  for (p = top; p < n; p++) {\n    // restore G\n    csMark(gptr, xi[p]);\n  }\n\n  return top;\n}","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js"],"names":["csMarked","csMark","csDfs","csReach","g","b","k","xi","pinv","gptr","_ptr","gsize","_size","bindex","_index","bptr","n","p","p0","p1","top","i"],"mappings":"AAAA,SAASA,QAAT,QAAyB,eAAzB;AACA,SAASC,MAAT,QAAuB,aAAvB;AACA,SAASC,KAAT,QAAsB,YAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,OAAT,CAAiBC,CAAjB,EAAoBC,CAApB,EAAuBC,CAAvB,EAA0BC,EAA1B,EAA8BC,IAA9B,EAAoC;AACzC;AACA,MAAIC,IAAI,GAAGL,CAAC,CAACM,IAAb;AACA,MAAIC,KAAK,GAAGP,CAAC,CAACQ,KAAd,CAHyC,CAIzC;;AACA,MAAIC,MAAM,GAAGR,CAAC,CAACS,MAAf;AACA,MAAIC,IAAI,GAAGV,CAAC,CAACK,IAAb,CANyC,CAOzC;;AACA,MAAIM,CAAC,GAAGL,KAAK,CAAC,CAAD,CAAb,CARyC,CASzC;;AACA,MAAIM,CAAJ,EAAOC,EAAP,EAAWC,EAAX,CAVyC,CAWzC;;AACA,MAAIC,GAAG,GAAGJ,CAAV,CAZyC,CAazC;;AACA,OAAKE,EAAE,GAAGH,IAAI,CAACT,CAAD,CAAT,EAAca,EAAE,GAAGJ,IAAI,CAACT,CAAC,GAAG,CAAL,CAAvB,EAAgCW,CAAC,GAAGC,EAAzC,EAA6CD,CAAC,GAAGE,EAAjD,EAAqDF,CAAC,EAAtD,EAA0D;AACxD;AACA,QAAII,CAAC,GAAGR,MAAM,CAACI,CAAD,CAAd,CAFwD,CAGxD;;AACA,QAAI,CAACjB,QAAQ,CAACS,IAAD,EAAOY,CAAP,CAAb,EAAwB;AACtB;AACAD,MAAAA,GAAG,GAAGlB,KAAK,CAACmB,CAAD,EAAIjB,CAAJ,EAAOgB,GAAP,EAAYb,EAAZ,EAAgBC,IAAhB,CAAX;AACD;AACF,GAtBwC,CAuBzC;;;AACA,OAAKS,CAAC,GAAGG,GAAT,EAAcH,CAAC,GAAGD,CAAlB,EAAqBC,CAAC,EAAtB,EAA0B;AACxB;AACAhB,IAAAA,MAAM,CAACQ,IAAD,EAAOF,EAAE,CAACU,CAAD,CAAT,CAAN;AACD;;AACD,SAAOG,GAAP;AACD","sourcesContent":["import { csMarked } from './csMarked.js';\r\nimport { csMark } from './csMark.js';\r\nimport { csDfs } from './csDfs.js';\r\n\r\n/**\r\n * The csReach function computes X = Reach(B), where B is the nonzero pattern of the n-by-1\r\n * sparse column of vector b. The function returns the set of nodes reachable from any node in B. The\r\n * nonzero pattern xi of the solution x to the sparse linear system Lx=b is given by X=Reach(B).\r\n *\r\n * @param {Matrix}  g               The G matrix\r\n * @param {Matrix}  b               The B matrix\r\n * @param {Number}  k               The kth column in B\r\n * @param {Array}   xi              The nonzero pattern xi[top] .. xi[n - 1], an array of size = 2 * n\r\n *                                  The first n entries is the nonzero pattern, the last n entries is the stack\r\n * @param {Array}   pinv            The inverse row permutation vector\r\n *\r\n * @return {Number}                 The index for the nonzero pattern\r\n *\r\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n */\r\nexport function csReach(g, b, k, xi, pinv) {\r\n  // g arrays\r\n  var gptr = g._ptr;\r\n  var gsize = g._size;\r\n  // b arrays\r\n  var bindex = b._index;\r\n  var bptr = b._ptr;\r\n  // columns\r\n  var n = gsize[1];\r\n  // vars\r\n  var p, p0, p1;\r\n  // initialize top\r\n  var top = n;\r\n  // loop column indeces in B\r\n  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {\r\n    // node i\r\n    var i = bindex[p];\r\n    // check node i is marked\r\n    if (!csMarked(gptr, i)) {\r\n      // start a dfs at unmarked node i\r\n      top = csDfs(i, g, top, xi, pinv);\r\n    }\r\n  }\r\n  // loop columns from top -> n - 1\r\n  for (p = top; p < n; p++) {\r\n    // restore G\r\n    csMark(gptr, xi[p]);\r\n  }\r\n  return top;\r\n}"]},"metadata":{},"sourceType":"module"}