{"ast":null,"code":"import { factory } from '../../../utils/factory.js';\nimport { csLeaf } from './csLeaf.js';\nvar name = 'csCounts';\nvar dependencies = ['transpose'];\nexport var createCsCounts = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    transpose\n  } = _ref;\n  /**\r\n   * Computes the column counts using the upper triangular part of A.\r\n   * It transposes A internally, none of the input parameters are modified.\r\n   *\r\n   * @param {Matrix} a           The sparse matrix A\r\n   *\r\n   * @param {Matrix} ata         Count the columns of A'A instead\r\n   *\r\n   * @return                     An array of size n of the column counts or null on error\r\n   *\r\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n   */\n\n  return function (a, parent, post, ata) {\n    // check inputs\n    if (!a || !parent || !post) {\n      return null;\n    } // a matrix arrays\n\n\n    var asize = a._size; // rows and columns\n\n    var m = asize[0];\n    var n = asize[1]; // variables\n\n    var i, j, k, J, p, p0, p1; // workspace size\n\n    var s = 4 * n + (ata ? n + m + 1 : 0); // allocate workspace\n\n    var w = []; // (s)\n\n    var ancestor = 0; // first n entries\n\n    var maxfirst = n; // next n entries\n\n    var prevleaf = 2 * n; // next n entries\n\n    var first = 3 * n; // next n entries\n\n    var head = 4 * n; // next n + 1 entries (used when ata is true)\n\n    var next = 5 * n + 1; // last entries in workspace\n    // clear workspace w[0..s-1]\n\n    for (k = 0; k < s; k++) {\n      w[k] = -1;\n    } // allocate result\n\n\n    var colcount = []; // (n)\n    // AT = A'\n\n    var at = transpose(a); // at arrays\n\n    var tindex = at._index;\n    var tptr = at._ptr; // find w[first + j]\n\n    for (k = 0; k < n; k++) {\n      j = post[k]; // colcount[j]=1 if j is a leaf\n\n      colcount[j] = w[first + j] === -1 ? 1 : 0;\n\n      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {\n        w[first + j] = k;\n      }\n    } // initialize ata if needed\n\n\n    if (ata) {\n      // invert post\n      for (k = 0; k < n; k++) {\n        w[post[k]] = k;\n      } // loop rows (columns in AT)\n\n\n      for (i = 0; i < m; i++) {\n        // values in column i of AT\n        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {\n          k = Math.min(k, w[tindex[p]]);\n        } // place row i in linked list k\n\n\n        w[next + i] = w[head + k];\n        w[head + k] = i;\n      }\n    } // each node in its own set\n\n\n    for (i = 0; i < n; i++) {\n      w[ancestor + i] = i;\n    }\n\n    for (k = 0; k < n; k++) {\n      // j is the kth node in postordered etree\n      j = post[k]; // check j is not a root\n\n      if (parent[j] !== -1) {\n        colcount[parent[j]]--;\n      } // J=j for LL'=A case\n\n\n      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {\n        for (p = tptr[J]; p < tptr[J + 1]; p++) {\n          i = tindex[p];\n          var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor); // check A(i,j) is in skeleton\n\n          if (r.jleaf >= 1) {\n            colcount[j]++;\n          } // check account for overlap in q\n\n\n          if (r.jleaf === 2) {\n            colcount[r.q]--;\n          }\n        }\n      }\n\n      if (parent[j] !== -1) {\n        w[ancestor + j] = parent[j];\n      }\n    } // sum up colcount's of each child\n\n\n    for (j = 0; j < n; j++) {\n      if (parent[j] !== -1) {\n        colcount[parent[j]] += colcount[j];\n      }\n    }\n\n    return colcount;\n  };\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js"],"names":["factory","csLeaf","name","dependencies","createCsCounts","_ref","transpose","a","parent","post","ata","asize","_size","m","n","i","j","k","J","p","p0","p1","s","w","ancestor","maxfirst","prevleaf","first","head","next","colcount","at","tindex","_index","tptr","_ptr","Math","min","r","jleaf","q"],"mappings":"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","sourcesContent":["import { factory } from '../../../utils/factory.js';\r\nimport { csLeaf } from './csLeaf.js';\r\nvar name = 'csCounts';\r\nvar dependencies = ['transpose'];\r\nexport var createCsCounts = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    transpose\r\n  } = _ref;\r\n  /**\r\n   * Computes the column counts using the upper triangular part of A.\r\n   * It transposes A internally, none of the input parameters are modified.\r\n   *\r\n   * @param {Matrix} a           The sparse matrix A\r\n   *\r\n   * @param {Matrix} ata         Count the columns of A'A instead\r\n   *\r\n   * @return                     An array of size n of the column counts or null on error\r\n   *\r\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n   */\r\n  return function (a, parent, post, ata) {\r\n    // check inputs\r\n    if (!a || !parent || !post) {\r\n      return null;\r\n    }\r\n    // a matrix arrays\r\n    var asize = a._size;\r\n    // rows and columns\r\n    var m = asize[0];\r\n    var n = asize[1];\r\n    // variables\r\n    var i, j, k, J, p, p0, p1;\r\n\r\n    // workspace size\r\n    var s = 4 * n + (ata ? n + m + 1 : 0);\r\n    // allocate workspace\r\n    var w = []; // (s)\r\n    var ancestor = 0; // first n entries\r\n    var maxfirst = n; // next n entries\r\n    var prevleaf = 2 * n; // next n entries\r\n    var first = 3 * n; // next n entries\r\n    var head = 4 * n; // next n + 1 entries (used when ata is true)\r\n    var next = 5 * n + 1; // last entries in workspace\r\n    // clear workspace w[0..s-1]\r\n    for (k = 0; k < s; k++) {\r\n      w[k] = -1;\r\n    }\r\n\r\n    // allocate result\r\n    var colcount = []; // (n)\r\n\r\n    // AT = A'\r\n    var at = transpose(a);\r\n    // at arrays\r\n    var tindex = at._index;\r\n    var tptr = at._ptr;\r\n\r\n    // find w[first + j]\r\n    for (k = 0; k < n; k++) {\r\n      j = post[k];\r\n      // colcount[j]=1 if j is a leaf\r\n      colcount[j] = w[first + j] === -1 ? 1 : 0;\r\n      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {\r\n        w[first + j] = k;\r\n      }\r\n    }\r\n\r\n    // initialize ata if needed\r\n    if (ata) {\r\n      // invert post\r\n      for (k = 0; k < n; k++) {\r\n        w[post[k]] = k;\r\n      }\r\n      // loop rows (columns in AT)\r\n      for (i = 0; i < m; i++) {\r\n        // values in column i of AT\r\n        for (k = n, p0 = tptr[i], p1 = tptr[i + 1], p = p0; p < p1; p++) {\r\n          k = Math.min(k, w[tindex[p]]);\r\n        }\r\n        // place row i in linked list k\r\n        w[next + i] = w[head + k];\r\n        w[head + k] = i;\r\n      }\r\n    }\r\n\r\n    // each node in its own set\r\n    for (i = 0; i < n; i++) {\r\n      w[ancestor + i] = i;\r\n    }\r\n    for (k = 0; k < n; k++) {\r\n      // j is the kth node in postordered etree\r\n      j = post[k];\r\n      // check j is not a root\r\n      if (parent[j] !== -1) {\r\n        colcount[parent[j]]--;\r\n      }\r\n\r\n      // J=j for LL'=A case\r\n      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {\r\n        for (p = tptr[J]; p < tptr[J + 1]; p++) {\r\n          i = tindex[p];\r\n          var r = csLeaf(i, j, w, first, maxfirst, prevleaf, ancestor);\r\n          // check A(i,j) is in skeleton\r\n          if (r.jleaf >= 1) {\r\n            colcount[j]++;\r\n          }\r\n          // check account for overlap in q\r\n          if (r.jleaf === 2) {\r\n            colcount[r.q]--;\r\n          }\r\n        }\r\n      }\r\n      if (parent[j] !== -1) {\r\n        w[ancestor + j] = parent[j];\r\n      }\r\n    }\r\n    // sum up colcount's of each child\r\n    for (j = 0; j < n; j++) {\r\n      if (parent[j] !== -1) {\r\n        colcount[parent[j]] += colcount[j];\r\n      }\r\n    }\r\n    return colcount;\r\n  };\r\n});"]},"metadata":{},"sourceType":"module"}