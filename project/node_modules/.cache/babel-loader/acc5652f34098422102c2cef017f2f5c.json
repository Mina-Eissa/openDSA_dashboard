{"ast":null,"code":"/**\r\n * Depth-first search and postorder of a tree rooted at node j\r\n *\r\n * @param {Number}  j               The tree node\r\n * @param {Number}  k\r\n * @param {Array}   w               The workspace array\r\n * @param {Number}  head            The index offset within the workspace for the head array\r\n * @param {Number}  next            The index offset within the workspace for the next array\r\n * @param {Array}   post            The post ordering array\r\n * @param {Number}  stack           The index offset within the workspace for the stack array\r\n *\r\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n */\nexport function csTdfs(j, k, w, head, next, post, stack) {\n  // variables\n  var top = 0; // place j on the stack\n\n  w[stack] = j; // while (stack is not empty)\n\n  while (top >= 0) {\n    // p = top of stack\n    var p = w[stack + top]; // i = youngest child of p\n\n    var i = w[head + p];\n\n    if (i === -1) {\n      // p has no unordered children left\n      top--; // node p is the kth postordered node\n\n      post[k++] = p;\n    } else {\n      // remove i from children of p\n      w[head + p] = w[next + i]; // increment top\n\n      ++top; // start dfs on child node i\n\n      w[stack + top] = i;\n    }\n  }\n\n  return k;\n}","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js"],"names":["csTdfs","j","k","w","head","next","post","stack","top","p","i"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,MAAT,CAAgBC,CAAhB,EAAmBC,CAAnB,EAAsBC,CAAtB,EAAyBC,IAAzB,EAA+BC,IAA/B,EAAqCC,IAArC,EAA2CC,KAA3C,EAAkD;AACvD;AACA,MAAIC,GAAG,GAAG,CAAV,CAFuD,CAGvD;;AACAL,EAAAA,CAAC,CAACI,KAAD,CAAD,GAAWN,CAAX,CAJuD,CAKvD;;AACA,SAAOO,GAAG,IAAI,CAAd,EAAiB;AACf;AACA,QAAIC,CAAC,GAAGN,CAAC,CAACI,KAAK,GAAGC,GAAT,CAAT,CAFe,CAGf;;AACA,QAAIE,CAAC,GAAGP,CAAC,CAACC,IAAI,GAAGK,CAAR,CAAT;;AACA,QAAIC,CAAC,KAAK,CAAC,CAAX,EAAc;AACZ;AACAF,MAAAA,GAAG,GAFS,CAGZ;;AACAF,MAAAA,IAAI,CAACJ,CAAC,EAAF,CAAJ,GAAYO,CAAZ;AACD,KALD,MAKO;AACL;AACAN,MAAAA,CAAC,CAACC,IAAI,GAAGK,CAAR,CAAD,GAAcN,CAAC,CAACE,IAAI,GAAGK,CAAR,CAAf,CAFK,CAGL;;AACA,QAAEF,GAAF,CAJK,CAKL;;AACAL,MAAAA,CAAC,CAACI,KAAK,GAAGC,GAAT,CAAD,GAAiBE,CAAjB;AACD;AACF;;AACD,SAAOR,CAAP;AACD","sourcesContent":["/**\r\n * Depth-first search and postorder of a tree rooted at node j\r\n *\r\n * @param {Number}  j               The tree node\r\n * @param {Number}  k\r\n * @param {Array}   w               The workspace array\r\n * @param {Number}  head            The index offset within the workspace for the head array\r\n * @param {Number}  next            The index offset within the workspace for the next array\r\n * @param {Array}   post            The post ordering array\r\n * @param {Number}  stack           The index offset within the workspace for the stack array\r\n *\r\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n */\r\nexport function csTdfs(j, k, w, head, next, post, stack) {\r\n  // variables\r\n  var top = 0;\r\n  // place j on the stack\r\n  w[stack] = j;\r\n  // while (stack is not empty)\r\n  while (top >= 0) {\r\n    // p = top of stack\r\n    var p = w[stack + top];\r\n    // i = youngest child of p\r\n    var i = w[head + p];\r\n    if (i === -1) {\r\n      // p has no unordered children left\r\n      top--;\r\n      // node p is the kth postordered node\r\n      post[k++] = p;\r\n    } else {\r\n      // remove i from children of p\r\n      w[head + p] = w[next + i];\r\n      // increment top\r\n      ++top;\r\n      // start dfs on child node i\r\n      w[stack + top] = i;\r\n    }\r\n  }\r\n  return k;\r\n}"]},"metadata":{},"sourceType":"module"}