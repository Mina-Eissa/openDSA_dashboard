{"ast":null,"code":"/**\r\n * Methods for calculating coefficient.\r\n */\n\n/** @private */\nexport function rangeValueToCoefficient(value, range, inversed) {\n  var result = (value - range.min) / range.delta;\n  return inversed ? 1 - result : result;\n}\n/** @private */\n\nexport function getXLocation(x, range, size, inversed) {\n  x = rangeValueToCoefficient(x, range, inversed);\n  return x * size;\n}\n/** @private */\n\nexport function getRangeValueXByPoint(value, size, range, inversed) {\n  var actualValue = !inversed ? value / size : 1 - value / size;\n  return actualValue * range.delta + range.min;\n}\n/** @private */\n\nexport function getExactData(points, start, end) {\n  var selectedData = [];\n  points.map(function (point) {\n    if (point.xValue >= start && point.xValue <= end) {\n      selectedData.push({\n        'x': point.x,\n        'y': point.y\n      });\n    }\n  });\n  return selectedData;\n}\n/** @private */\n\nexport function getNearestValue(values, point) {\n  return values.reduce(function (prev, curr) {\n    return Math.abs(curr - point) < Math.abs(prev - point) ? curr : prev;\n  });\n}\n/**\r\n * Data point\r\n *\r\n * @public\r\n */\n\nvar DataPoint =\n/** @class */\nfunction () {\n  // eslint-disable-next-line @typescript-eslint/no-inferrable-types\n  function DataPoint(x, y, xValue, yValue, visible) {\n    if (visible === void 0) {\n      visible = true;\n    }\n\n    this.x = x;\n    this.y = y;\n    this.xValue = xValue;\n    this.visible = visible;\n  }\n\n  return DataPoint;\n}();\n\nexport { DataPoint };","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/range-navigator/utils/helper.js"],"names":["rangeValueToCoefficient","value","range","inversed","result","min","delta","getXLocation","x","size","getRangeValueXByPoint","actualValue","getExactData","points","start","end","selectedData","map","point","xValue","push","y","getNearestValue","values","reduce","prev","curr","Math","abs","DataPoint","yValue","visible"],"mappings":"AAAA;AACA;AACA;;AACA;AACA,OAAO,SAASA,uBAAT,CAAiCC,KAAjC,EAAwCC,KAAxC,EAA+CC,QAA/C,EAAyD;AAC5D,MAAIC,MAAM,GAAG,CAACH,KAAK,GAAGC,KAAK,CAACG,GAAf,IAAuBH,KAAK,CAACI,KAA1C;AACA,SAAOH,QAAQ,GAAI,IAAIC,MAAR,GAAkBA,MAAjC;AACH;AACD;;AACA,OAAO,SAASG,YAAT,CAAsBC,CAAtB,EAAyBN,KAAzB,EAAgCO,IAAhC,EAAsCN,QAAtC,EAAgD;AACnDK,EAAAA,CAAC,GAAGR,uBAAuB,CAACQ,CAAD,EAAIN,KAAJ,EAAWC,QAAX,CAA3B;AACA,SAAOK,CAAC,GAAGC,IAAX;AACH;AACD;;AACA,OAAO,SAASC,qBAAT,CAA+BT,KAA/B,EAAsCQ,IAAtC,EAA4CP,KAA5C,EAAmDC,QAAnD,EAA6D;AAChE,MAAIQ,WAAW,GAAG,CAACR,QAAD,GAAYF,KAAK,GAAGQ,IAApB,GAA4B,IAAKR,KAAK,GAAGQ,IAA3D;AACA,SAAOE,WAAW,GAAIT,KAAK,CAACI,KAArB,GAA8BJ,KAAK,CAACG,GAA3C;AACH;AACD;;AACA,OAAO,SAASO,YAAT,CAAsBC,MAAtB,EAA8BC,KAA9B,EAAqCC,GAArC,EAA0C;AAC7C,MAAIC,YAAY,GAAG,EAAnB;AACAH,EAAAA,MAAM,CAACI,GAAP,CAAW,UAAUC,KAAV,EAAiB;AACxB,QAAIA,KAAK,CAACC,MAAN,IAAgBL,KAAhB,IAAyBI,KAAK,CAACC,MAAN,IAAgBJ,GAA7C,EAAkD;AAC9CC,MAAAA,YAAY,CAACI,IAAb,CAAkB;AACd,aAAKF,KAAK,CAACV,CADG;AAEd,aAAKU,KAAK,CAACG;AAFG,OAAlB;AAIH;AACJ,GAPD;AAQA,SAAOL,YAAP;AACH;AACD;;AACA,OAAO,SAASM,eAAT,CAAyBC,MAAzB,EAAiCL,KAAjC,EAAwC;AAC3C,SAAOK,MAAM,CAACC,MAAP,CAAc,UAAUC,IAAV,EAAgBC,IAAhB,EAAsB;AACvC,WAAQC,IAAI,CAACC,GAAL,CAASF,IAAI,GAAGR,KAAhB,IAAyBS,IAAI,CAACC,GAAL,CAASH,IAAI,GAAGP,KAAhB,CAAzB,GAAkDQ,IAAlD,GAAyDD,IAAjE;AACH,GAFM,CAAP;AAGH;AACD;AACA;AACA;AACA;AACA;;AACA,IAAII,SAAS;AAAG;AAAe,YAAY;AACvC;AACA,WAASA,SAAT,CAAmBrB,CAAnB,EAAsBa,CAAtB,EAAyBF,MAAzB,EAAiCW,MAAjC,EAAyCC,OAAzC,EAAkD;AAC9C,QAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,MAAAA,OAAO,GAAG,IAAV;AAAiB;;AAC3C,SAAKvB,CAAL,GAASA,CAAT;AACA,SAAKa,CAAL,GAASA,CAAT;AACA,SAAKF,MAAL,GAAcA,MAAd;AACA,SAAKY,OAAL,GAAeA,OAAf;AACH;;AACD,SAAOF,SAAP;AACH,CAV8B,EAA/B;;AAWA,SAASA,SAAT","sourcesContent":["/**\r\n * Methods for calculating coefficient.\r\n */\r\n/** @private */\r\nexport function rangeValueToCoefficient(value, range, inversed) {\r\n    var result = (value - range.min) / (range.delta);\r\n    return inversed ? (1 - result) : result;\r\n}\r\n/** @private */\r\nexport function getXLocation(x, range, size, inversed) {\r\n    x = rangeValueToCoefficient(x, range, inversed);\r\n    return x * size;\r\n}\r\n/** @private */\r\nexport function getRangeValueXByPoint(value, size, range, inversed) {\r\n    var actualValue = !inversed ? value / size : (1 - (value / size));\r\n    return actualValue * (range.delta) + range.min;\r\n}\r\n/** @private */\r\nexport function getExactData(points, start, end) {\r\n    var selectedData = [];\r\n    points.map(function (point) {\r\n        if (point.xValue >= start && point.xValue <= end) {\r\n            selectedData.push({\r\n                'x': point.x,\r\n                'y': point.y\r\n            });\r\n        }\r\n    });\r\n    return selectedData;\r\n}\r\n/** @private */\r\nexport function getNearestValue(values, point) {\r\n    return values.reduce(function (prev, curr) {\r\n        return (Math.abs(curr - point) < Math.abs(prev - point) ? curr : prev);\r\n    });\r\n}\r\n/**\r\n * Data point\r\n *\r\n * @public\r\n */\r\nvar DataPoint = /** @class */ (function () {\r\n    // eslint-disable-next-line @typescript-eslint/no-inferrable-types\r\n    function DataPoint(x, y, xValue, yValue, visible) {\r\n        if (visible === void 0) { visible = true; }\r\n        this.x = x;\r\n        this.y = y;\r\n        this.xValue = xValue;\r\n        this.visible = visible;\r\n    }\r\n    return DataPoint;\r\n}());\r\nexport { DataPoint };\r\n"]},"metadata":{},"sourceType":"module"}