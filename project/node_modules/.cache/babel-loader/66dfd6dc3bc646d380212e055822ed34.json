{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'ConditionalNode';\nvar dependencies = ['Node'];\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\r\n   * Test whether a condition is met\r\n   * @param {*} condition\r\n   * @returns {boolean} true if condition is true or non-zero, else false\r\n   */\n\n  function testCondition(condition) {\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\n      return !!condition;\n    }\n\n    if (condition) {\n      if (isBigNumber(condition)) {\n        return !condition.isZero();\n      }\n\n      if (isComplex(condition)) {\n        return !!(condition.re || condition.im);\n      }\n\n      if (isUnit(condition)) {\n        return !!condition.value;\n      }\n    }\n\n    if (condition === null || condition === undefined) {\n      return false;\n    }\n\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\n  }\n\n  class ConditionalNode extends Node {\n    /**\r\n     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\r\n     *\r\n     * @param {Node} condition   Condition, must result in a boolean\r\n     * @param {Node} trueExpr    Expression evaluated when condition is true\r\n     * @param {Node} falseExpr   Expression evaluated when condition is true\r\n     *\r\n     * @constructor ConditionalNode\r\n     * @extends {Node}\r\n     */\n    constructor(condition, trueExpr, falseExpr) {\n      super();\n\n      if (!isNode(condition)) {\n        throw new TypeError('Parameter condition must be a Node');\n      }\n\n      if (!isNode(trueExpr)) {\n        throw new TypeError('Parameter trueExpr must be a Node');\n      }\n\n      if (!isNode(falseExpr)) {\n        throw new TypeError('Parameter falseExpr must be a Node');\n      }\n\n      this.condition = condition;\n      this.trueExpr = trueExpr;\n      this.falseExpr = falseExpr;\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isConditionalNode() {\n      return true;\n    }\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\n\n\n    _compile(math, argNames) {\n      var evalCondition = this.condition._compile(math, argNames);\n\n      var evalTrueExpr = this.trueExpr._compile(math, argNames);\n\n      var evalFalseExpr = this.falseExpr._compile(math, argNames);\n\n      return function evalConditionalNode(scope, args, context) {\n        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\n      };\n    }\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\n\n\n    forEach(callback) {\n      callback(this.condition, 'condition', this);\n      callback(this.trueExpr, 'trueExpr', this);\n      callback(this.falseExpr, 'falseExpr', this);\n    }\n    /**\r\n     * Create a new ConditionalNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {ConditionalNode} Returns a transformed copy of the node\r\n     */\n\n\n    map(callback) {\n      return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\n    }\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {ConditionalNode}\r\n     */\n\n\n    clone() {\n      return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\n    }\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit); // Enclose Arguments in parentheses if they are an OperatorNode\n      // or have lower or equal precedence\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\n      // purely based on aesthetics and readability\n\n      var condition = this.condition.toString(options);\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n        condition = '(' + condition + ')';\n      }\n\n      var trueExpr = this.trueExpr.toString(options);\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n        trueExpr = '(' + trueExpr + ')';\n      }\n\n      var falseExpr = this.falseExpr.toString(options);\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n        falseExpr = '(' + falseExpr + ')';\n      }\n\n      return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\n    }\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        condition: this.condition,\n        trueExpr: this.trueExpr,\n        falseExpr: this.falseExpr\n      };\n    }\n    /**\r\n     * Instantiate an ConditionalNode from its JSON representation\r\n     * @param {Object} json\r\n     *     An object structured like\r\n     *     ```\r\n     *     {\"mathjs\": \"ConditionalNode\",\r\n     *      \"condition\": ...,\r\n     *      \"trueExpr\": ...,\r\n     *      \"falseExpr\": ...}\r\n     *     ```\r\n     *     where mathjs is optional\r\n     * @returns {ConditionalNode}\r\n     */\n\n\n    static fromJSON(json) {\n      return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\n    }\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit); // Enclose Arguments in parentheses if they are an OperatorNode\n      // or have lower or equal precedence\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\n      // purely based on aesthetics and readability\n\n      var condition = this.condition.toHTML(options);\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\n        condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      var trueExpr = this.trueExpr.toHTML(options);\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\n        trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      var falseExpr = this.falseExpr.toHTML(options);\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\n\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\n        falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\n    }\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    _toTex(options) {\n      return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\n    }\n\n  }\n\n  _defineProperty(ConditionalNode, \"name\", name);\n\n  return ConditionalNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js"],"names":["_defineProperty","isBigNumber","isComplex","isNode","isUnit","typeOf","factory","getPrecedence","name","dependencies","createConditionalNode","_ref","Node","testCondition","condition","isZero","re","im","value","undefined","TypeError","ConditionalNode","constructor","trueExpr","falseExpr","type","isConditionalNode","_compile","math","argNames","evalCondition","evalTrueExpr","evalFalseExpr","evalConditionalNode","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","parenthesis","precedence","implicit","toString","conditionPrecedence","truePrecedence","falsePrecedence","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isClass"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\r\nimport { isBigNumber, isComplex, isNode, isUnit, typeOf } from '../../utils/is.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { getPrecedence } from '../operators.js';\r\nvar name = 'ConditionalNode';\r\nvar dependencies = ['Node'];\r\nexport var createConditionalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Node\r\n  } = _ref;\r\n  /**\r\n   * Test whether a condition is met\r\n   * @param {*} condition\r\n   * @returns {boolean} true if condition is true or non-zero, else false\r\n   */\r\n  function testCondition(condition) {\r\n    if (typeof condition === 'number' || typeof condition === 'boolean' || typeof condition === 'string') {\r\n      return !!condition;\r\n    }\r\n    if (condition) {\r\n      if (isBigNumber(condition)) {\r\n        return !condition.isZero();\r\n      }\r\n      if (isComplex(condition)) {\r\n        return !!(condition.re || condition.im);\r\n      }\r\n      if (isUnit(condition)) {\r\n        return !!condition.value;\r\n      }\r\n    }\r\n    if (condition === null || condition === undefined) {\r\n      return false;\r\n    }\r\n    throw new TypeError('Unsupported type of condition \"' + typeOf(condition) + '\"');\r\n  }\r\n  class ConditionalNode extends Node {\r\n    /**\r\n     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'\r\n     *\r\n     * @param {Node} condition   Condition, must result in a boolean\r\n     * @param {Node} trueExpr    Expression evaluated when condition is true\r\n     * @param {Node} falseExpr   Expression evaluated when condition is true\r\n     *\r\n     * @constructor ConditionalNode\r\n     * @extends {Node}\r\n     */\r\n    constructor(condition, trueExpr, falseExpr) {\r\n      super();\r\n      if (!isNode(condition)) {\r\n        throw new TypeError('Parameter condition must be a Node');\r\n      }\r\n      if (!isNode(trueExpr)) {\r\n        throw new TypeError('Parameter trueExpr must be a Node');\r\n      }\r\n      if (!isNode(falseExpr)) {\r\n        throw new TypeError('Parameter falseExpr must be a Node');\r\n      }\r\n      this.condition = condition;\r\n      this.trueExpr = trueExpr;\r\n      this.falseExpr = falseExpr;\r\n    }\r\n    get type() {\r\n      return name;\r\n    }\r\n    get isConditionalNode() {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n    _compile(math, argNames) {\r\n      var evalCondition = this.condition._compile(math, argNames);\r\n      var evalTrueExpr = this.trueExpr._compile(math, argNames);\r\n      var evalFalseExpr = this.falseExpr._compile(math, argNames);\r\n      return function evalConditionalNode(scope, args, context) {\r\n        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n    forEach(callback) {\r\n      callback(this.condition, 'condition', this);\r\n      callback(this.trueExpr, 'trueExpr', this);\r\n      callback(this.falseExpr, 'falseExpr', this);\r\n    }\r\n\r\n    /**\r\n     * Create a new ConditionalNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {ConditionalNode} Returns a transformed copy of the node\r\n     */\r\n    map(callback) {\r\n      return new ConditionalNode(this._ifNode(callback(this.condition, 'condition', this)), this._ifNode(callback(this.trueExpr, 'trueExpr', this)), this._ifNode(callback(this.falseExpr, 'falseExpr', this)));\r\n    }\r\n\r\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {ConditionalNode}\r\n     */\r\n    clone() {\r\n      return new ConditionalNode(this.condition, this.trueExpr, this.falseExpr);\r\n    }\r\n\r\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    _toString(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit);\r\n\r\n      // Enclose Arguments in parentheses if they are an OperatorNode\r\n      // or have lower or equal precedence\r\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\r\n      // purely based on aesthetics and readability\r\n      var condition = this.condition.toString(options);\r\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\r\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\r\n        condition = '(' + condition + ')';\r\n      }\r\n      var trueExpr = this.trueExpr.toString(options);\r\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\r\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\r\n        trueExpr = '(' + trueExpr + ')';\r\n      }\r\n      var falseExpr = this.falseExpr.toString(options);\r\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\r\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\r\n        falseExpr = '(' + falseExpr + ')';\r\n      }\r\n      return condition + ' ? ' + trueExpr + ' : ' + falseExpr;\r\n    }\r\n\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n      return {\r\n        mathjs: name,\r\n        condition: this.condition,\r\n        trueExpr: this.trueExpr,\r\n        falseExpr: this.falseExpr\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Instantiate an ConditionalNode from its JSON representation\r\n     * @param {Object} json\r\n     *     An object structured like\r\n     *     ```\r\n     *     {\"mathjs\": \"ConditionalNode\",\r\n     *      \"condition\": ...,\r\n     *      \"trueExpr\": ...,\r\n     *      \"falseExpr\": ...}\r\n     *     ```\r\n     *     where mathjs is optional\r\n     * @returns {ConditionalNode}\r\n     */\r\n    static fromJSON(json) {\r\n      return new ConditionalNode(json.condition, json.trueExpr, json.falseExpr);\r\n    }\r\n\r\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    toHTML(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var precedence = getPrecedence(this, parenthesis, options && options.implicit);\r\n\r\n      // Enclose Arguments in parentheses if they are an OperatorNode\r\n      // or have lower or equal precedence\r\n      // NOTE: enclosing all OperatorNodes in parentheses is a decision\r\n      // purely based on aesthetics and readability\r\n      var condition = this.condition.toHTML(options);\r\n      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);\r\n      if (parenthesis === 'all' || this.condition.type === 'OperatorNode' || conditionPrecedence !== null && conditionPrecedence <= precedence) {\r\n        condition = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + condition + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n      }\r\n      var trueExpr = this.trueExpr.toHTML(options);\r\n      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);\r\n      if (parenthesis === 'all' || this.trueExpr.type === 'OperatorNode' || truePrecedence !== null && truePrecedence <= precedence) {\r\n        trueExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + trueExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n      }\r\n      var falseExpr = this.falseExpr.toHTML(options);\r\n      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);\r\n      if (parenthesis === 'all' || this.falseExpr.type === 'OperatorNode' || falsePrecedence !== null && falsePrecedence <= precedence) {\r\n        falseExpr = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + falseExpr + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n      }\r\n      return condition + '<span class=\"math-operator math-conditional-operator\">?</span>' + trueExpr + '<span class=\"math-operator math-conditional-operator\">:</span>' + falseExpr;\r\n    }\r\n\r\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    _toTex(options) {\r\n      return '\\\\begin{cases} {' + this.trueExpr.toTex(options) + '}, &\\\\quad{\\\\text{if }\\\\;' + this.condition.toTex(options) + '}\\\\\\\\{' + this.falseExpr.toTex(options) + '}, &\\\\quad{\\\\text{otherwise}}\\\\end{cases}';\r\n    }\r\n  }\r\n  _defineProperty(ConditionalNode, \"name\", name);\r\n  return ConditionalNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"]},"metadata":{},"sourceType":"module"}