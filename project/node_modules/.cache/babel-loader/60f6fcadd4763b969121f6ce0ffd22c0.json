{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { isCollection } from '../../utils/is.js';\nvar name = 'std';\nvar dependencies = ['typed', 'map', 'sqrt', 'variance'];\nexport var createStd = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    map,\n    sqrt,\n    variance\n  } = _ref;\n  /**\r\n   * Compute the standard deviation of a matrix or a  list with values.\r\n   * The standard deviations is defined as the square root of the variance:\r\n   * `std(A) = sqrt(variance(A))`.\r\n   * In case of a (multi dimensional) array or matrix, the standard deviation\r\n   * over all elements will be calculated by default, unless an axis is specified\r\n   * in which case the standard deviation will be computed along that axis.\r\n   *\r\n   * Additionally, it is possible to compute the standard deviation along the rows\r\n   * or columns of a matrix by specifying the dimension as the second argument.\r\n   *\r\n   * Optionally, the type of normalization can be specified as the final\r\n   * parameter. The parameter `normalization` can be one of the following values:\r\n   *\r\n   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)\r\n   * - 'uncorrected'        The sum of squared errors is divided by n\r\n   * - 'biased'             The sum of squared errors is divided by (n + 1)\r\n   *\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.std(a, b, c, ...)\r\n   *     math.std(A)\r\n   *     math.std(A, normalization)\r\n   *     math.std(A, dimension)\r\n   *     math.std(A, dimension, normalization)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.std(2, 4, 6)                     // returns 2\r\n   *     math.std([2, 4, 6, 8])                // returns 2.581988897471611\r\n   *     math.std([2, 4, 6, 8], 'uncorrected') // returns 2.23606797749979\r\n   *     math.std([2, 4, 6, 8], 'biased')      // returns 2\r\n   *\r\n   *     math.std([[1, 2, 3], [4, 5, 6]])      // returns 1.8708286933869707\r\n   *     math.std([[1, 2, 3], [4, 6, 8]], 0)    // returns [2.1213203435596424, 2.8284271247461903, 3.5355339059327378]\r\n   *     math.std([[1, 2, 3], [4, 6, 8]], 1)    // returns [1, 2]\r\n   *     math.std([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.7071067811865476, 1.4142135623730951]\r\n   *\r\n   * See also:\r\n   *\r\n   *    mean, median, max, min, prod, sum, variance\r\n   *\r\n   * @param {Array | Matrix} array\r\n   *                        A single matrix or or multiple scalar values\r\n   * @param {string} [normalization='unbiased']\r\n   *                        Determines how to normalize the variance.\r\n   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.\r\n   * @param dimension {number | BigNumber}\r\n   *                        Determines the axis to compute the standard deviation for a matrix\r\n   * @return {*} The standard deviation\r\n   */\n\n  return typed(name, {\n    // std([a, b, c, d, ...])\n    'Array | Matrix': _std,\n    // std([a, b, c, d, ...], normalization)\n    'Array | Matrix, string': _std,\n    // std([a, b, c, c, ...], dim)\n    'Array | Matrix, number | BigNumber': _std,\n    // std([a, b, c, c, ...], dim, normalization)\n    'Array | Matrix, number | BigNumber, string': _std,\n    // std(a, b, c, d, ...)\n    '...': function _(args) {\n      return _std(args);\n    }\n  });\n\n  function _std(array, normalization) {\n    if (array.length === 0) {\n      throw new SyntaxError('Function std requires one or more parameters (0 provided)');\n    }\n\n    try {\n      var v = variance.apply(null, arguments);\n\n      if (isCollection(v)) {\n        return map(v, sqrt);\n      } else {\n        return sqrt(v);\n      }\n    } catch (err) {\n      if (err instanceof TypeError && err.message.indexOf(' variance') !== -1) {\n        throw new TypeError(err.message.replace(' variance', ' std'));\n      } else {\n        throw err;\n      }\n    }\n  }\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/statistics/std.js"],"names":["factory","isCollection","name","dependencies","createStd","_ref","typed","map","sqrt","variance","_std","_","args","array","normalization","length","SyntaxError","v","apply","arguments","err","TypeError","message","indexOf","replace"],"mappings":"AAAA,SAASA,OAAT,QAAwB,wBAAxB;AACA,SAASC,YAAT,QAA6B,mBAA7B;AACA,IAAIC,IAAI,GAAG,KAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,KAAV,EAAiB,MAAjB,EAAyB,UAAzB,CAAnB;AACA,OAAO,IAAIC,SAAS,GAAG,eAAeJ,OAAO,CAACE,IAAD,EAAOC,YAAP,EAAqBE,IAAI,IAAI;AACxE,MAAI;AACFC,IAAAA,KADE;AAEFC,IAAAA,GAFE;AAGFC,IAAAA,IAHE;AAIFC,IAAAA;AAJE,MAKAJ,IALJ;AAMA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,SAAOC,KAAK,CAACJ,IAAD,EAAO;AACjB;AACA,sBAAkBQ,IAFD;AAGjB;AACA,8BAA0BA,IAJT;AAKjB;AACA,0CAAsCA,IANrB;AAOjB;AACA,kDAA8CA,IAR7B;AASjB;AACA,WAAO,SAASC,CAAT,CAAWC,IAAX,EAAiB;AACtB,aAAOF,IAAI,CAACE,IAAD,CAAX;AACD;AAZgB,GAAP,CAAZ;;AAcA,WAASF,IAAT,CAAcG,KAAd,EAAqBC,aAArB,EAAoC;AAClC,QAAID,KAAK,CAACE,MAAN,KAAiB,CAArB,EAAwB;AACtB,YAAM,IAAIC,WAAJ,CAAgB,2DAAhB,CAAN;AACD;;AACD,QAAI;AACF,UAAIC,CAAC,GAAGR,QAAQ,CAACS,KAAT,CAAe,IAAf,EAAqBC,SAArB,CAAR;;AACA,UAAIlB,YAAY,CAACgB,CAAD,CAAhB,EAAqB;AACnB,eAAOV,GAAG,CAACU,CAAD,EAAIT,IAAJ,CAAV;AACD,OAFD,MAEO;AACL,eAAOA,IAAI,CAACS,CAAD,CAAX;AACD;AACF,KAPD,CAOE,OAAOG,GAAP,EAAY;AACZ,UAAIA,GAAG,YAAYC,SAAf,IAA4BD,GAAG,CAACE,OAAJ,CAAYC,OAAZ,CAAoB,WAApB,MAAqC,CAAC,CAAtE,EAAyE;AACvE,cAAM,IAAIF,SAAJ,CAAcD,GAAG,CAACE,OAAJ,CAAYE,OAAZ,CAAoB,WAApB,EAAiC,MAAjC,CAAd,CAAN;AACD,OAFD,MAEO;AACL,cAAMJ,GAAN;AACD;AACF;AACF;AACF,CA5F4C,CAAtC","sourcesContent":["import { factory } from '../../utils/factory.js';\r\nimport { isCollection } from '../../utils/is.js';\r\nvar name = 'std';\r\nvar dependencies = ['typed', 'map', 'sqrt', 'variance'];\r\nexport var createStd = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    map,\r\n    sqrt,\r\n    variance\r\n  } = _ref;\r\n  /**\r\n   * Compute the standard deviation of a matrix or a  list with values.\r\n   * The standard deviations is defined as the square root of the variance:\r\n   * `std(A) = sqrt(variance(A))`.\r\n   * In case of a (multi dimensional) array or matrix, the standard deviation\r\n   * over all elements will be calculated by default, unless an axis is specified\r\n   * in which case the standard deviation will be computed along that axis.\r\n   *\r\n   * Additionally, it is possible to compute the standard deviation along the rows\r\n   * or columns of a matrix by specifying the dimension as the second argument.\r\n   *\r\n   * Optionally, the type of normalization can be specified as the final\r\n   * parameter. The parameter `normalization` can be one of the following values:\r\n   *\r\n   * - 'unbiased' (default) The sum of squared errors is divided by (n - 1)\r\n   * - 'uncorrected'        The sum of squared errors is divided by n\r\n   * - 'biased'             The sum of squared errors is divided by (n + 1)\r\n   *\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.std(a, b, c, ...)\r\n   *     math.std(A)\r\n   *     math.std(A, normalization)\r\n   *     math.std(A, dimension)\r\n   *     math.std(A, dimension, normalization)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.std(2, 4, 6)                     // returns 2\r\n   *     math.std([2, 4, 6, 8])                // returns 2.581988897471611\r\n   *     math.std([2, 4, 6, 8], 'uncorrected') // returns 2.23606797749979\r\n   *     math.std([2, 4, 6, 8], 'biased')      // returns 2\r\n   *\r\n   *     math.std([[1, 2, 3], [4, 5, 6]])      // returns 1.8708286933869707\r\n   *     math.std([[1, 2, 3], [4, 6, 8]], 0)    // returns [2.1213203435596424, 2.8284271247461903, 3.5355339059327378]\r\n   *     math.std([[1, 2, 3], [4, 6, 8]], 1)    // returns [1, 2]\r\n   *     math.std([[1, 2, 3], [4, 6, 8]], 1, 'biased') // returns [0.7071067811865476, 1.4142135623730951]\r\n   *\r\n   * See also:\r\n   *\r\n   *    mean, median, max, min, prod, sum, variance\r\n   *\r\n   * @param {Array | Matrix} array\r\n   *                        A single matrix or or multiple scalar values\r\n   * @param {string} [normalization='unbiased']\r\n   *                        Determines how to normalize the variance.\r\n   *                        Choose 'unbiased' (default), 'uncorrected', or 'biased'.\r\n   * @param dimension {number | BigNumber}\r\n   *                        Determines the axis to compute the standard deviation for a matrix\r\n   * @return {*} The standard deviation\r\n   */\r\n  return typed(name, {\r\n    // std([a, b, c, d, ...])\r\n    'Array | Matrix': _std,\r\n    // std([a, b, c, d, ...], normalization)\r\n    'Array | Matrix, string': _std,\r\n    // std([a, b, c, c, ...], dim)\r\n    'Array | Matrix, number | BigNumber': _std,\r\n    // std([a, b, c, c, ...], dim, normalization)\r\n    'Array | Matrix, number | BigNumber, string': _std,\r\n    // std(a, b, c, d, ...)\r\n    '...': function _(args) {\r\n      return _std(args);\r\n    }\r\n  });\r\n  function _std(array, normalization) {\r\n    if (array.length === 0) {\r\n      throw new SyntaxError('Function std requires one or more parameters (0 provided)');\r\n    }\r\n    try {\r\n      var v = variance.apply(null, arguments);\r\n      if (isCollection(v)) {\r\n        return map(v, sqrt);\r\n      } else {\r\n        return sqrt(v);\r\n      }\r\n    } catch (err) {\r\n      if (err instanceof TypeError && err.message.indexOf(' variance') !== -1) {\r\n        throw new TypeError(err.message.replace(' variance', ' std'));\r\n      } else {\r\n        throw err;\r\n      }\r\n    }\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}