{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { isInteger } from '../../utils/number.js';\nimport { arraySize as size } from '../../utils/array.js';\nimport { powNumber } from '../../plain/number/index.js';\nvar name = 'pow';\nvar dependencies = ['typed', 'config', 'identity', 'multiply', 'matrix', 'inv', 'fraction', 'number', 'Complex'];\nexport var createPow = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    identity,\n    multiply,\n    matrix,\n    inv,\n    number,\n    fraction,\n    Complex\n  } = _ref;\n  /**\r\n   * Calculates the power of x to y, `x ^ y`.\r\n   *\r\n   * Matrix exponentiation is supported for square matrices `x` and integers `y`:\r\n   * when `y` is nonnegative, `x` may be any square matrix; and when `y` is\r\n   * negative, `x` must be invertible, and then this function returns\r\n   * inv(x)^(-y).\r\n   *\r\n   * For cubic roots of negative numbers, the function returns the principal\r\n   * root by default. In order to let the function return the real root,\r\n   * math.js can be configured with `math.config({predictable: true})`.\r\n   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.pow(x, y)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.pow(2, 3)               // returns number 8\r\n   *\r\n   *    const a = math.complex(2, 3)\r\n   *    math.pow(a, 2)                // returns Complex -5 + 12i\r\n   *\r\n   *    const b = [[1, 2], [4, 3]]\r\n   *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]\r\n   *\r\n   *    const c = [[1, 2], [4, 3]]\r\n   *    math.pow(c, -1)               // returns Array [[-0.6, 0.4], [0.8, -0.2]]\r\n   *\r\n   * See also:\r\n   *\r\n   *    multiply, sqrt, cbrt, nthRoot\r\n   *\r\n   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base\r\n   * @param  {number | BigNumber | Complex} y                          The exponent\r\n   * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`\r\n   */\n\n  return typed(name, {\n    'number, number': _pow,\n    'Complex, Complex': function ComplexComplex(x, y) {\n      return x.pow(y);\n    },\n    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {\n      if (y.isInteger() || x >= 0 || config.predictable) {\n        return x.pow(y);\n      } else {\n        return new Complex(x.toNumber(), 0).pow(y.toNumber(), 0);\n      }\n    },\n    'Fraction, Fraction': function FractionFraction(x, y) {\n      var result = x.pow(y);\n\n      if (result != null) {\n        return result;\n      }\n\n      if (config.predictable) {\n        throw new Error('Result of pow is non-rational and cannot be expressed as a fraction');\n      } else {\n        return _pow(x.valueOf(), y.valueOf());\n      }\n    },\n    'Array, number': _powArray,\n    'Array, BigNumber': function ArrayBigNumber(x, y) {\n      return _powArray(x, y.toNumber());\n    },\n    'Matrix, number': _powMatrix,\n    'Matrix, BigNumber': function MatrixBigNumber(x, y) {\n      return _powMatrix(x, y.toNumber());\n    },\n    'Unit, number | BigNumber': function UnitNumberBigNumber(x, y) {\n      return x.pow(y);\n    }\n  });\n  /**\r\n   * Calculates the power of x to y, x^y, for two numbers.\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @return {number | Complex} res\r\n   * @private\r\n   */\n\n  function _pow(x, y) {\n    // Alternatively could define a 'realmode' config option or something, but\n    // 'predictable' will work for now\n    if (config.predictable && !isInteger(y) && x < 0) {\n      // Check to see if y can be represented as a fraction\n      try {\n        var yFrac = fraction(y);\n        var yNum = number(yFrac);\n\n        if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {\n          if (yFrac.d % 2 === 1) {\n            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);\n          }\n        }\n      } catch (ex) {// fraction() throws an error if y is Infinity, etc.\n      } // Unable to express y as a fraction, so continue on\n\n    } // **for predictable mode** x^Infinity === NaN if x < -1\n    // N.B. this behavour is different from `Math.pow` which gives\n    // (-2)^Infinity === Infinity\n\n\n    if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {\n      return NaN;\n    }\n\n    if (isInteger(y) || x >= 0 || config.predictable) {\n      return powNumber(x, y);\n    } else {\n      // TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow\n      // x^Infinity === 0 if -1 < x < 1\n      // A real number 0 is returned instead of complex(0)\n      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {\n        return 0;\n      }\n\n      return new Complex(x, 0).pow(y, 0);\n    }\n  }\n  /**\r\n   * Calculate the power of a 2d array\r\n   * @param {Array} x     must be a 2 dimensional, square matrix\r\n   * @param {number} y    a integer value (positive if `x` is not invertible)\r\n   * @returns {Array}\r\n   * @private\r\n   */\n\n\n  function _powArray(x, y) {\n    if (!isInteger(y)) {\n      throw new TypeError('For A^b, b must be an integer (value is ' + y + ')');\n    } // verify that A is a 2 dimensional square matrix\n\n\n    var s = size(x);\n\n    if (s.length !== 2) {\n      throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');\n    }\n\n    if (s[0] !== s[1]) {\n      throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');\n    }\n\n    if (y < 0) {\n      try {\n        return _powArray(inv(x), -y);\n      } catch (error) {\n        if (error.message === 'Cannot calculate inverse, determinant is zero') {\n          throw new TypeError('For A^b, when A is not invertible, b must be a positive integer (value is ' + y + ')');\n        }\n\n        throw error;\n      }\n    }\n\n    var res = identity(s[0]).valueOf();\n    var px = x;\n\n    while (y >= 1) {\n      if ((y & 1) === 1) {\n        res = multiply(px, res);\n      }\n\n      y >>= 1;\n      px = multiply(px, px);\n    }\n\n    return res;\n  }\n  /**\r\n   * Calculate the power of a 2d matrix\r\n   * @param {Matrix} x     must be a 2 dimensional, square matrix\r\n   * @param {number} y    a positive, integer value\r\n   * @returns {Matrix}\r\n   * @private\r\n   */\n\n\n  function _powMatrix(x, y) {\n    return matrix(_powArray(x.valueOf(), y));\n  }\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/arithmetic/pow.js"],"names":["factory","isInteger","arraySize","size","powNumber","name","dependencies","createPow","_ref","typed","config","identity","multiply","matrix","inv","number","fraction","Complex","_pow","ComplexComplex","x","y","pow","BigNumberBigNumber","predictable","toNumber","FractionFraction","result","Error","valueOf","_powArray","ArrayBigNumber","_powMatrix","MatrixBigNumber","UnitNumberBigNumber","yFrac","yNum","Math","abs","d","n","ex","Infinity","NaN","TypeError","s","length","error","message","res","px"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory.js';\r\nimport { isInteger } from '../../utils/number.js';\r\nimport { arraySize as size } from '../../utils/array.js';\r\nimport { powNumber } from '../../plain/number/index.js';\r\nvar name = 'pow';\r\nvar dependencies = ['typed', 'config', 'identity', 'multiply', 'matrix', 'inv', 'fraction', 'number', 'Complex'];\r\nexport var createPow = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    config,\r\n    identity,\r\n    multiply,\r\n    matrix,\r\n    inv,\r\n    number,\r\n    fraction,\r\n    Complex\r\n  } = _ref;\r\n  /**\r\n   * Calculates the power of x to y, `x ^ y`.\r\n   *\r\n   * Matrix exponentiation is supported for square matrices `x` and integers `y`:\r\n   * when `y` is nonnegative, `x` may be any square matrix; and when `y` is\r\n   * negative, `x` must be invertible, and then this function returns\r\n   * inv(x)^(-y).\r\n   *\r\n   * For cubic roots of negative numbers, the function returns the principal\r\n   * root by default. In order to let the function return the real root,\r\n   * math.js can be configured with `math.config({predictable: true})`.\r\n   * To retrieve all cubic roots of a value, use `math.cbrt(x, true)`.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.pow(x, y)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.pow(2, 3)               // returns number 8\r\n   *\r\n   *    const a = math.complex(2, 3)\r\n   *    math.pow(a, 2)                // returns Complex -5 + 12i\r\n   *\r\n   *    const b = [[1, 2], [4, 3]]\r\n   *    math.pow(b, 2)               // returns Array [[9, 8], [16, 17]]\r\n   *\r\n   *    const c = [[1, 2], [4, 3]]\r\n   *    math.pow(c, -1)               // returns Array [[-0.6, 0.4], [0.8, -0.2]]\r\n   *\r\n   * See also:\r\n   *\r\n   *    multiply, sqrt, cbrt, nthRoot\r\n   *\r\n   * @param  {number | BigNumber | Complex | Unit | Array | Matrix} x  The base\r\n   * @param  {number | BigNumber | Complex} y                          The exponent\r\n   * @return {number | BigNumber | Complex | Array | Matrix} The value of `x` to the power `y`\r\n   */\r\n  return typed(name, {\r\n    'number, number': _pow,\r\n    'Complex, Complex': function ComplexComplex(x, y) {\r\n      return x.pow(y);\r\n    },\r\n    'BigNumber, BigNumber': function BigNumberBigNumber(x, y) {\r\n      if (y.isInteger() || x >= 0 || config.predictable) {\r\n        return x.pow(y);\r\n      } else {\r\n        return new Complex(x.toNumber(), 0).pow(y.toNumber(), 0);\r\n      }\r\n    },\r\n    'Fraction, Fraction': function FractionFraction(x, y) {\r\n      var result = x.pow(y);\r\n      if (result != null) {\r\n        return result;\r\n      }\r\n      if (config.predictable) {\r\n        throw new Error('Result of pow is non-rational and cannot be expressed as a fraction');\r\n      } else {\r\n        return _pow(x.valueOf(), y.valueOf());\r\n      }\r\n    },\r\n    'Array, number': _powArray,\r\n    'Array, BigNumber': function ArrayBigNumber(x, y) {\r\n      return _powArray(x, y.toNumber());\r\n    },\r\n    'Matrix, number': _powMatrix,\r\n    'Matrix, BigNumber': function MatrixBigNumber(x, y) {\r\n      return _powMatrix(x, y.toNumber());\r\n    },\r\n    'Unit, number | BigNumber': function UnitNumberBigNumber(x, y) {\r\n      return x.pow(y);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Calculates the power of x to y, x^y, for two numbers.\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @return {number | Complex} res\r\n   * @private\r\n   */\r\n  function _pow(x, y) {\r\n    // Alternatively could define a 'realmode' config option or something, but\r\n    // 'predictable' will work for now\r\n    if (config.predictable && !isInteger(y) && x < 0) {\r\n      // Check to see if y can be represented as a fraction\r\n      try {\r\n        var yFrac = fraction(y);\r\n        var yNum = number(yFrac);\r\n        if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {\r\n          if (yFrac.d % 2 === 1) {\r\n            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);\r\n          }\r\n        }\r\n      } catch (ex) {\r\n        // fraction() throws an error if y is Infinity, etc.\r\n      }\r\n\r\n      // Unable to express y as a fraction, so continue on\r\n    }\r\n\r\n    // **for predictable mode** x^Infinity === NaN if x < -1\r\n    // N.B. this behavour is different from `Math.pow` which gives\r\n    // (-2)^Infinity === Infinity\r\n    if (config.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {\r\n      return NaN;\r\n    }\r\n    if (isInteger(y) || x >= 0 || config.predictable) {\r\n      return powNumber(x, y);\r\n    } else {\r\n      // TODO: the following infinity checks are duplicated from powNumber. Deduplicate this somehow\r\n\r\n      // x^Infinity === 0 if -1 < x < 1\r\n      // A real number 0 is returned instead of complex(0)\r\n      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {\r\n        return 0;\r\n      }\r\n      return new Complex(x, 0).pow(y, 0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate the power of a 2d array\r\n   * @param {Array} x     must be a 2 dimensional, square matrix\r\n   * @param {number} y    a integer value (positive if `x` is not invertible)\r\n   * @returns {Array}\r\n   * @private\r\n   */\r\n  function _powArray(x, y) {\r\n    if (!isInteger(y)) {\r\n      throw new TypeError('For A^b, b must be an integer (value is ' + y + ')');\r\n    }\r\n    // verify that A is a 2 dimensional square matrix\r\n    var s = size(x);\r\n    if (s.length !== 2) {\r\n      throw new Error('For A^b, A must be 2 dimensional (A has ' + s.length + ' dimensions)');\r\n    }\r\n    if (s[0] !== s[1]) {\r\n      throw new Error('For A^b, A must be square (size is ' + s[0] + 'x' + s[1] + ')');\r\n    }\r\n    if (y < 0) {\r\n      try {\r\n        return _powArray(inv(x), -y);\r\n      } catch (error) {\r\n        if (error.message === 'Cannot calculate inverse, determinant is zero') {\r\n          throw new TypeError('For A^b, when A is not invertible, b must be a positive integer (value is ' + y + ')');\r\n        }\r\n        throw error;\r\n      }\r\n    }\r\n    var res = identity(s[0]).valueOf();\r\n    var px = x;\r\n    while (y >= 1) {\r\n      if ((y & 1) === 1) {\r\n        res = multiply(px, res);\r\n      }\r\n      y >>= 1;\r\n      px = multiply(px, px);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Calculate the power of a 2d matrix\r\n   * @param {Matrix} x     must be a 2 dimensional, square matrix\r\n   * @param {number} y    a positive, integer value\r\n   * @returns {Matrix}\r\n   * @private\r\n   */\r\n  function _powMatrix(x, y) {\r\n    return matrix(_powArray(x.valueOf(), y));\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}