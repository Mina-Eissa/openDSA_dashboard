{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport typedFunction from 'typed-function';\nimport { deepFlatten, isLegacyFactory, values } from '../utils/object.js';\nimport * as emitter from './../utils/emitter.js';\nimport { importFactory } from './function/import.js';\nimport { configFactory } from './function/config.js';\nimport { factory, isFactory } from '../utils/factory.js';\nimport { isAccessorNode, isArray, isArrayNode, isAssignmentNode, isBigNumber, isBlockNode, isBoolean, isChain, isCollection, isComplex, isConditionalNode, isConstantNode, isDate, isDenseMatrix, isFraction, isFunction, isFunctionAssignmentNode, isFunctionNode, isHelp, isIndex, isIndexNode, isMatrix, isNode, isNull, isNumber, isObject, isObjectNode, isOperatorNode, isParenthesisNode, isRange, isRangeNode, isRelationalNode, isRegExp, isResultSet, isSparseMatrix, isString, isSymbolNode, isUndefined, isUnit } from '../utils/is.js';\nimport { ArgumentsError } from '../error/ArgumentsError.js';\nimport { DimensionError } from '../error/DimensionError.js';\nimport { IndexError } from '../error/IndexError.js';\nimport { DEFAULT_CONFIG } from './config.js';\n/**\r\n * Create a mathjs instance from given factory functions and optionally config\r\n *\r\n * Usage:\r\n *\r\n *     const mathjs1 = create({ createAdd, createMultiply, ...})\r\n *     const config = { number: 'BigNumber' }\r\n *     const mathjs2 = create(all, config)\r\n *\r\n * @param {Object} [factories] An object with factory functions\r\n *                             The object can contain nested objects,\r\n *                             all nested objects will be flattened.\r\n * @param {Object} [config]    Available options:\r\n *                            {number} epsilon\r\n *                              Minimum relative difference between two\r\n *                              compared values, used by all comparison functions.\r\n *                            {string} matrix\r\n *                              A string 'Matrix' (default) or 'Array'.\r\n *                            {string} number\r\n *                              A string 'number' (default), 'BigNumber', or 'Fraction'\r\n *                            {number} precision\r\n *                              The number of significant digits for BigNumbers.\r\n *                              Not applicable for Numbers.\r\n *                            {boolean} predictable\r\n *                              Predictable output type of functions. When true,\r\n *                              output type depends only on the input types. When\r\n *                              false (default), output type can vary depending\r\n *                              on input values. For example `math.sqrt(-4)`\r\n *                              returns `complex('2i')` when predictable is false, and\r\n *                              returns `NaN` when true.\r\n *                            {string} randomSeed\r\n *                              Random seed for seeded pseudo random number generator.\r\n *                              Set to null to randomly seed.\r\n * @returns {Object} Returns a bare-bone math.js instance containing\r\n *                   functions:\r\n *                   - `import` to add new functions\r\n *                   - `config` to change configuration\r\n *                   - `on`, `off`, `once`, `emit` for events\r\n */\n\nexport function create(factories, config) {\n  var configInternal = _extends({}, DEFAULT_CONFIG, config); // simple test for ES5 support\n\n\n  if (typeof Object.create !== 'function') {\n    throw new Error('ES5 not supported by this JavaScript engine. ' + 'Please load the es5-shim and es5-sham library for compatibility.');\n  } // create the mathjs instance\n\n\n  var math = emitter.mixin({\n    // only here for backward compatibility for legacy factory functions\n    isNumber,\n    isComplex,\n    isBigNumber,\n    isFraction,\n    isUnit,\n    isString,\n    isArray,\n    isMatrix,\n    isCollection,\n    isDenseMatrix,\n    isSparseMatrix,\n    isRange,\n    isIndex,\n    isBoolean,\n    isResultSet,\n    isHelp,\n    isFunction,\n    isDate,\n    isRegExp,\n    isObject,\n    isNull,\n    isUndefined,\n    isAccessorNode,\n    isArrayNode,\n    isAssignmentNode,\n    isBlockNode,\n    isConditionalNode,\n    isConstantNode,\n    isFunctionAssignmentNode,\n    isFunctionNode,\n    isIndexNode,\n    isNode,\n    isObjectNode,\n    isOperatorNode,\n    isParenthesisNode,\n    isRangeNode,\n    isRelationalNode,\n    isSymbolNode,\n    isChain\n  }); // load config function and apply provided config\n\n  math.config = configFactory(configInternal, math.emit);\n  math.expression = {\n    transform: {},\n    mathWithTransform: {\n      config: math.config\n    }\n  }; // cached factories and instances used by function load\n\n  var legacyFactories = [];\n  var legacyInstances = [];\n  /**\r\n   * Load a function or data type from a factory.\r\n   * If the function or data type already exists, the existing instance is\r\n   * returned.\r\n   * @param {Function} factory\r\n   * @returns {*}\r\n   */\n\n  function load(factory) {\n    if (isFactory(factory)) {\n      return factory(math);\n    }\n\n    var firstProperty = factory[Object.keys(factory)[0]];\n\n    if (isFactory(firstProperty)) {\n      return firstProperty(math);\n    }\n\n    if (!isLegacyFactory(factory)) {\n      console.warn('Factory object with properties `type`, `name`, and `factory` expected', factory);\n      throw new Error('Factory object with properties `type`, `name`, and `factory` expected');\n    }\n\n    var index = legacyFactories.indexOf(factory);\n    var instance;\n\n    if (index === -1) {\n      // doesn't yet exist\n      if (factory.math === true) {\n        // pass with math namespace\n        instance = factory.factory(math.type, configInternal, load, math.typed, math);\n      } else {\n        instance = factory.factory(math.type, configInternal, load, math.typed);\n      } // append to the cache\n\n\n      legacyFactories.push(factory);\n      legacyInstances.push(instance);\n    } else {\n      // already existing function, return the cached instance\n      instance = legacyInstances[index];\n    }\n\n    return instance;\n  }\n\n  var importedFactories = {}; // load the import function\n\n  function lazyTyped() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return math.typed.apply(math.typed, args);\n  }\n\n  lazyTyped.isTypedFunction = typedFunction.isTypedFunction;\n  var internalImport = importFactory(lazyTyped, load, math, importedFactories);\n  math.import = internalImport; // listen for changes in config, import all functions again when changed\n  // TODO: move this listener into the import function?\n\n  math.on('config', () => {\n    values(importedFactories).forEach(factory => {\n      if (factory && factory.meta && factory.meta.recreateOnConfigChange) {\n        // FIXME: only re-create when the current instance is the same as was initially created\n        // FIXME: delete the functions/constants before importing them again?\n        internalImport(factory, {\n          override: true\n        });\n      }\n    });\n  }); // the create function exposed on the mathjs instance is bound to\n  // the factory functions passed before\n\n  math.create = create.bind(null, factories); // export factory function\n\n  math.factory = factory; // import the factory functions like createAdd as an array instead of object,\n  // else they will get a different naming (`createAdd` instead of `add`).\n\n  math.import(values(deepFlatten(factories)));\n  math.ArgumentsError = ArgumentsError;\n  math.DimensionError = DimensionError;\n  math.IndexError = IndexError;\n  return math;\n}","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/core/create.js"],"names":["_extends","typedFunction","deepFlatten","isLegacyFactory","values","emitter","importFactory","configFactory","factory","isFactory","isAccessorNode","isArray","isArrayNode","isAssignmentNode","isBigNumber","isBlockNode","isBoolean","isChain","isCollection","isComplex","isConditionalNode","isConstantNode","isDate","isDenseMatrix","isFraction","isFunction","isFunctionAssignmentNode","isFunctionNode","isHelp","isIndex","isIndexNode","isMatrix","isNode","isNull","isNumber","isObject","isObjectNode","isOperatorNode","isParenthesisNode","isRange","isRangeNode","isRelationalNode","isRegExp","isResultSet","isSparseMatrix","isString","isSymbolNode","isUndefined","isUnit","ArgumentsError","DimensionError","IndexError","DEFAULT_CONFIG","create","factories","config","configInternal","Object","Error","math","mixin","emit","expression","transform","mathWithTransform","legacyFactories","legacyInstances","load","firstProperty","keys","console","warn","index","indexOf","instance","type","typed","push","importedFactories","lazyTyped","_len","arguments","length","args","Array","_key","apply","isTypedFunction","internalImport","import","on","forEach","meta","recreateOnConfigChange","override","bind"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\r\nimport typedFunction from 'typed-function';\r\nimport { deepFlatten, isLegacyFactory, values } from '../utils/object.js';\r\nimport * as emitter from './../utils/emitter.js';\r\nimport { importFactory } from './function/import.js';\r\nimport { configFactory } from './function/config.js';\r\nimport { factory, isFactory } from '../utils/factory.js';\r\nimport { isAccessorNode, isArray, isArrayNode, isAssignmentNode, isBigNumber, isBlockNode, isBoolean, isChain, isCollection, isComplex, isConditionalNode, isConstantNode, isDate, isDenseMatrix, isFraction, isFunction, isFunctionAssignmentNode, isFunctionNode, isHelp, isIndex, isIndexNode, isMatrix, isNode, isNull, isNumber, isObject, isObjectNode, isOperatorNode, isParenthesisNode, isRange, isRangeNode, isRelationalNode, isRegExp, isResultSet, isSparseMatrix, isString, isSymbolNode, isUndefined, isUnit } from '../utils/is.js';\r\nimport { ArgumentsError } from '../error/ArgumentsError.js';\r\nimport { DimensionError } from '../error/DimensionError.js';\r\nimport { IndexError } from '../error/IndexError.js';\r\nimport { DEFAULT_CONFIG } from './config.js';\r\n\r\n/**\r\n * Create a mathjs instance from given factory functions and optionally config\r\n *\r\n * Usage:\r\n *\r\n *     const mathjs1 = create({ createAdd, createMultiply, ...})\r\n *     const config = { number: 'BigNumber' }\r\n *     const mathjs2 = create(all, config)\r\n *\r\n * @param {Object} [factories] An object with factory functions\r\n *                             The object can contain nested objects,\r\n *                             all nested objects will be flattened.\r\n * @param {Object} [config]    Available options:\r\n *                            {number} epsilon\r\n *                              Minimum relative difference between two\r\n *                              compared values, used by all comparison functions.\r\n *                            {string} matrix\r\n *                              A string 'Matrix' (default) or 'Array'.\r\n *                            {string} number\r\n *                              A string 'number' (default), 'BigNumber', or 'Fraction'\r\n *                            {number} precision\r\n *                              The number of significant digits for BigNumbers.\r\n *                              Not applicable for Numbers.\r\n *                            {boolean} predictable\r\n *                              Predictable output type of functions. When true,\r\n *                              output type depends only on the input types. When\r\n *                              false (default), output type can vary depending\r\n *                              on input values. For example `math.sqrt(-4)`\r\n *                              returns `complex('2i')` when predictable is false, and\r\n *                              returns `NaN` when true.\r\n *                            {string} randomSeed\r\n *                              Random seed for seeded pseudo random number generator.\r\n *                              Set to null to randomly seed.\r\n * @returns {Object} Returns a bare-bone math.js instance containing\r\n *                   functions:\r\n *                   - `import` to add new functions\r\n *                   - `config` to change configuration\r\n *                   - `on`, `off`, `once`, `emit` for events\r\n */\r\nexport function create(factories, config) {\r\n  var configInternal = _extends({}, DEFAULT_CONFIG, config);\r\n\r\n  // simple test for ES5 support\r\n  if (typeof Object.create !== 'function') {\r\n    throw new Error('ES5 not supported by this JavaScript engine. ' + 'Please load the es5-shim and es5-sham library for compatibility.');\r\n  }\r\n\r\n  // create the mathjs instance\r\n  var math = emitter.mixin({\r\n    // only here for backward compatibility for legacy factory functions\r\n    isNumber,\r\n    isComplex,\r\n    isBigNumber,\r\n    isFraction,\r\n    isUnit,\r\n    isString,\r\n    isArray,\r\n    isMatrix,\r\n    isCollection,\r\n    isDenseMatrix,\r\n    isSparseMatrix,\r\n    isRange,\r\n    isIndex,\r\n    isBoolean,\r\n    isResultSet,\r\n    isHelp,\r\n    isFunction,\r\n    isDate,\r\n    isRegExp,\r\n    isObject,\r\n    isNull,\r\n    isUndefined,\r\n    isAccessorNode,\r\n    isArrayNode,\r\n    isAssignmentNode,\r\n    isBlockNode,\r\n    isConditionalNode,\r\n    isConstantNode,\r\n    isFunctionAssignmentNode,\r\n    isFunctionNode,\r\n    isIndexNode,\r\n    isNode,\r\n    isObjectNode,\r\n    isOperatorNode,\r\n    isParenthesisNode,\r\n    isRangeNode,\r\n    isRelationalNode,\r\n    isSymbolNode,\r\n    isChain\r\n  });\r\n\r\n  // load config function and apply provided config\r\n  math.config = configFactory(configInternal, math.emit);\r\n  math.expression = {\r\n    transform: {},\r\n    mathWithTransform: {\r\n      config: math.config\r\n    }\r\n  };\r\n\r\n  // cached factories and instances used by function load\r\n  var legacyFactories = [];\r\n  var legacyInstances = [];\r\n\r\n  /**\r\n   * Load a function or data type from a factory.\r\n   * If the function or data type already exists, the existing instance is\r\n   * returned.\r\n   * @param {Function} factory\r\n   * @returns {*}\r\n   */\r\n  function load(factory) {\r\n    if (isFactory(factory)) {\r\n      return factory(math);\r\n    }\r\n    var firstProperty = factory[Object.keys(factory)[0]];\r\n    if (isFactory(firstProperty)) {\r\n      return firstProperty(math);\r\n    }\r\n    if (!isLegacyFactory(factory)) {\r\n      console.warn('Factory object with properties `type`, `name`, and `factory` expected', factory);\r\n      throw new Error('Factory object with properties `type`, `name`, and `factory` expected');\r\n    }\r\n    var index = legacyFactories.indexOf(factory);\r\n    var instance;\r\n    if (index === -1) {\r\n      // doesn't yet exist\r\n      if (factory.math === true) {\r\n        // pass with math namespace\r\n        instance = factory.factory(math.type, configInternal, load, math.typed, math);\r\n      } else {\r\n        instance = factory.factory(math.type, configInternal, load, math.typed);\r\n      }\r\n\r\n      // append to the cache\r\n      legacyFactories.push(factory);\r\n      legacyInstances.push(instance);\r\n    } else {\r\n      // already existing function, return the cached instance\r\n      instance = legacyInstances[index];\r\n    }\r\n    return instance;\r\n  }\r\n  var importedFactories = {};\r\n\r\n  // load the import function\r\n  function lazyTyped() {\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n    return math.typed.apply(math.typed, args);\r\n  }\r\n  lazyTyped.isTypedFunction = typedFunction.isTypedFunction;\r\n  var internalImport = importFactory(lazyTyped, load, math, importedFactories);\r\n  math.import = internalImport;\r\n\r\n  // listen for changes in config, import all functions again when changed\r\n  // TODO: move this listener into the import function?\r\n  math.on('config', () => {\r\n    values(importedFactories).forEach(factory => {\r\n      if (factory && factory.meta && factory.meta.recreateOnConfigChange) {\r\n        // FIXME: only re-create when the current instance is the same as was initially created\r\n        // FIXME: delete the functions/constants before importing them again?\r\n        internalImport(factory, {\r\n          override: true\r\n        });\r\n      }\r\n    });\r\n  });\r\n\r\n  // the create function exposed on the mathjs instance is bound to\r\n  // the factory functions passed before\r\n  math.create = create.bind(null, factories);\r\n\r\n  // export factory function\r\n  math.factory = factory;\r\n\r\n  // import the factory functions like createAdd as an array instead of object,\r\n  // else they will get a different naming (`createAdd` instead of `add`).\r\n  math.import(values(deepFlatten(factories)));\r\n  math.ArgumentsError = ArgumentsError;\r\n  math.DimensionError = DimensionError;\r\n  math.IndexError = IndexError;\r\n  return math;\r\n}"]},"metadata":{},"sourceType":"module"}