{"ast":null,"code":"import { isParenthesisNode } from '../../utils/is.js';\nimport { isConstantNode, isVariableNode, isNumericNode, isConstantExpression } from './simplify/wildcards.js';\nimport { factory } from '../../utils/factory.js';\nimport { createUtil } from './simplify/util.js';\nimport { hasOwnProperty } from '../../utils/object.js';\nimport { createEmptyMap, createMap } from '../../utils/map.js';\nvar name = 'simplify';\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', 'resolve', 'simplifyConstant', 'simplifyCore', '?fraction', '?bignumber', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplify = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    config,\n    typed,\n    parse,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    isZero,\n    equal,\n    resolve,\n    simplifyConstant,\n    simplifyCore,\n    fraction,\n    bignumber,\n    mathWithTransform,\n    matrix,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  var {\n    hasProperty,\n    isCommutative,\n    isAssociative,\n    mergeContext,\n    flatten,\n    unflattenr,\n    unflattenl,\n    createMakeNodeFunction,\n    defaultContext,\n    realContext,\n    positiveContext\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n  /**\r\n   * Simplify an expression tree.\r\n   *\r\n   * A list of rules are applied to an expression, repeating over the list until\r\n   * no further changes are made.\r\n   * It's possible to pass a custom set of rules to the function as second\r\n   * argument. A rule can be specified as an object, string, or function:\r\n   *\r\n   *     const rules = [\r\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\r\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\r\n   *       function (node) {\r\n   *         // ... return a new node or return the node unchanged\r\n   *         return node\r\n   *       }\r\n   *     ]\r\n   *\r\n   * String and object rules consist of a left and right pattern. The left is\r\n   * used to match against the expression and the right determines what matches\r\n   * are replaced with. The main difference between a pattern and a normal\r\n   * expression is that variables starting with the following characters are\r\n   * interpreted as wildcards:\r\n   *\r\n   * - 'n' - Matches any node [Node]\r\n   * - 'c' - Matches a constant literal (5 or 3.2) [ConstantNode]\r\n   * - 'cl' - Matches a constant literal; same as c [ConstantNode]\r\n   * - 'cd' - Matches a decimal literal (5 or -3.2) [ConstantNode or unaryMinus wrapping a ConstantNode]\r\n   * - 'ce' - Matches a constant expression (-5 or √3) [Expressions consisting of only ConstantNodes, functions, and operators]\r\n   * - 'v' - Matches a variable; anything not matched by c (-5 or x) [Node that is not a ConstantNode]\r\n   * - 'vl' - Matches a variable literal (x or y) [SymbolNode]\r\n   * - 'vd' - Matches a non-decimal expression; anything not matched by cd (x or √3) [Node that is not a ConstantNode or unaryMinus that is wrapping a ConstantNode]\r\n   * - 've' - Matches a variable expression; anything not matched by ce (x or 2x) [Expressions that contain a SymbolNode or other non-constant term]\r\n   *\r\n   * The default list of rules is exposed on the function as `simplify.rules`\r\n   * and can be used as a basis to built a set of custom rules. Note that since\r\n   * the `simplifyCore` function is in the default list of rules, by default\r\n   * simplify will convert any function calls in the expression that have\r\n   * operator equivalents to their operator forms.\r\n   *\r\n   * To specify a rule as a string, separate the left and right pattern by '->'\r\n   * When specifying a rule as an object, the following keys are meaningful:\r\n   * - l - the left pattern\r\n   * - r - the right pattern\r\n   * - s - in lieu of l and r, the string form that is broken at -> to give them\r\n   * - repeat - whether to repeat this rule until the expression stabilizes\r\n   * - assuming - gives a context object, as in the 'context' option to\r\n   *     simplify. Every property in the context object must match the current\r\n   *     context in order, or else the rule will not be applied.\r\n   * - imposeContext - gives a context object, as in the 'context' option to\r\n   *     simplify. Any settings specified will override the incoming context\r\n   *     for all matches of this rule.\r\n   *\r\n   * For more details on the theory, see:\r\n   *\r\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\r\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\r\n   *\r\n   *  An optional `options` argument can be passed as last argument of `simplify`.\r\n   *  Currently available options (defaults in parentheses):\r\n   *  - `consoleDebug` (false): whether to write the expression being simplified\r\n   *    and any changes to it, along with the rule responsible, to console\r\n   *  - `context` (simplify.defaultContext): an object giving properties of\r\n   *    each operator, which determine what simplifications are allowed. The\r\n   *    currently meaningful properties are commutative, associative,\r\n   *    total (whether the operation is defined for all arguments), and\r\n   *    trivial (whether the operation applied to a single argument leaves\r\n   *    that argument unchanged). The default context is very permissive and\r\n   *    allows almost all simplifications. Only properties differing from\r\n   *    the default need to be specified; the default context is used as a\r\n   *    fallback. Additional contexts `simplify.realContext` and\r\n   *    `simplify.positiveContext` are supplied to cause simplify to perform\r\n   *    just simplifications guaranteed to preserve all values of the expression\r\n   *    assuming all variables and subexpressions are real numbers or\r\n   *    positive real numbers, respectively. (Note that these are in some cases\r\n   *    more restrictive than the default context; for example, the default\r\n   *    context will allow `x/x` to simplify to 1, whereas\r\n   *    `simplify.realContext` will not, as `0/0` is not equal to 1.)\r\n   *  - `exactFractions` (true): whether to try to convert all constants to\r\n   *    exact rational numbers.\r\n   *  - `fractionsLimit` (10000): when `exactFractions` is true, constants will\r\n   *    be expressed as fractions only when both numerator and denominator\r\n   *    are smaller than `fractionsLimit`.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     simplify(expr)\r\n   *     simplify(expr, rules)\r\n   *     simplify(expr, rules)\r\n   *     simplify(expr, rules, scope)\r\n   *     simplify(expr, rules, scope, options)\r\n   *     simplify(expr, scope)\r\n   *     simplify(expr, scope, options)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\r\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\r\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\r\n   *     math.simplify(f)                          // Node \"2 * x\"\r\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\r\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplifyCore, derivative, evaluate, parse, rationalize, resolve\r\n   *\r\n   * @param {Node | string} expr\r\n   *            The expression to be simplified\r\n   * @param {SimplifyRule[]} [rules]\r\n   *            Optional list with custom rules\r\n   * @param {Object} [scope] Optional scope with variables\r\n   * @param {SimplifyOptions} [options] Optional configuration settings\r\n   * @return {Node} Returns the simplified form of `expr`\r\n   */\n\n  typed.addConversion({\n    from: 'Object',\n    to: 'Map',\n    convert: createMap\n  });\n  var simplify = typed('simplify', {\n    Node: _simplify,\n    'Node, Map': (expr, scope) => _simplify(expr, false, scope),\n    'Node, Map, Object': (expr, scope, options) => _simplify(expr, false, scope, options),\n    'Node, Array': _simplify,\n    'Node, Array, Map': _simplify,\n    'Node, Array, Map, Object': _simplify\n  });\n  typed.removeConversion({\n    from: 'Object',\n    to: 'Map',\n    convert: createMap\n  });\n  simplify.defaultContext = defaultContext;\n  simplify.realContext = realContext;\n  simplify.positiveContext = positiveContext;\n\n  function removeParens(node) {\n    return node.transform(function (node, path, parent) {\n      return isParenthesisNode(node) ? removeParens(node.content) : node;\n    });\n  } // All constants that are allowed in rules\n\n\n  var SUPPORTED_CONSTANTS = {\n    true: true,\n    false: true,\n    e: true,\n    i: true,\n    Infinity: true,\n    LN2: true,\n    LN10: true,\n    LOG2E: true,\n    LOG10E: true,\n    NaN: true,\n    phi: true,\n    pi: true,\n    SQRT1_2: true,\n    SQRT2: true,\n    tau: true // null: false,\n    // undefined: false,\n    // version: false,\n\n  }; // Array of strings, used to build the ruleSet.\n  // Each l (left side) and r (right side) are parsed by\n  // the expression parser into a node tree.\n  // Left hand sides are matched to subtrees within the\n  // expression to be parsed and replaced with the right\n  // hand side.\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\n  // It is possible to get into an infinite loop with conflicting rules\n\n  simplify.rules = [simplifyCore, // { l: 'n+0', r: 'n' },     // simplifyCore\n  // { l: 'n^0', r: '1' },     // simplifyCore\n  // { l: '0*n', r: '0' },     // simplifyCore\n  // { l: 'n/n', r: '1'},      // simplifyCore\n  // { l: 'n^1', r: 'n' },     // simplifyCore\n  // { l: '+n1', r:'n1' },     // simplifyCore\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\n  {\n    l: 'log(e)',\n    r: '1'\n  }, // temporary rules\n  // Note initially we tend constants to the right because like-term\n  // collection prefers the left, and we would rather collect nonconstants\n  {\n    s: 'n-n1 -> n+-n1',\n    // temporarily replace 'subtract' so we can further flatten the 'add' operator\n    assuming: {\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: 'n-n -> 0',\n    // partial alternative when we can't always subtract\n    assuming: {\n      subtract: {\n        total: false\n      }\n    }\n  }, {\n    s: '-(cl*v) -> v * (-cl)',\n    // make non-constant terms positive\n    assuming: {\n      multiply: {\n        commutative: true\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: '-(cl*v) -> (-cl) * v',\n    // non-commutative version, part 1\n    assuming: {\n      multiply: {\n        commutative: false\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: '-(v*cl) -> v * (-cl)',\n    // non-commutative version, part 2\n    assuming: {\n      multiply: {\n        commutative: false\n      },\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    l: '-(n1/n2)',\n    r: '-n1/n2'\n  }, {\n    l: '-v',\n    r: 'v * (-1)'\n  }, // finish making non-constant terms positive\n  {\n    l: '(n1 + n2)*(-1)',\n    r: 'n1*(-1) + n2*(-1)',\n    repeat: true\n  }, // expand negations to achieve as much sign cancellation as possible\n  {\n    l: 'n/n1^n2',\n    r: 'n*n1^-n2'\n  }, // temporarily replace 'divide' so we can further flatten the 'multiply' operator\n  {\n    l: 'n/n1',\n    r: 'n*n1^-1'\n  }, {\n    s: '(n1*n2)^n3 -> n1^n3 * n2^n3',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    }\n  }, {\n    s: '(n1*n2)^(-1) -> n2^(-1) * n1^(-1)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // expand nested exponentiation\n  {\n    s: '(n ^ n1) ^ n2 -> n ^ (n1 * n2)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // 1/(1/n) = n needs 1/n to exist\n\n  }, // collect like factors; into a sum, only do this for nonconstants\n  {\n    l: ' vd   * ( vd   * n1 + n2)',\n    r: 'vd^2       * n1 +  vd   * n2'\n  }, {\n    s: ' vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // v*1/v = v^(1+-1) needs 1/v\n\n  }, {\n    s: 'vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    }\n  }, {\n    s: 'vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2',\n    assuming: {\n      divide: {\n        total: true\n      }\n    }\n  }, {\n    l: 'n*n',\n    r: 'n^2'\n  }, {\n    s: 'n * n^n1 -> n^(n1+1)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // n*1/n = n^(-1+1) needs 1/n\n\n  }, {\n    s: 'n^n1 * n^n2 -> n^(n1+n2)',\n    assuming: {\n      divide: {\n        total: true\n      }\n    } // ditto for n^2*1/n^2\n\n  }, // Unfortunately, to deal with more complicated cancellations, it\n  // becomes necessary to simplify constants twice per pass. It's not\n  // terribly expensive compared to matching rules, so this should not\n  // pose a performance problem.\n  simplifyConstant, // First: before collecting like terms\n  // collect like terms\n  {\n    s: 'n+n -> 2*n',\n    assuming: {\n      add: {\n        total: true\n      }\n    } // 2 = 1 + 1 needs to exist\n\n  }, {\n    l: 'n+-n',\n    r: '0'\n  }, {\n    l: 'vd*n + vd',\n    r: 'vd*(n+1)'\n  }, // NOTE: leftmost position is special:\n  {\n    l: 'n3*n1 + n3*n2',\n    r: 'n3*(n1+n2)'\n  }, // All sub-monomials tried there.\n  {\n    l: 'n3^(-n4)*n1 +   n3  * n2',\n    r: 'n3^(-n4)*(n1 + n3^(n4+1) *n2)'\n  }, {\n    l: 'n3^(-n4)*n1 + n3^n5 * n2',\n    r: 'n3^(-n4)*(n1 + n3^(n4+n5)*n2)'\n  }, // noncommutative additional cases (term collection & factoring)\n  {\n    s: 'n*vd + vd -> (n+1)*vd',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'vd + n*vd -> (1+n)*vd',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3 + n2*n3 -> (n1+n2)*n3',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n^n1 * n -> n^(n1+1)',\n    assuming: {\n      divide: {\n        total: true\n      },\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    l: 'n*cd + cd',\n    r: '(n+1)*cd'\n  }, {\n    s: 'cd*n + cd -> cd*(n+1)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'cd + cd*n -> cd*(1+n)',\n    assuming: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, simplifyConstant, // Second: before returning expressions to \"standard form\"\n  // make factors positive (and undo 'make non-constant terms positive')\n  {\n    s: '(-n)*n1 -> -(n*n1)',\n    assuming: {\n      subtract: {\n        total: true\n      }\n    }\n  }, {\n    s: 'n1*(-n) -> -(n1*n)',\n    // in case * non-commutative\n    assuming: {\n      subtract: {\n        total: true\n      },\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // final ordering of constants\n  {\n    s: 'ce+ve -> ve+ce',\n    assuming: {\n      add: {\n        commutative: true\n      }\n    },\n    imposeContext: {\n      add: {\n        commutative: false\n      }\n    }\n  }, {\n    s: 'vd*cd -> cd*vd',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    },\n    imposeContext: {\n      multiply: {\n        commutative: false\n      }\n    }\n  }, // undo temporary rules\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\n  {\n    l: 'n+-n1',\n    r: 'n-n1'\n  }, // undo replace 'subtract'\n  {\n    s: 'n*(n1^-1) -> n/n1',\n    // undo replace 'divide'; for * commutative\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n\n  }, {\n    s: 'n*n1^-n2 -> n/n1^n2',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n\n  }, {\n    s: 'n^-1 -> 1/n',\n    assuming: {\n      multiply: {\n        commutative: true\n      }\n    } // o.w. / not conventional\n\n  }, {\n    l: 'n^1',\n    r: 'n'\n  }, // can be produced by power cancellation\n  {\n    s: 'n*(n1/n2) -> (n*n1)/n2',\n    // '*' before '/'\n    assuming: {\n      multiply: {\n        associative: true\n      }\n    }\n  }, {\n    s: 'n-(n1+n2) -> n-n1-n2',\n    // '-' before '+'\n    assuming: {\n      addition: {\n        associative: true,\n        commutative: true\n      }\n    }\n  }, // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\n  // simplifyConstant can leave an extra factor of 1, which can always\n  // be eliminated, since the identity always commutes\n  {\n    l: '1*n',\n    r: 'n',\n    imposeContext: {\n      multiply: {\n        commutative: true\n      }\n    }\n  }, {\n    s: 'n1/(n2/n3) -> (n1*n3)/n2',\n    assuming: {\n      multiply: {\n        associative: true\n      }\n    }\n  }, {\n    l: 'n1/(-n2)',\n    r: '-n1/n2'\n  }];\n  /**\r\n   * Takes any rule object as allowed by the specification in simplify\r\n   * and puts it in a standard form used by applyRule\r\n   */\n\n  function _canonicalizeRule(ruleObject, context) {\n    var newRule = {};\n\n    if (ruleObject.s) {\n      var lr = ruleObject.s.split('->');\n\n      if (lr.length === 2) {\n        newRule.l = lr[0];\n        newRule.r = lr[1];\n      } else {\n        throw SyntaxError('Could not parse rule: ' + ruleObject.s);\n      }\n    } else {\n      newRule.l = ruleObject.l;\n      newRule.r = ruleObject.r;\n    }\n\n    newRule.l = removeParens(parse(newRule.l));\n    newRule.r = removeParens(parse(newRule.r));\n\n    for (var prop of ['imposeContext', 'repeat', 'assuming']) {\n      if (prop in ruleObject) {\n        newRule[prop] = ruleObject[prop];\n      }\n    }\n\n    if (ruleObject.evaluate) {\n      newRule.evaluate = parse(ruleObject.evaluate);\n    }\n\n    if (isAssociative(newRule.l, context)) {\n      var nonCommutative = !isCommutative(newRule.l, context);\n      var leftExpandsym; // Gen. the LHS placeholder used in this NC-context specific expansion rules\n\n      if (nonCommutative) leftExpandsym = _getExpandPlaceholderSymbol();\n      var makeNode = createMakeNodeFunction(newRule.l);\n\n      var expandsym = _getExpandPlaceholderSymbol();\n\n      newRule.expanded = {};\n      newRule.expanded.l = makeNode([newRule.l, expandsym]); // Push the expandsym into the deepest possible branch.\n      // This helps to match the newRule against nodes returned from getSplits() later on.\n\n      flatten(newRule.expanded.l, context);\n      unflattenr(newRule.expanded.l, context);\n      newRule.expanded.r = makeNode([newRule.r, expandsym]); // In and for a non-commutative context, attempting with yet additional expansion rules makes\n      // way for more matches cases of multi-arg expressions; such that associative rules (such as\n      // 'n*n -> n^2') can be applied to exprs. such as 'a * b * b' and 'a * b * b * a'.\n\n      if (nonCommutative) {\n        // 'Non-commutative' 1: LHS (placeholder) only\n        newRule.expandedNC1 = {};\n        newRule.expandedNC1.l = makeNode([leftExpandsym, newRule.l]);\n        newRule.expandedNC1.r = makeNode([leftExpandsym, newRule.r]); // 'Non-commutative' 2: farmost LHS and RHS placeholders\n\n        newRule.expandedNC2 = {};\n        newRule.expandedNC2.l = makeNode([leftExpandsym, newRule.expanded.l]);\n        newRule.expandedNC2.r = makeNode([leftExpandsym, newRule.expanded.r]);\n      }\n    }\n\n    return newRule;\n  }\n  /**\r\n   * Parse the string array of rules into nodes\r\n   *\r\n   * Example syntax for rules:\r\n   *\r\n   * Position constants to the left in a product:\r\n   * { l: 'n1 * c1', r: 'c1 * n1' }\r\n   * n1 is any Node, and c1 is a ConstantNode.\r\n   *\r\n   * Apply difference of squares formula:\r\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\r\n   * n1, n2 mean any Node.\r\n   *\r\n   * Short hand notation:\r\n   * 'n1 * c1 -> c1 * n1'\r\n   */\n\n\n  function _buildRules(rules, context) {\n    // Array of rules to be used to simplify expressions\n    var ruleSet = [];\n\n    for (var i = 0; i < rules.length; i++) {\n      var rule = rules[i];\n      var newRule = void 0;\n      var ruleType = typeof rule;\n\n      switch (ruleType) {\n        case 'string':\n          rule = {\n            s: rule\n          };\n\n        /* falls through */\n\n        case 'object':\n          newRule = _canonicalizeRule(rule, context);\n          break;\n\n        case 'function':\n          newRule = rule;\n          break;\n\n        default:\n          throw TypeError('Unsupported type of rule: ' + ruleType);\n      } // console.log('Adding rule: ' + rules[i])\n      // console.log(newRule)\n\n\n      ruleSet.push(newRule);\n    }\n\n    return ruleSet;\n  }\n\n  var _lastsym = 0;\n\n  function _getExpandPlaceholderSymbol() {\n    return new SymbolNode('_p' + _lastsym++);\n  }\n\n  function _simplify(expr, rules) {\n    var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createEmptyMap();\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var debug = options.consoleDebug;\n    rules = _buildRules(rules || simplify.rules, options.context);\n    var res = resolve(expr, scope);\n    res = removeParens(res);\n    var visited = {};\n    var str = res.toString({\n      parenthesis: 'all'\n    });\n\n    while (!visited[str]) {\n      visited[str] = true;\n      _lastsym = 0; // counter for placeholder symbols\n\n      var laststr = str;\n      if (debug) console.log('Working on: ', str);\n\n      for (var i = 0; i < rules.length; i++) {\n        var rulestr = '';\n\n        if (typeof rules[i] === 'function') {\n          res = rules[i](res, options);\n          if (debug) rulestr = rules[i].name;\n        } else {\n          flatten(res, options.context);\n          res = applyRule(res, rules[i], options.context);\n\n          if (debug) {\n            rulestr = \"\".concat(rules[i].l.toString(), \" -> \").concat(rules[i].r.toString());\n          }\n        }\n\n        if (debug) {\n          var newstr = res.toString({\n            parenthesis: 'all'\n          });\n\n          if (newstr !== laststr) {\n            console.log('Applying', rulestr, 'produced', newstr);\n            laststr = newstr;\n          }\n        }\n        /* Use left-heavy binary tree internally,\r\n         * since custom rule functions may expect it\r\n         */\n\n\n        unflattenl(res, options.context);\n      }\n\n      str = res.toString({\n        parenthesis: 'all'\n      });\n    }\n\n    return res;\n  }\n\n  function mapRule(nodes, rule, context) {\n    var resNodes = nodes;\n\n    if (nodes) {\n      for (var i = 0; i < nodes.length; ++i) {\n        var newNode = applyRule(nodes[i], rule, context);\n\n        if (newNode !== nodes[i]) {\n          if (resNodes === nodes) {\n            resNodes = nodes.slice();\n          }\n\n          resNodes[i] = newNode;\n        }\n      }\n    }\n\n    return resNodes;\n  }\n  /**\r\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\r\n   *\r\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\r\n   * @param  {Object | Function} rule\r\n   * @param  {Object} context -- information about assumed properties of operators\r\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\r\n   */\n\n\n  function applyRule(node, rule, context) {\n    //    console.log('Entering applyRule(\"', rule.l.toString({parenthesis:'all'}), '->', rule.r.toString({parenthesis:'all'}), '\",', node.toString({parenthesis:'all'}),')')\n    // check that the assumptions for this rule are satisfied by the current\n    // context:\n    if (rule.assuming) {\n      for (var symbol in rule.assuming) {\n        for (var property in rule.assuming[symbol]) {\n          if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {\n            return node;\n          }\n        }\n      }\n    }\n\n    var mergedContext = mergeContext(rule.imposeContext, context); // Do not clone node unless we find a match\n\n    var res = node; // First replace our child nodes with their simplified versions\n    // If a child could not be simplified, applying the rule to it\n    // will have no effect since the node is returned unchanged\n\n    if (res instanceof OperatorNode || res instanceof FunctionNode) {\n      var newArgs = mapRule(res.args, rule, context);\n\n      if (newArgs !== res.args) {\n        res = res.clone();\n        res.args = newArgs;\n      }\n    } else if (res instanceof ParenthesisNode) {\n      if (res.content) {\n        var newContent = applyRule(res.content, rule, context);\n\n        if (newContent !== res.content) {\n          res = new ParenthesisNode(newContent);\n        }\n      }\n    } else if (res instanceof ArrayNode) {\n      var newItems = mapRule(res.items, rule, context);\n\n      if (newItems !== res.items) {\n        res = new ArrayNode(newItems);\n      }\n    } else if (res instanceof AccessorNode) {\n      var newObj = res.object;\n\n      if (res.object) {\n        newObj = applyRule(res.object, rule, context);\n      }\n\n      var newIndex = res.index;\n\n      if (res.index) {\n        newIndex = applyRule(res.index, rule, context);\n      }\n\n      if (newObj !== res.object || newIndex !== res.index) {\n        res = new AccessorNode(newObj, newIndex);\n      }\n    } else if (res instanceof IndexNode) {\n      var newDims = mapRule(res.dimensions, rule, context);\n\n      if (newDims !== res.dimensions) {\n        res = new IndexNode(newDims);\n      }\n    } else if (res instanceof ObjectNode) {\n      var changed = false;\n      var newProps = {};\n\n      for (var prop in res.properties) {\n        newProps[prop] = applyRule(res.properties[prop], rule, context);\n\n        if (newProps[prop] !== res.properties[prop]) {\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        res = new ObjectNode(newProps);\n      }\n    } // Try to match a rule against this node\n\n\n    var repl = rule.r;\n\n    var matches = _ruleMatch(rule.l, res, mergedContext)[0]; // If the rule is associative operator, we can try matching it while allowing additional terms.\n    // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\n\n\n    if (!matches && rule.expanded) {\n      repl = rule.expanded.r;\n      matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];\n    } // Additional, non-commutative context expansion-rules\n\n\n    if (!matches && rule.expandedNC1) {\n      repl = rule.expandedNC1.r;\n      matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];\n\n      if (!matches) {\n        // Existence of NC1 implies NC2\n        repl = rule.expandedNC2.r;\n        matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];\n      }\n    }\n\n    if (matches) {\n      // const before = res.toString({parenthesis: 'all'})\n      // Create a new node by cloning the rhs of the matched rule\n      // we keep any implicit multiplication state if relevant\n      var implicit = res.implicit;\n      res = repl.clone();\n\n      if (implicit && 'implicit' in repl) {\n        res.implicit = true;\n      } // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\n\n\n      res = res.transform(function (node) {\n        if (node.isSymbolNode && hasOwnProperty(matches.placeholders, node.name)) {\n          return matches.placeholders[node.name].clone();\n        } else {\n          return node;\n        }\n      }); // const after = res.toString({parenthesis: 'all'})\n      // console.log('Simplified ' + before + ' to ' + after)\n    }\n\n    if (rule.repeat && res !== node) {\n      res = applyRule(res, rule, context);\n    }\n\n    return res;\n  }\n  /**\r\n   * Get (binary) combinations of a flattened binary node\r\n   * e.g. +(node1, node2, node3) -> [\r\n   *        +(node1,  +(node2, node3)),\r\n   *        +(node2,  +(node1, node3)),\r\n   *        +(node3,  +(node1, node2))]\r\n   *\r\n   */\n\n\n  function getSplits(node, context) {\n    var res = [];\n    var right, rightArgs;\n    var makeNode = createMakeNodeFunction(node);\n\n    if (isCommutative(node, context)) {\n      for (var i = 0; i < node.args.length; i++) {\n        rightArgs = node.args.slice(0);\n        rightArgs.splice(i, 1);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([node.args[i], right]));\n      }\n    } else {\n      // Keep order, but try all parenthesizations\n      for (var _i = 1; _i < node.args.length; _i++) {\n        var left = node.args[0];\n\n        if (_i > 1) {\n          left = makeNode(node.args.slice(0, _i));\n        }\n\n        rightArgs = node.args.slice(_i);\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\n        res.push(makeNode([left, right]));\n      }\n    }\n\n    return res;\n  }\n  /**\r\n   * Returns the set union of two match-placeholders or null if there is a conflict.\r\n   */\n\n\n  function mergeMatch(match1, match2) {\n    var res = {\n      placeholders: {}\n    }; // Some matches may not have placeholders; this is OK\n\n    if (!match1.placeholders && !match2.placeholders) {\n      return res;\n    } else if (!match1.placeholders) {\n      return match2;\n    } else if (!match2.placeholders) {\n      return match1;\n    } // Placeholders with the same key must match exactly\n\n\n    for (var key in match1.placeholders) {\n      if (hasOwnProperty(match1.placeholders, key)) {\n        res.placeholders[key] = match1.placeholders[key];\n\n        if (hasOwnProperty(match2.placeholders, key)) {\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\n            return null;\n          }\n        }\n      }\n    }\n\n    for (var _key in match2.placeholders) {\n      if (hasOwnProperty(match2.placeholders, _key)) {\n        res.placeholders[_key] = match2.placeholders[_key];\n      }\n    }\n\n    return res;\n  }\n  /**\r\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\r\n   * Each list represents matches found in one child of a node.\r\n   */\n\n\n  function combineChildMatches(list1, list2) {\n    var res = [];\n\n    if (list1.length === 0 || list2.length === 0) {\n      return res;\n    }\n\n    var merged;\n\n    for (var i1 = 0; i1 < list1.length; i1++) {\n      for (var i2 = 0; i2 < list2.length; i2++) {\n        merged = mergeMatch(list1[i1], list2[i2]);\n\n        if (merged) {\n          res.push(merged);\n        }\n      }\n    }\n\n    return res;\n  }\n  /**\r\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\r\n   * Each list represents matches found in one child of a node.\r\n   * Returns a list of unique matches.\r\n   */\n\n\n  function mergeChildMatches(childMatches) {\n    if (childMatches.length === 0) {\n      return childMatches;\n    }\n\n    var sets = childMatches.reduce(combineChildMatches);\n    var uniqueSets = [];\n    var unique = {};\n\n    for (var i = 0; i < sets.length; i++) {\n      var s = JSON.stringify(sets[i]);\n\n      if (!unique[s]) {\n        unique[s] = true;\n        uniqueSets.push(sets[i]);\n      }\n    }\n\n    return uniqueSets;\n  }\n  /**\r\n   * Determines whether node matches rule.\r\n   *\r\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\r\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\r\n   * @param {Object} context -- provides assumed properties of operators\r\n   * @param {Boolean} isSplit -- whether we are in process of splitting an\r\n   *                    n-ary operator node into possible binary combinations.\r\n   *                    Defaults to false.\r\n   * @return {Object} Information about the match, if it exists.\r\n   */\n\n\n  function _ruleMatch(rule, node, context, isSplit) {\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\n    //    console.log('rule = ' + rule)\n    //    console.log('node = ' + node)\n    //    console.log('Entering _ruleMatch(', rule.toString({parenthesis:'all'}), ', ', node.toString({parenthesis:'all'}), ', ', context, ')')\n    var res = [{\n      placeholders: {}\n    }];\n\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\n      if (rule instanceof OperatorNode) {\n        if (rule.op !== node.op || rule.fn !== node.fn) {\n          return [];\n        }\n      } else if (rule instanceof FunctionNode) {\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } // rule and node match. Search the children of rule and node.\n\n\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {\n        // Expect non-associative operators to match exactly,\n        // except in any order if operator is commutative\n        var childMatches = [];\n\n        for (var i = 0; i < rule.args.length; i++) {\n          var childMatch = _ruleMatch(rule.args[i], node.args[i], context);\n\n          if (childMatch.length === 0) {\n            // Child did not match, so stop searching immediately\n            break;\n          } // The child matched, so add the information returned from the child to our result\n\n\n          childMatches.push(childMatch);\n        }\n\n        if (childMatches.length !== rule.args.length) {\n          if (!isCommutative(node, context) || // exact match in order needed\n          rule.args.length === 1) {\n            // nothing to commute\n            return [];\n          }\n\n          if (rule.args.length > 2) {\n            /* Need to generate all permutations and try them.\r\n             * It's a bit complicated, and unlikely to come up since there\r\n             * are very few ternary or higher operators. So punt for now.\r\n             */\n            throw new Error('permuting >2 commutative non-associative rule arguments not yet implemented');\n          }\n          /* Exactly two arguments, try them reversed */\n\n\n          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);\n\n          if (leftMatch.length === 0) {\n            return [];\n          }\n\n          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);\n\n          if (rightMatch.length === 0) {\n            return [];\n          }\n\n          childMatches = [leftMatch, rightMatch];\n        }\n\n        res = mergeChildMatches(childMatches);\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\n        // node is flattened, rule is not\n        // Associative operators/functions can be split in different ways so we check if the rule\n        // matches for each of them and return their union.\n        var splits = getSplits(node, context);\n        var splitMatches = [];\n\n        for (var _i2 = 0; _i2 < splits.length; _i2++) {\n          var matchSet = _ruleMatch(rule, splits[_i2], context, true); // recursing at the same tree depth here\n\n\n          splitMatches = splitMatches.concat(matchSet);\n        }\n\n        return splitMatches;\n      } else if (rule.args.length > 2) {\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\n      } else {\n        // Incorrect number of arguments in rule and node, so no match\n        return [];\n      }\n    } else if (rule instanceof SymbolNode) {\n      // If the rule is a SymbolNode, then it carries a special meaning\n      // according to the first one or two characters of the symbol node name.\n      // These meanings are expalined in the documentation for simplify()\n      if (rule.name.length === 0) {\n        throw new Error('Symbol in rule has 0 length...!?');\n      }\n\n      if (SUPPORTED_CONSTANTS[rule.name]) {\n        // built-in constant must match exactly\n        if (rule.name !== node.name) {\n          return [];\n        }\n      } else {\n        // wildcards are composed of up to two alphabetic or underscore characters\n        switch (rule.name[1] >= 'a' && rule.name[1] <= 'z' ? rule.name.substring(0, 2) : rule.name[0]) {\n          case 'n':\n          case '_p':\n            // rule matches _anything_, so assign this node to the rule.name placeholder\n            // Assign node to the rule.name placeholder.\n            // Our parent will check for matches among placeholders.\n            res[0].placeholders[rule.name] = node;\n            break;\n\n          case 'c':\n          case 'cl':\n            // rule matches a ConstantNode\n            if (isConstantNode(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n\n            break;\n\n          case 'v':\n            // rule matches anything other than a ConstantNode\n            if (!isConstantNode(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n\n            break;\n\n          case 'vl':\n            // rule matches VariableNode\n            if (isVariableNode(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n\n            break;\n\n          case 'cd':\n            // rule matches a ConstantNode or unaryMinus-wrapped ConstantNode\n            if (isNumericNode(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n\n            break;\n\n          case 'vd':\n            // rule matches anything other than a ConstantNode or unaryMinus-wrapped ConstantNode\n            if (!isNumericNode(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n\n            break;\n\n          case 'ce':\n            // rule matches expressions that have a constant value\n            if (isConstantExpression(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n\n            break;\n\n          case 've':\n            // rule matches expressions that do not have a constant value\n            if (!isConstantExpression(node)) {\n              res[0].placeholders[rule.name] = node;\n            } else {\n              // mis-match: rule does not encompass current node\n              return [];\n            }\n\n            break;\n\n          default:\n            throw new Error('Invalid symbol in rule: ' + rule.name);\n        }\n      }\n    } else if (rule instanceof ConstantNode) {\n      // Literal constant must match exactly\n      if (!equal(rule.value, node.value)) {\n        return [];\n      }\n    } else {\n      // Some other node was encountered which we aren't prepared for, so no match\n      return [];\n    } // It's a match!\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\n\n\n    return res;\n  }\n  /**\r\n   * Determines whether p and q (and all their children nodes) are identical.\r\n   *\r\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\r\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\r\n   * @return {Object} Information about the match, if it exists.\r\n   */\n\n\n  function _exactMatch(p, q) {\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\n      if (!equal(p.value, q.value)) {\n        return false;\n      }\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\n      if (p.name !== q.name) {\n        return false;\n      }\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\n      if (p instanceof OperatorNode) {\n        if (p.op !== q.op || p.fn !== q.fn) {\n          return false;\n        }\n      } else if (p instanceof FunctionNode) {\n        if (p.name !== q.name) {\n          return false;\n        }\n      }\n\n      if (p.args.length !== q.args.length) {\n        return false;\n      }\n\n      for (var i = 0; i < p.args.length; i++) {\n        if (!_exactMatch(p.args[i], q.args[i])) {\n          return false;\n        }\n      }\n    } else {\n      return false;\n    }\n\n    return true;\n  }\n\n  return simplify;\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/simplify.js"],"names":["isParenthesisNode","isConstantNode","isVariableNode","isNumericNode","isConstantExpression","factory","createUtil","hasOwnProperty","createEmptyMap","createMap","name","dependencies","createSimplify","_ref","config","typed","parse","add","subtract","multiply","divide","pow","isZero","equal","resolve","simplifyConstant","simplifyCore","fraction","bignumber","mathWithTransform","matrix","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode","hasProperty","isCommutative","isAssociative","mergeContext","flatten","unflattenr","unflattenl","createMakeNodeFunction","defaultContext","realContext","positiveContext","addConversion","from","to","convert","simplify","Node","_simplify","expr","scope","options","removeConversion","removeParens","node","transform","path","parent","content","SUPPORTED_CONSTANTS","true","false","e","i","Infinity","LN2","LN10","LOG2E","LOG10E","NaN","phi","pi","SQRT1_2","SQRT2","tau","rules","l","r","s","assuming","total","commutative","repeat","imposeContext","associative","addition","_canonicalizeRule","ruleObject","context","newRule","lr","split","length","SyntaxError","prop","evaluate","nonCommutative","leftExpandsym","_getExpandPlaceholderSymbol","makeNode","expandsym","expanded","expandedNC1","expandedNC2","_buildRules","ruleSet","rule","ruleType","TypeError","push","_lastsym","arguments","undefined","debug","consoleDebug","res","visited","str","toString","parenthesis","laststr","console","log","rulestr","applyRule","concat","newstr","mapRule","nodes","resNodes","newNode","slice","symbol","property","mergedContext","newArgs","args","clone","newContent","newItems","items","newObj","object","newIndex","index","newDims","dimensions","changed","newProps","properties","repl","matches","_ruleMatch","implicit","isSymbolNode","placeholders","getSplits","right","rightArgs","splice","_i","left","mergeMatch","match1","match2","key","_exactMatch","_key","combineChildMatches","list1","list2","merged","i1","i2","mergeChildMatches","childMatches","sets","reduce","uniqueSets","unique","JSON","stringify","isSplit","op","fn","childMatch","Error","leftMatch","rightMatch","splits","splitMatches","_i2","matchSet","substring","value","p","q"],"mappings":"AAAA,SAASA,iBAAT,QAAkC,mBAAlC;AACA,SAASC,cAAT,EAAyBC,cAAzB,EAAyCC,aAAzC,EAAwDC,oBAAxD,QAAoF,yBAApF;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,UAAT,QAA2B,oBAA3B;AACA,SAASC,cAAT,QAA+B,uBAA/B;AACA,SAASC,cAAT,EAAyBC,SAAzB,QAA0C,oBAA1C;AACA,IAAIC,IAAI,GAAG,UAAX;AACA,IAAIC,YAAY,GAAG,CAAC,QAAD,EAAW,OAAX,EAAoB,OAApB,EAA6B,KAA7B,EAAoC,UAApC,EAAgD,UAAhD,EAA4D,QAA5D,EAAsE,KAAtE,EAA6E,QAA7E,EAAuF,OAAvF,EAAgG,SAAhG,EAA2G,kBAA3G,EAA+H,cAA/H,EAA+I,WAA/I,EAA4J,YAA5J,EAA0K,mBAA1K,EAA+L,QAA/L,EAAyM,cAAzM,EAAyN,WAAzN,EAAsO,cAAtO,EAAsP,cAAtP,EAAsQ,WAAtQ,EAAmR,YAAnR,EAAiS,cAAjS,EAAiT,iBAAjT,EAAoU,YAApU,CAAnB;AACA,OAAO,IAAIC,cAAc,GAAG,eAAeP,OAAO,CAACK,IAAD,EAAOC,YAAP,EAAqBE,IAAI,IAAI;AAC7E,MAAI;AACFC,IAAAA,MADE;AAEFC,IAAAA,KAFE;AAGFC,IAAAA,KAHE;AAIFC,IAAAA,GAJE;AAKFC,IAAAA,QALE;AAMFC,IAAAA,QANE;AAOFC,IAAAA,MAPE;AAQFC,IAAAA,GARE;AASFC,IAAAA,MATE;AAUFC,IAAAA,KAVE;AAWFC,IAAAA,OAXE;AAYFC,IAAAA,gBAZE;AAaFC,IAAAA,YAbE;AAcFC,IAAAA,QAdE;AAeFC,IAAAA,SAfE;AAgBFC,IAAAA,iBAhBE;AAiBFC,IAAAA,MAjBE;AAkBFC,IAAAA,YAlBE;AAmBFC,IAAAA,SAnBE;AAoBFC,IAAAA,YApBE;AAqBFC,IAAAA,YArBE;AAsBFC,IAAAA,SAtBE;AAuBFC,IAAAA,UAvBE;AAwBFC,IAAAA,YAxBE;AAyBFC,IAAAA,eAzBE;AA0BFC,IAAAA;AA1BE,MA2BA1B,IA3BJ;AA4BA,MAAI;AACF2B,IAAAA,WADE;AAEFC,IAAAA,aAFE;AAGFC,IAAAA,aAHE;AAIFC,IAAAA,YAJE;AAKFC,IAAAA,OALE;AAMFC,IAAAA,UANE;AAOFC,IAAAA,UAPE;AAQFC,IAAAA,sBARE;AASFC,IAAAA,cATE;AAUFC,IAAAA,WAVE;AAWFC,IAAAA;AAXE,MAYA5C,UAAU,CAAC;AACb4B,IAAAA,YADa;AAEbG,IAAAA,YAFa;AAGbE,IAAAA;AAHa,GAAD,CAZd;AAkBA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACExB,EAAAA,KAAK,CAACoC,aAAN,CAAoB;AAClBC,IAAAA,IAAI,EAAE,QADY;AAElBC,IAAAA,EAAE,EAAE,KAFc;AAGlBC,IAAAA,OAAO,EAAE7C;AAHS,GAApB;AAKA,MAAI8C,QAAQ,GAAGxC,KAAK,CAAC,UAAD,EAAa;AAC/ByC,IAAAA,IAAI,EAAEC,SADyB;AAE/B,iBAAa,CAACC,IAAD,EAAOC,KAAP,KAAiBF,SAAS,CAACC,IAAD,EAAO,KAAP,EAAcC,KAAd,CAFR;AAG/B,yBAAqB,CAACD,IAAD,EAAOC,KAAP,EAAcC,OAAd,KAA0BH,SAAS,CAACC,IAAD,EAAO,KAAP,EAAcC,KAAd,EAAqBC,OAArB,C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","sourcesContent":["import { isParenthesisNode } from '../../utils/is.js';\r\nimport { isConstantNode, isVariableNode, isNumericNode, isConstantExpression } from './simplify/wildcards.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { createUtil } from './simplify/util.js';\r\nimport { hasOwnProperty } from '../../utils/object.js';\r\nimport { createEmptyMap, createMap } from '../../utils/map.js';\r\nvar name = 'simplify';\r\nvar dependencies = ['config', 'typed', 'parse', 'add', 'subtract', 'multiply', 'divide', 'pow', 'isZero', 'equal', 'resolve', 'simplifyConstant', 'simplifyCore', '?fraction', '?bignumber', 'mathWithTransform', 'matrix', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\r\nexport var createSimplify = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    config,\r\n    typed,\r\n    parse,\r\n    add,\r\n    subtract,\r\n    multiply,\r\n    divide,\r\n    pow,\r\n    isZero,\r\n    equal,\r\n    resolve,\r\n    simplifyConstant,\r\n    simplifyCore,\r\n    fraction,\r\n    bignumber,\r\n    mathWithTransform,\r\n    matrix,\r\n    AccessorNode,\r\n    ArrayNode,\r\n    ConstantNode,\r\n    FunctionNode,\r\n    IndexNode,\r\n    ObjectNode,\r\n    OperatorNode,\r\n    ParenthesisNode,\r\n    SymbolNode\r\n  } = _ref;\r\n  var {\r\n    hasProperty,\r\n    isCommutative,\r\n    isAssociative,\r\n    mergeContext,\r\n    flatten,\r\n    unflattenr,\r\n    unflattenl,\r\n    createMakeNodeFunction,\r\n    defaultContext,\r\n    realContext,\r\n    positiveContext\r\n  } = createUtil({\r\n    FunctionNode,\r\n    OperatorNode,\r\n    SymbolNode\r\n  });\r\n\r\n  /**\r\n   * Simplify an expression tree.\r\n   *\r\n   * A list of rules are applied to an expression, repeating over the list until\r\n   * no further changes are made.\r\n   * It's possible to pass a custom set of rules to the function as second\r\n   * argument. A rule can be specified as an object, string, or function:\r\n   *\r\n   *     const rules = [\r\n   *       { l: 'n1*n3 + n2*n3', r: '(n1+n2)*n3' },\r\n   *       'n1*n3 + n2*n3 -> (n1+n2)*n3',\r\n   *       function (node) {\r\n   *         // ... return a new node or return the node unchanged\r\n   *         return node\r\n   *       }\r\n   *     ]\r\n   *\r\n   * String and object rules consist of a left and right pattern. The left is\r\n   * used to match against the expression and the right determines what matches\r\n   * are replaced with. The main difference between a pattern and a normal\r\n   * expression is that variables starting with the following characters are\r\n   * interpreted as wildcards:\r\n   *\r\n   * - 'n' - Matches any node [Node]\r\n   * - 'c' - Matches a constant literal (5 or 3.2) [ConstantNode]\r\n   * - 'cl' - Matches a constant literal; same as c [ConstantNode]\r\n   * - 'cd' - Matches a decimal literal (5 or -3.2) [ConstantNode or unaryMinus wrapping a ConstantNode]\r\n   * - 'ce' - Matches a constant expression (-5 or √3) [Expressions consisting of only ConstantNodes, functions, and operators]\r\n   * - 'v' - Matches a variable; anything not matched by c (-5 or x) [Node that is not a ConstantNode]\r\n   * - 'vl' - Matches a variable literal (x or y) [SymbolNode]\r\n   * - 'vd' - Matches a non-decimal expression; anything not matched by cd (x or √3) [Node that is not a ConstantNode or unaryMinus that is wrapping a ConstantNode]\r\n   * - 've' - Matches a variable expression; anything not matched by ce (x or 2x) [Expressions that contain a SymbolNode or other non-constant term]\r\n   *\r\n   * The default list of rules is exposed on the function as `simplify.rules`\r\n   * and can be used as a basis to built a set of custom rules. Note that since\r\n   * the `simplifyCore` function is in the default list of rules, by default\r\n   * simplify will convert any function calls in the expression that have\r\n   * operator equivalents to their operator forms.\r\n   *\r\n   * To specify a rule as a string, separate the left and right pattern by '->'\r\n   * When specifying a rule as an object, the following keys are meaningful:\r\n   * - l - the left pattern\r\n   * - r - the right pattern\r\n   * - s - in lieu of l and r, the string form that is broken at -> to give them\r\n   * - repeat - whether to repeat this rule until the expression stabilizes\r\n   * - assuming - gives a context object, as in the 'context' option to\r\n   *     simplify. Every property in the context object must match the current\r\n   *     context in order, or else the rule will not be applied.\r\n   * - imposeContext - gives a context object, as in the 'context' option to\r\n   *     simplify. Any settings specified will override the incoming context\r\n   *     for all matches of this rule.\r\n   *\r\n   * For more details on the theory, see:\r\n   *\r\n   * - [Strategies for simplifying math expressions (Stackoverflow)](https://stackoverflow.com/questions/7540227/strategies-for-simplifying-math-expressions)\r\n   * - [Symbolic computation - Simplification (Wikipedia)](https://en.wikipedia.org/wiki/Symbolic_computation#Simplification)\r\n   *\r\n   *  An optional `options` argument can be passed as last argument of `simplify`.\r\n   *  Currently available options (defaults in parentheses):\r\n   *  - `consoleDebug` (false): whether to write the expression being simplified\r\n   *    and any changes to it, along with the rule responsible, to console\r\n   *  - `context` (simplify.defaultContext): an object giving properties of\r\n   *    each operator, which determine what simplifications are allowed. The\r\n   *    currently meaningful properties are commutative, associative,\r\n   *    total (whether the operation is defined for all arguments), and\r\n   *    trivial (whether the operation applied to a single argument leaves\r\n   *    that argument unchanged). The default context is very permissive and\r\n   *    allows almost all simplifications. Only properties differing from\r\n   *    the default need to be specified; the default context is used as a\r\n   *    fallback. Additional contexts `simplify.realContext` and\r\n   *    `simplify.positiveContext` are supplied to cause simplify to perform\r\n   *    just simplifications guaranteed to preserve all values of the expression\r\n   *    assuming all variables and subexpressions are real numbers or\r\n   *    positive real numbers, respectively. (Note that these are in some cases\r\n   *    more restrictive than the default context; for example, the default\r\n   *    context will allow `x/x` to simplify to 1, whereas\r\n   *    `simplify.realContext` will not, as `0/0` is not equal to 1.)\r\n   *  - `exactFractions` (true): whether to try to convert all constants to\r\n   *    exact rational numbers.\r\n   *  - `fractionsLimit` (10000): when `exactFractions` is true, constants will\r\n   *    be expressed as fractions only when both numerator and denominator\r\n   *    are smaller than `fractionsLimit`.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     simplify(expr)\r\n   *     simplify(expr, rules)\r\n   *     simplify(expr, rules)\r\n   *     simplify(expr, rules, scope)\r\n   *     simplify(expr, rules, scope, options)\r\n   *     simplify(expr, scope)\r\n   *     simplify(expr, scope, options)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.simplify('2 * 1 * x ^ (2 - 1)')      // Node \"2 * x\"\r\n   *     math.simplify('2 * 3 * x', {x: 4})        // Node \"24\"\r\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\r\n   *     math.simplify(f)                          // Node \"2 * x\"\r\n   *     math.simplify('0.4 * x', {}, {exactFractions: true})  // Node \"x * 2 / 5\"\r\n   *     math.simplify('0.4 * x', {}, {exactFractions: false}) // Node \"0.4 * x\"\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplifyCore, derivative, evaluate, parse, rationalize, resolve\r\n   *\r\n   * @param {Node | string} expr\r\n   *            The expression to be simplified\r\n   * @param {SimplifyRule[]} [rules]\r\n   *            Optional list with custom rules\r\n   * @param {Object} [scope] Optional scope with variables\r\n   * @param {SimplifyOptions} [options] Optional configuration settings\r\n   * @return {Node} Returns the simplified form of `expr`\r\n   */\r\n  typed.addConversion({\r\n    from: 'Object',\r\n    to: 'Map',\r\n    convert: createMap\r\n  });\r\n  var simplify = typed('simplify', {\r\n    Node: _simplify,\r\n    'Node, Map': (expr, scope) => _simplify(expr, false, scope),\r\n    'Node, Map, Object': (expr, scope, options) => _simplify(expr, false, scope, options),\r\n    'Node, Array': _simplify,\r\n    'Node, Array, Map': _simplify,\r\n    'Node, Array, Map, Object': _simplify\r\n  });\r\n  typed.removeConversion({\r\n    from: 'Object',\r\n    to: 'Map',\r\n    convert: createMap\r\n  });\r\n  simplify.defaultContext = defaultContext;\r\n  simplify.realContext = realContext;\r\n  simplify.positiveContext = positiveContext;\r\n  function removeParens(node) {\r\n    return node.transform(function (node, path, parent) {\r\n      return isParenthesisNode(node) ? removeParens(node.content) : node;\r\n    });\r\n  }\r\n\r\n  // All constants that are allowed in rules\r\n  var SUPPORTED_CONSTANTS = {\r\n    true: true,\r\n    false: true,\r\n    e: true,\r\n    i: true,\r\n    Infinity: true,\r\n    LN2: true,\r\n    LN10: true,\r\n    LOG2E: true,\r\n    LOG10E: true,\r\n    NaN: true,\r\n    phi: true,\r\n    pi: true,\r\n    SQRT1_2: true,\r\n    SQRT2: true,\r\n    tau: true\r\n    // null: false,\r\n    // undefined: false,\r\n    // version: false,\r\n  };\r\n\r\n  // Array of strings, used to build the ruleSet.\r\n  // Each l (left side) and r (right side) are parsed by\r\n  // the expression parser into a node tree.\r\n  // Left hand sides are matched to subtrees within the\r\n  // expression to be parsed and replaced with the right\r\n  // hand side.\r\n  // TODO: Add support for constraints on constants (either in the form of a '=' expression or a callback [callback allows things like comparing symbols alphabetically])\r\n  // To evaluate lhs constants for rhs constants, use: { l: 'c1+c2', r: 'c3', evaluate: 'c3 = c1 + c2' }. Multiple assignments are separated by ';' in block format.\r\n  // It is possible to get into an infinite loop with conflicting rules\r\n  simplify.rules = [simplifyCore,\r\n  // { l: 'n+0', r: 'n' },     // simplifyCore\r\n  // { l: 'n^0', r: '1' },     // simplifyCore\r\n  // { l: '0*n', r: '0' },     // simplifyCore\r\n  // { l: 'n/n', r: '1'},      // simplifyCore\r\n  // { l: 'n^1', r: 'n' },     // simplifyCore\r\n  // { l: '+n1', r:'n1' },     // simplifyCore\r\n  // { l: 'n--n1', r:'n+n1' }, // simplifyCore\r\n  {\r\n    l: 'log(e)',\r\n    r: '1'\r\n  },\r\n  // temporary rules\r\n  // Note initially we tend constants to the right because like-term\r\n  // collection prefers the left, and we would rather collect nonconstants\r\n  {\r\n    s: 'n-n1 -> n+-n1',\r\n    // temporarily replace 'subtract' so we can further flatten the 'add' operator\r\n    assuming: {\r\n      subtract: {\r\n        total: true\r\n      }\r\n    }\r\n  }, {\r\n    s: 'n-n -> 0',\r\n    // partial alternative when we can't always subtract\r\n    assuming: {\r\n      subtract: {\r\n        total: false\r\n      }\r\n    }\r\n  }, {\r\n    s: '-(cl*v) -> v * (-cl)',\r\n    // make non-constant terms positive\r\n    assuming: {\r\n      multiply: {\r\n        commutative: true\r\n      },\r\n      subtract: {\r\n        total: true\r\n      }\r\n    }\r\n  }, {\r\n    s: '-(cl*v) -> (-cl) * v',\r\n    // non-commutative version, part 1\r\n    assuming: {\r\n      multiply: {\r\n        commutative: false\r\n      },\r\n      subtract: {\r\n        total: true\r\n      }\r\n    }\r\n  }, {\r\n    s: '-(v*cl) -> v * (-cl)',\r\n    // non-commutative version, part 2\r\n    assuming: {\r\n      multiply: {\r\n        commutative: false\r\n      },\r\n      subtract: {\r\n        total: true\r\n      }\r\n    }\r\n  }, {\r\n    l: '-(n1/n2)',\r\n    r: '-n1/n2'\r\n  }, {\r\n    l: '-v',\r\n    r: 'v * (-1)'\r\n  },\r\n  // finish making non-constant terms positive\r\n  {\r\n    l: '(n1 + n2)*(-1)',\r\n    r: 'n1*(-1) + n2*(-1)',\r\n    repeat: true\r\n  },\r\n  // expand negations to achieve as much sign cancellation as possible\r\n  {\r\n    l: 'n/n1^n2',\r\n    r: 'n*n1^-n2'\r\n  },\r\n  // temporarily replace 'divide' so we can further flatten the 'multiply' operator\r\n  {\r\n    l: 'n/n1',\r\n    r: 'n*n1^-1'\r\n  }, {\r\n    s: '(n1*n2)^n3 -> n1^n3 * n2^n3',\r\n    assuming: {\r\n      multiply: {\r\n        commutative: true\r\n      }\r\n    }\r\n  }, {\r\n    s: '(n1*n2)^(-1) -> n2^(-1) * n1^(-1)',\r\n    assuming: {\r\n      multiply: {\r\n        commutative: false\r\n      }\r\n    }\r\n  },\r\n  // expand nested exponentiation\r\n  {\r\n    s: '(n ^ n1) ^ n2 -> n ^ (n1 * n2)',\r\n    assuming: {\r\n      divide: {\r\n        total: true\r\n      }\r\n    } // 1/(1/n) = n needs 1/n to exist\r\n  },\r\n  // collect like factors; into a sum, only do this for nonconstants\r\n  {\r\n    l: ' vd   * ( vd   * n1 + n2)',\r\n    r: 'vd^2       * n1 +  vd   * n2'\r\n  }, {\r\n    s: ' vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2',\r\n    assuming: {\r\n      divide: {\r\n        total: true\r\n      }\r\n    } // v*1/v = v^(1+-1) needs 1/v\r\n  }, {\r\n    s: 'vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2',\r\n    assuming: {\r\n      divide: {\r\n        total: true\r\n      }\r\n    }\r\n  }, {\r\n    s: 'vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2',\r\n    assuming: {\r\n      divide: {\r\n        total: true\r\n      }\r\n    }\r\n  }, {\r\n    l: 'n*n',\r\n    r: 'n^2'\r\n  }, {\r\n    s: 'n * n^n1 -> n^(n1+1)',\r\n    assuming: {\r\n      divide: {\r\n        total: true\r\n      }\r\n    } // n*1/n = n^(-1+1) needs 1/n\r\n  }, {\r\n    s: 'n^n1 * n^n2 -> n^(n1+n2)',\r\n    assuming: {\r\n      divide: {\r\n        total: true\r\n      }\r\n    } // ditto for n^2*1/n^2\r\n  },\r\n  // Unfortunately, to deal with more complicated cancellations, it\r\n  // becomes necessary to simplify constants twice per pass. It's not\r\n  // terribly expensive compared to matching rules, so this should not\r\n  // pose a performance problem.\r\n  simplifyConstant,\r\n  // First: before collecting like terms\r\n\r\n  // collect like terms\r\n  {\r\n    s: 'n+n -> 2*n',\r\n    assuming: {\r\n      add: {\r\n        total: true\r\n      }\r\n    } // 2 = 1 + 1 needs to exist\r\n  }, {\r\n    l: 'n+-n',\r\n    r: '0'\r\n  }, {\r\n    l: 'vd*n + vd',\r\n    r: 'vd*(n+1)'\r\n  },\r\n  // NOTE: leftmost position is special:\r\n  {\r\n    l: 'n3*n1 + n3*n2',\r\n    r: 'n3*(n1+n2)'\r\n  },\r\n  // All sub-monomials tried there.\r\n  {\r\n    l: 'n3^(-n4)*n1 +   n3  * n2',\r\n    r: 'n3^(-n4)*(n1 + n3^(n4+1) *n2)'\r\n  }, {\r\n    l: 'n3^(-n4)*n1 + n3^n5 * n2',\r\n    r: 'n3^(-n4)*(n1 + n3^(n4+n5)*n2)'\r\n  },\r\n  // noncommutative additional cases (term collection & factoring)\r\n  {\r\n    s: 'n*vd + vd -> (n+1)*vd',\r\n    assuming: {\r\n      multiply: {\r\n        commutative: false\r\n      }\r\n    }\r\n  }, {\r\n    s: 'vd + n*vd -> (1+n)*vd',\r\n    assuming: {\r\n      multiply: {\r\n        commutative: false\r\n      }\r\n    }\r\n  }, {\r\n    s: 'n1*n3 + n2*n3 -> (n1+n2)*n3',\r\n    assuming: {\r\n      multiply: {\r\n        commutative: false\r\n      }\r\n    }\r\n  }, {\r\n    s: 'n^n1 * n -> n^(n1+1)',\r\n    assuming: {\r\n      divide: {\r\n        total: true\r\n      },\r\n      multiply: {\r\n        commutative: false\r\n      }\r\n    }\r\n  }, {\r\n    s: 'n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)',\r\n    assuming: {\r\n      multiply: {\r\n        commutative: false\r\n      }\r\n    }\r\n  }, {\r\n    s: 'n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)',\r\n    assuming: {\r\n      multiply: {\r\n        commutative: false\r\n      }\r\n    }\r\n  }, {\r\n    l: 'n*cd + cd',\r\n    r: '(n+1)*cd'\r\n  }, {\r\n    s: 'cd*n + cd -> cd*(n+1)',\r\n    assuming: {\r\n      multiply: {\r\n        commutative: false\r\n      }\r\n    }\r\n  }, {\r\n    s: 'cd + cd*n -> cd*(1+n)',\r\n    assuming: {\r\n      multiply: {\r\n        commutative: false\r\n      }\r\n    }\r\n  }, simplifyConstant,\r\n  // Second: before returning expressions to \"standard form\"\r\n\r\n  // make factors positive (and undo 'make non-constant terms positive')\r\n  {\r\n    s: '(-n)*n1 -> -(n*n1)',\r\n    assuming: {\r\n      subtract: {\r\n        total: true\r\n      }\r\n    }\r\n  }, {\r\n    s: 'n1*(-n) -> -(n1*n)',\r\n    // in case * non-commutative\r\n    assuming: {\r\n      subtract: {\r\n        total: true\r\n      },\r\n      multiply: {\r\n        commutative: false\r\n      }\r\n    }\r\n  },\r\n  // final ordering of constants\r\n  {\r\n    s: 'ce+ve -> ve+ce',\r\n    assuming: {\r\n      add: {\r\n        commutative: true\r\n      }\r\n    },\r\n    imposeContext: {\r\n      add: {\r\n        commutative: false\r\n      }\r\n    }\r\n  }, {\r\n    s: 'vd*cd -> cd*vd',\r\n    assuming: {\r\n      multiply: {\r\n        commutative: true\r\n      }\r\n    },\r\n    imposeContext: {\r\n      multiply: {\r\n        commutative: false\r\n      }\r\n    }\r\n  },\r\n  // undo temporary rules\r\n  // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant\r\n  {\r\n    l: 'n+-n1',\r\n    r: 'n-n1'\r\n  },\r\n  // undo replace 'subtract'\r\n  {\r\n    s: 'n*(n1^-1) -> n/n1',\r\n    // undo replace 'divide'; for * commutative\r\n    assuming: {\r\n      multiply: {\r\n        commutative: true\r\n      }\r\n    } // o.w. / not conventional\r\n  }, {\r\n    s: 'n*n1^-n2 -> n/n1^n2',\r\n    assuming: {\r\n      multiply: {\r\n        commutative: true\r\n      }\r\n    } // o.w. / not conventional\r\n  }, {\r\n    s: 'n^-1 -> 1/n',\r\n    assuming: {\r\n      multiply: {\r\n        commutative: true\r\n      }\r\n    } // o.w. / not conventional\r\n  }, {\r\n    l: 'n^1',\r\n    r: 'n'\r\n  },\r\n  // can be produced by power cancellation\r\n  {\r\n    s: 'n*(n1/n2) -> (n*n1)/n2',\r\n    // '*' before '/'\r\n    assuming: {\r\n      multiply: {\r\n        associative: true\r\n      }\r\n    }\r\n  }, {\r\n    s: 'n-(n1+n2) -> n-n1-n2',\r\n    // '-' before '+'\r\n    assuming: {\r\n      addition: {\r\n        associative: true,\r\n        commutative: true\r\n      }\r\n    }\r\n  },\r\n  // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },\r\n  // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },\r\n\r\n  // simplifyConstant can leave an extra factor of 1, which can always\r\n  // be eliminated, since the identity always commutes\r\n  {\r\n    l: '1*n',\r\n    r: 'n',\r\n    imposeContext: {\r\n      multiply: {\r\n        commutative: true\r\n      }\r\n    }\r\n  }, {\r\n    s: 'n1/(n2/n3) -> (n1*n3)/n2',\r\n    assuming: {\r\n      multiply: {\r\n        associative: true\r\n      }\r\n    }\r\n  }, {\r\n    l: 'n1/(-n2)',\r\n    r: '-n1/n2'\r\n  }];\r\n\r\n  /**\r\n   * Takes any rule object as allowed by the specification in simplify\r\n   * and puts it in a standard form used by applyRule\r\n   */\r\n  function _canonicalizeRule(ruleObject, context) {\r\n    var newRule = {};\r\n    if (ruleObject.s) {\r\n      var lr = ruleObject.s.split('->');\r\n      if (lr.length === 2) {\r\n        newRule.l = lr[0];\r\n        newRule.r = lr[1];\r\n      } else {\r\n        throw SyntaxError('Could not parse rule: ' + ruleObject.s);\r\n      }\r\n    } else {\r\n      newRule.l = ruleObject.l;\r\n      newRule.r = ruleObject.r;\r\n    }\r\n    newRule.l = removeParens(parse(newRule.l));\r\n    newRule.r = removeParens(parse(newRule.r));\r\n    for (var prop of ['imposeContext', 'repeat', 'assuming']) {\r\n      if (prop in ruleObject) {\r\n        newRule[prop] = ruleObject[prop];\r\n      }\r\n    }\r\n    if (ruleObject.evaluate) {\r\n      newRule.evaluate = parse(ruleObject.evaluate);\r\n    }\r\n    if (isAssociative(newRule.l, context)) {\r\n      var nonCommutative = !isCommutative(newRule.l, context);\r\n      var leftExpandsym;\r\n      // Gen. the LHS placeholder used in this NC-context specific expansion rules\r\n      if (nonCommutative) leftExpandsym = _getExpandPlaceholderSymbol();\r\n      var makeNode = createMakeNodeFunction(newRule.l);\r\n      var expandsym = _getExpandPlaceholderSymbol();\r\n      newRule.expanded = {};\r\n      newRule.expanded.l = makeNode([newRule.l, expandsym]);\r\n      // Push the expandsym into the deepest possible branch.\r\n      // This helps to match the newRule against nodes returned from getSplits() later on.\r\n      flatten(newRule.expanded.l, context);\r\n      unflattenr(newRule.expanded.l, context);\r\n      newRule.expanded.r = makeNode([newRule.r, expandsym]);\r\n\r\n      // In and for a non-commutative context, attempting with yet additional expansion rules makes\r\n      // way for more matches cases of multi-arg expressions; such that associative rules (such as\r\n      // 'n*n -> n^2') can be applied to exprs. such as 'a * b * b' and 'a * b * b * a'.\r\n      if (nonCommutative) {\r\n        // 'Non-commutative' 1: LHS (placeholder) only\r\n        newRule.expandedNC1 = {};\r\n        newRule.expandedNC1.l = makeNode([leftExpandsym, newRule.l]);\r\n        newRule.expandedNC1.r = makeNode([leftExpandsym, newRule.r]);\r\n        // 'Non-commutative' 2: farmost LHS and RHS placeholders\r\n        newRule.expandedNC2 = {};\r\n        newRule.expandedNC2.l = makeNode([leftExpandsym, newRule.expanded.l]);\r\n        newRule.expandedNC2.r = makeNode([leftExpandsym, newRule.expanded.r]);\r\n      }\r\n    }\r\n    return newRule;\r\n  }\r\n\r\n  /**\r\n   * Parse the string array of rules into nodes\r\n   *\r\n   * Example syntax for rules:\r\n   *\r\n   * Position constants to the left in a product:\r\n   * { l: 'n1 * c1', r: 'c1 * n1' }\r\n   * n1 is any Node, and c1 is a ConstantNode.\r\n   *\r\n   * Apply difference of squares formula:\r\n   * { l: '(n1 - n2) * (n1 + n2)', r: 'n1^2 - n2^2' }\r\n   * n1, n2 mean any Node.\r\n   *\r\n   * Short hand notation:\r\n   * 'n1 * c1 -> c1 * n1'\r\n   */\r\n  function _buildRules(rules, context) {\r\n    // Array of rules to be used to simplify expressions\r\n    var ruleSet = [];\r\n    for (var i = 0; i < rules.length; i++) {\r\n      var rule = rules[i];\r\n      var newRule = void 0;\r\n      var ruleType = typeof rule;\r\n      switch (ruleType) {\r\n        case 'string':\r\n          rule = {\r\n            s: rule\r\n          };\r\n        /* falls through */\r\n        case 'object':\r\n          newRule = _canonicalizeRule(rule, context);\r\n          break;\r\n        case 'function':\r\n          newRule = rule;\r\n          break;\r\n        default:\r\n          throw TypeError('Unsupported type of rule: ' + ruleType);\r\n      }\r\n      // console.log('Adding rule: ' + rules[i])\r\n      // console.log(newRule)\r\n      ruleSet.push(newRule);\r\n    }\r\n    return ruleSet;\r\n  }\r\n  var _lastsym = 0;\r\n  function _getExpandPlaceholderSymbol() {\r\n    return new SymbolNode('_p' + _lastsym++);\r\n  }\r\n  function _simplify(expr, rules) {\r\n    var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : createEmptyMap();\r\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\r\n    var debug = options.consoleDebug;\r\n    rules = _buildRules(rules || simplify.rules, options.context);\r\n    var res = resolve(expr, scope);\r\n    res = removeParens(res);\r\n    var visited = {};\r\n    var str = res.toString({\r\n      parenthesis: 'all'\r\n    });\r\n    while (!visited[str]) {\r\n      visited[str] = true;\r\n      _lastsym = 0; // counter for placeholder symbols\r\n      var laststr = str;\r\n      if (debug) console.log('Working on: ', str);\r\n      for (var i = 0; i < rules.length; i++) {\r\n        var rulestr = '';\r\n        if (typeof rules[i] === 'function') {\r\n          res = rules[i](res, options);\r\n          if (debug) rulestr = rules[i].name;\r\n        } else {\r\n          flatten(res, options.context);\r\n          res = applyRule(res, rules[i], options.context);\r\n          if (debug) {\r\n            rulestr = \"\".concat(rules[i].l.toString(), \" -> \").concat(rules[i].r.toString());\r\n          }\r\n        }\r\n        if (debug) {\r\n          var newstr = res.toString({\r\n            parenthesis: 'all'\r\n          });\r\n          if (newstr !== laststr) {\r\n            console.log('Applying', rulestr, 'produced', newstr);\r\n            laststr = newstr;\r\n          }\r\n        }\r\n        /* Use left-heavy binary tree internally,\r\n         * since custom rule functions may expect it\r\n         */\r\n        unflattenl(res, options.context);\r\n      }\r\n      str = res.toString({\r\n        parenthesis: 'all'\r\n      });\r\n    }\r\n    return res;\r\n  }\r\n  function mapRule(nodes, rule, context) {\r\n    var resNodes = nodes;\r\n    if (nodes) {\r\n      for (var i = 0; i < nodes.length; ++i) {\r\n        var newNode = applyRule(nodes[i], rule, context);\r\n        if (newNode !== nodes[i]) {\r\n          if (resNodes === nodes) {\r\n            resNodes = nodes.slice();\r\n          }\r\n          resNodes[i] = newNode;\r\n        }\r\n      }\r\n    }\r\n    return resNodes;\r\n  }\r\n\r\n  /**\r\n   * Returns a simplfied form of node, or the original node if no simplification was possible.\r\n   *\r\n   * @param  {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\r\n   * @param  {Object | Function} rule\r\n   * @param  {Object} context -- information about assumed properties of operators\r\n   * @return {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} The simplified form of `expr`, or the original node if no simplification was possible.\r\n   */\r\n  function applyRule(node, rule, context) {\r\n    //    console.log('Entering applyRule(\"', rule.l.toString({parenthesis:'all'}), '->', rule.r.toString({parenthesis:'all'}), '\",', node.toString({parenthesis:'all'}),')')\r\n\r\n    // check that the assumptions for this rule are satisfied by the current\r\n    // context:\r\n    if (rule.assuming) {\r\n      for (var symbol in rule.assuming) {\r\n        for (var property in rule.assuming[symbol]) {\r\n          if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {\r\n            return node;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    var mergedContext = mergeContext(rule.imposeContext, context);\r\n\r\n    // Do not clone node unless we find a match\r\n    var res = node;\r\n\r\n    // First replace our child nodes with their simplified versions\r\n    // If a child could not be simplified, applying the rule to it\r\n    // will have no effect since the node is returned unchanged\r\n    if (res instanceof OperatorNode || res instanceof FunctionNode) {\r\n      var newArgs = mapRule(res.args, rule, context);\r\n      if (newArgs !== res.args) {\r\n        res = res.clone();\r\n        res.args = newArgs;\r\n      }\r\n    } else if (res instanceof ParenthesisNode) {\r\n      if (res.content) {\r\n        var newContent = applyRule(res.content, rule, context);\r\n        if (newContent !== res.content) {\r\n          res = new ParenthesisNode(newContent);\r\n        }\r\n      }\r\n    } else if (res instanceof ArrayNode) {\r\n      var newItems = mapRule(res.items, rule, context);\r\n      if (newItems !== res.items) {\r\n        res = new ArrayNode(newItems);\r\n      }\r\n    } else if (res instanceof AccessorNode) {\r\n      var newObj = res.object;\r\n      if (res.object) {\r\n        newObj = applyRule(res.object, rule, context);\r\n      }\r\n      var newIndex = res.index;\r\n      if (res.index) {\r\n        newIndex = applyRule(res.index, rule, context);\r\n      }\r\n      if (newObj !== res.object || newIndex !== res.index) {\r\n        res = new AccessorNode(newObj, newIndex);\r\n      }\r\n    } else if (res instanceof IndexNode) {\r\n      var newDims = mapRule(res.dimensions, rule, context);\r\n      if (newDims !== res.dimensions) {\r\n        res = new IndexNode(newDims);\r\n      }\r\n    } else if (res instanceof ObjectNode) {\r\n      var changed = false;\r\n      var newProps = {};\r\n      for (var prop in res.properties) {\r\n        newProps[prop] = applyRule(res.properties[prop], rule, context);\r\n        if (newProps[prop] !== res.properties[prop]) {\r\n          changed = true;\r\n        }\r\n      }\r\n      if (changed) {\r\n        res = new ObjectNode(newProps);\r\n      }\r\n    }\r\n\r\n    // Try to match a rule against this node\r\n    var repl = rule.r;\r\n    var matches = _ruleMatch(rule.l, res, mergedContext)[0];\r\n\r\n    // If the rule is associative operator, we can try matching it while allowing additional terms.\r\n    // This allows us to match rules like 'n+n' to the expression '(1+x)+x' or even 'x+1+x' if the operator is commutative.\r\n    if (!matches && rule.expanded) {\r\n      repl = rule.expanded.r;\r\n      matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];\r\n    }\r\n    // Additional, non-commutative context expansion-rules\r\n    if (!matches && rule.expandedNC1) {\r\n      repl = rule.expandedNC1.r;\r\n      matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];\r\n      if (!matches) {\r\n        // Existence of NC1 implies NC2\r\n        repl = rule.expandedNC2.r;\r\n        matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];\r\n      }\r\n    }\r\n    if (matches) {\r\n      // const before = res.toString({parenthesis: 'all'})\r\n\r\n      // Create a new node by cloning the rhs of the matched rule\r\n      // we keep any implicit multiplication state if relevant\r\n      var implicit = res.implicit;\r\n      res = repl.clone();\r\n      if (implicit && 'implicit' in repl) {\r\n        res.implicit = true;\r\n      }\r\n\r\n      // Replace placeholders with their respective nodes without traversing deeper into the replaced nodes\r\n      res = res.transform(function (node) {\r\n        if (node.isSymbolNode && hasOwnProperty(matches.placeholders, node.name)) {\r\n          return matches.placeholders[node.name].clone();\r\n        } else {\r\n          return node;\r\n        }\r\n      });\r\n\r\n      // const after = res.toString({parenthesis: 'all'})\r\n      // console.log('Simplified ' + before + ' to ' + after)\r\n    }\r\n\r\n    if (rule.repeat && res !== node) {\r\n      res = applyRule(res, rule, context);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Get (binary) combinations of a flattened binary node\r\n   * e.g. +(node1, node2, node3) -> [\r\n   *        +(node1,  +(node2, node3)),\r\n   *        +(node2,  +(node1, node3)),\r\n   *        +(node3,  +(node1, node2))]\r\n   *\r\n   */\r\n  function getSplits(node, context) {\r\n    var res = [];\r\n    var right, rightArgs;\r\n    var makeNode = createMakeNodeFunction(node);\r\n    if (isCommutative(node, context)) {\r\n      for (var i = 0; i < node.args.length; i++) {\r\n        rightArgs = node.args.slice(0);\r\n        rightArgs.splice(i, 1);\r\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\r\n        res.push(makeNode([node.args[i], right]));\r\n      }\r\n    } else {\r\n      // Keep order, but try all parenthesizations\r\n      for (var _i = 1; _i < node.args.length; _i++) {\r\n        var left = node.args[0];\r\n        if (_i > 1) {\r\n          left = makeNode(node.args.slice(0, _i));\r\n        }\r\n        rightArgs = node.args.slice(_i);\r\n        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);\r\n        res.push(makeNode([left, right]));\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Returns the set union of two match-placeholders or null if there is a conflict.\r\n   */\r\n  function mergeMatch(match1, match2) {\r\n    var res = {\r\n      placeholders: {}\r\n    };\r\n\r\n    // Some matches may not have placeholders; this is OK\r\n    if (!match1.placeholders && !match2.placeholders) {\r\n      return res;\r\n    } else if (!match1.placeholders) {\r\n      return match2;\r\n    } else if (!match2.placeholders) {\r\n      return match1;\r\n    }\r\n\r\n    // Placeholders with the same key must match exactly\r\n    for (var key in match1.placeholders) {\r\n      if (hasOwnProperty(match1.placeholders, key)) {\r\n        res.placeholders[key] = match1.placeholders[key];\r\n        if (hasOwnProperty(match2.placeholders, key)) {\r\n          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {\r\n            return null;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    for (var _key in match2.placeholders) {\r\n      if (hasOwnProperty(match2.placeholders, _key)) {\r\n        res.placeholders[_key] = match2.placeholders[_key];\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Combine two lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\r\n   * Each list represents matches found in one child of a node.\r\n   */\r\n  function combineChildMatches(list1, list2) {\r\n    var res = [];\r\n    if (list1.length === 0 || list2.length === 0) {\r\n      return res;\r\n    }\r\n    var merged;\r\n    for (var i1 = 0; i1 < list1.length; i1++) {\r\n      for (var i2 = 0; i2 < list2.length; i2++) {\r\n        merged = mergeMatch(list1[i1], list2[i2]);\r\n        if (merged) {\r\n          res.push(merged);\r\n        }\r\n      }\r\n    }\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Combine multiple lists of matches by applying mergeMatch to the cartesian product of two lists of matches.\r\n   * Each list represents matches found in one child of a node.\r\n   * Returns a list of unique matches.\r\n   */\r\n  function mergeChildMatches(childMatches) {\r\n    if (childMatches.length === 0) {\r\n      return childMatches;\r\n    }\r\n    var sets = childMatches.reduce(combineChildMatches);\r\n    var uniqueSets = [];\r\n    var unique = {};\r\n    for (var i = 0; i < sets.length; i++) {\r\n      var s = JSON.stringify(sets[i]);\r\n      if (!unique[s]) {\r\n        unique[s] = true;\r\n        uniqueSets.push(sets[i]);\r\n      }\r\n    }\r\n    return uniqueSets;\r\n  }\r\n\r\n  /**\r\n   * Determines whether node matches rule.\r\n   *\r\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} rule\r\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} node\r\n   * @param {Object} context -- provides assumed properties of operators\r\n   * @param {Boolean} isSplit -- whether we are in process of splitting an\r\n   *                    n-ary operator node into possible binary combinations.\r\n   *                    Defaults to false.\r\n   * @return {Object} Information about the match, if it exists.\r\n   */\r\n  function _ruleMatch(rule, node, context, isSplit) {\r\n    //    console.log('Entering _ruleMatch(' + JSON.stringify(rule) + ', ' + JSON.stringify(node) + ')')\r\n    //    console.log('rule = ' + rule)\r\n    //    console.log('node = ' + node)\r\n\r\n    //    console.log('Entering _ruleMatch(', rule.toString({parenthesis:'all'}), ', ', node.toString({parenthesis:'all'}), ', ', context, ')')\r\n    var res = [{\r\n      placeholders: {}\r\n    }];\r\n    if (rule instanceof OperatorNode && node instanceof OperatorNode || rule instanceof FunctionNode && node instanceof FunctionNode) {\r\n      // If the rule is an OperatorNode or a FunctionNode, then node must match exactly\r\n      if (rule instanceof OperatorNode) {\r\n        if (rule.op !== node.op || rule.fn !== node.fn) {\r\n          return [];\r\n        }\r\n      } else if (rule instanceof FunctionNode) {\r\n        if (rule.name !== node.name) {\r\n          return [];\r\n        }\r\n      }\r\n\r\n      // rule and node match. Search the children of rule and node.\r\n      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {\r\n        // Expect non-associative operators to match exactly,\r\n        // except in any order if operator is commutative\r\n        var childMatches = [];\r\n        for (var i = 0; i < rule.args.length; i++) {\r\n          var childMatch = _ruleMatch(rule.args[i], node.args[i], context);\r\n          if (childMatch.length === 0) {\r\n            // Child did not match, so stop searching immediately\r\n            break;\r\n          }\r\n          // The child matched, so add the information returned from the child to our result\r\n          childMatches.push(childMatch);\r\n        }\r\n        if (childMatches.length !== rule.args.length) {\r\n          if (!isCommutative(node, context) ||\r\n          // exact match in order needed\r\n          rule.args.length === 1) {\r\n            // nothing to commute\r\n            return [];\r\n          }\r\n          if (rule.args.length > 2) {\r\n            /* Need to generate all permutations and try them.\r\n             * It's a bit complicated, and unlikely to come up since there\r\n             * are very few ternary or higher operators. So punt for now.\r\n             */\r\n            throw new Error('permuting >2 commutative non-associative rule arguments not yet implemented');\r\n          }\r\n          /* Exactly two arguments, try them reversed */\r\n          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);\r\n          if (leftMatch.length === 0) {\r\n            return [];\r\n          }\r\n          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);\r\n          if (rightMatch.length === 0) {\r\n            return [];\r\n          }\r\n          childMatches = [leftMatch, rightMatch];\r\n        }\r\n        res = mergeChildMatches(childMatches);\r\n      } else if (node.args.length >= 2 && rule.args.length === 2) {\r\n        // node is flattened, rule is not\r\n        // Associative operators/functions can be split in different ways so we check if the rule\r\n        // matches for each of them and return their union.\r\n        var splits = getSplits(node, context);\r\n        var splitMatches = [];\r\n        for (var _i2 = 0; _i2 < splits.length; _i2++) {\r\n          var matchSet = _ruleMatch(rule, splits[_i2], context, true); // recursing at the same tree depth here\r\n          splitMatches = splitMatches.concat(matchSet);\r\n        }\r\n        return splitMatches;\r\n      } else if (rule.args.length > 2) {\r\n        throw Error('Unexpected non-binary associative function: ' + rule.toString());\r\n      } else {\r\n        // Incorrect number of arguments in rule and node, so no match\r\n        return [];\r\n      }\r\n    } else if (rule instanceof SymbolNode) {\r\n      // If the rule is a SymbolNode, then it carries a special meaning\r\n      // according to the first one or two characters of the symbol node name.\r\n      // These meanings are expalined in the documentation for simplify()\r\n      if (rule.name.length === 0) {\r\n        throw new Error('Symbol in rule has 0 length...!?');\r\n      }\r\n      if (SUPPORTED_CONSTANTS[rule.name]) {\r\n        // built-in constant must match exactly\r\n        if (rule.name !== node.name) {\r\n          return [];\r\n        }\r\n      } else {\r\n        // wildcards are composed of up to two alphabetic or underscore characters\r\n        switch (rule.name[1] >= 'a' && rule.name[1] <= 'z' ? rule.name.substring(0, 2) : rule.name[0]) {\r\n          case 'n':\r\n          case '_p':\r\n            // rule matches _anything_, so assign this node to the rule.name placeholder\r\n            // Assign node to the rule.name placeholder.\r\n            // Our parent will check for matches among placeholders.\r\n            res[0].placeholders[rule.name] = node;\r\n            break;\r\n          case 'c':\r\n          case 'cl':\r\n            // rule matches a ConstantNode\r\n            if (isConstantNode(node)) {\r\n              res[0].placeholders[rule.name] = node;\r\n            } else {\r\n              // mis-match: rule does not encompass current node\r\n              return [];\r\n            }\r\n            break;\r\n          case 'v':\r\n            // rule matches anything other than a ConstantNode\r\n            if (!isConstantNode(node)) {\r\n              res[0].placeholders[rule.name] = node;\r\n            } else {\r\n              // mis-match: rule does not encompass current node\r\n              return [];\r\n            }\r\n            break;\r\n          case 'vl':\r\n            // rule matches VariableNode\r\n            if (isVariableNode(node)) {\r\n              res[0].placeholders[rule.name] = node;\r\n            } else {\r\n              // mis-match: rule does not encompass current node\r\n              return [];\r\n            }\r\n            break;\r\n          case 'cd':\r\n            // rule matches a ConstantNode or unaryMinus-wrapped ConstantNode\r\n            if (isNumericNode(node)) {\r\n              res[0].placeholders[rule.name] = node;\r\n            } else {\r\n              // mis-match: rule does not encompass current node\r\n              return [];\r\n            }\r\n            break;\r\n          case 'vd':\r\n            // rule matches anything other than a ConstantNode or unaryMinus-wrapped ConstantNode\r\n            if (!isNumericNode(node)) {\r\n              res[0].placeholders[rule.name] = node;\r\n            } else {\r\n              // mis-match: rule does not encompass current node\r\n              return [];\r\n            }\r\n            break;\r\n          case 'ce':\r\n            // rule matches expressions that have a constant value\r\n            if (isConstantExpression(node)) {\r\n              res[0].placeholders[rule.name] = node;\r\n            } else {\r\n              // mis-match: rule does not encompass current node\r\n              return [];\r\n            }\r\n            break;\r\n          case 've':\r\n            // rule matches expressions that do not have a constant value\r\n            if (!isConstantExpression(node)) {\r\n              res[0].placeholders[rule.name] = node;\r\n            } else {\r\n              // mis-match: rule does not encompass current node\r\n              return [];\r\n            }\r\n            break;\r\n          default:\r\n            throw new Error('Invalid symbol in rule: ' + rule.name);\r\n        }\r\n      }\r\n    } else if (rule instanceof ConstantNode) {\r\n      // Literal constant must match exactly\r\n      if (!equal(rule.value, node.value)) {\r\n        return [];\r\n      }\r\n    } else {\r\n      // Some other node was encountered which we aren't prepared for, so no match\r\n      return [];\r\n    }\r\n\r\n    // It's a match!\r\n\r\n    // console.log('_ruleMatch(' + rule.toString() + ', ' + node.toString() + ') found a match')\r\n    return res;\r\n  }\r\n\r\n  /**\r\n   * Determines whether p and q (and all their children nodes) are identical.\r\n   *\r\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} p\r\n   * @param {ConstantNode | SymbolNode | ParenthesisNode | FunctionNode | OperatorNode} q\r\n   * @return {Object} Information about the match, if it exists.\r\n   */\r\n  function _exactMatch(p, q) {\r\n    if (p instanceof ConstantNode && q instanceof ConstantNode) {\r\n      if (!equal(p.value, q.value)) {\r\n        return false;\r\n      }\r\n    } else if (p instanceof SymbolNode && q instanceof SymbolNode) {\r\n      if (p.name !== q.name) {\r\n        return false;\r\n      }\r\n    } else if (p instanceof OperatorNode && q instanceof OperatorNode || p instanceof FunctionNode && q instanceof FunctionNode) {\r\n      if (p instanceof OperatorNode) {\r\n        if (p.op !== q.op || p.fn !== q.fn) {\r\n          return false;\r\n        }\r\n      } else if (p instanceof FunctionNode) {\r\n        if (p.name !== q.name) {\r\n          return false;\r\n        }\r\n      }\r\n      if (p.args.length !== q.args.length) {\r\n        return false;\r\n      }\r\n      for (var i = 0; i < p.args.length; i++) {\r\n        if (!_exactMatch(p.args[i], q.args[i])) {\r\n          return false;\r\n        }\r\n      }\r\n    } else {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n  return simplify;\r\n});"]},"metadata":{},"sourceType":"module"}