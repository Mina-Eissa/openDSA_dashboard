{"ast":null,"code":"import { factory } from '../../../utils/factory.js';\nimport { createSolveValidation } from './utils/solveValidation.js';\nvar name = 'lsolve';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nexport var createLsolve = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divideScalar,\n    multiplyScalar,\n    subtract,\n    equalScalar,\n    DenseMatrix\n  } = _ref;\n  var solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n  /**\r\n   * Finds one solution of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix. Throws an error if there's no solution.\r\n   *\r\n   * `L * x = b`\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lsolve(L, b)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    const a = [[-2, 3], [2, 1]]\r\n   *    const b = [11, 9]\r\n   *    const x = lsolve(a, b)  // [[-5.5], [20]]\r\n   *\r\n   * See also:\r\n   *\r\n   *    lsolveAll, lup, slu, usolve, lusolve\r\n   *\r\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\r\n   * @param {Matrix, Array} b       A column vector with the b values\r\n   *\r\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\r\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      var m = matrix(a);\n\n      var r = _denseForwardSubstitution(m, b);\n\n      return r.valueOf();\n    }\n  });\n\n  function _denseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1]; // result\n\n    var x = [];\n    var mdata = m._data; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      var bj = bdata[j][0] || 0;\n      var xj = void 0;\n\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n        var vjj = mdata[j][j];\n\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n\n        xj = divideScalar(bj, vjj); // loop rows\n\n        for (var i = j + 1; i < rows; i++) {\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\n        }\n      } else {\n        // degenerate row, we can choose any value\n        xj = 0;\n      }\n\n      x[j] = [xj];\n    }\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n\n  function _sparseForwardSubstitution(m, b) {\n    // validate matrix and vector, return copy of column vector b\n    b = solveValidation(m, b, true);\n    var bdata = b._data;\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // result\n\n    var x = []; // loop columns\n\n    for (var j = 0; j < columns; j++) {\n      var bj = bdata[j][0] || 0;\n\n      if (!equalScalar(bj, 0)) {\n        // non-degenerate row, find solution\n        var vjj = 0; // matrix values & indices (column j)\n\n        var jValues = [];\n        var jIndices = []; // first and last index in the column\n\n        var firstIndex = ptr[j];\n        var lastIndex = ptr[j + 1]; // values in column, find value at [j, j]\n\n        for (var k = firstIndex; k < lastIndex; k++) {\n          var i = index[k]; // check row (rows are not sorted!)\n\n          if (i === j) {\n            vjj = values[k];\n          } else if (i > j) {\n            // store lower triangular\n            jValues.push(values[k]);\n            jIndices.push(i);\n          }\n        } // at this point we must have a value in vjj\n\n\n        if (equalScalar(vjj, 0)) {\n          throw new Error('Linear system cannot be solved since matrix is singular');\n        }\n\n        var xj = divideScalar(bj, vjj);\n\n        for (var _k = 0, l = jIndices.length; _k < l; _k++) {\n          var _i = jIndices[_k];\n          bdata[_i] = [subtract(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];\n        }\n\n        x[j] = [xj];\n      } else {\n        // degenerate row, we can choose any value\n        x[j] = [0];\n      }\n    }\n\n    return new DenseMatrix({\n      data: x,\n      size: [rows, 1]\n    });\n  }\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js"],"names":["factory","createSolveValidation","name","dependencies","createLsolve","_ref","typed","matrix","divideScalar","multiplyScalar","subtract","equalScalar","DenseMatrix","solveValidation","SparseMatrixArrayMatrix","m","b","_sparseForwardSubstitution","DenseMatrixArrayMatrix","_denseForwardSubstitution","ArrayArrayMatrix","a","r","valueOf","bdata","_data","rows","_size","columns","x","mdata","j","bj","xj","vjj","Error","i","data","size","values","_values","index","_index","ptr","_ptr","jValues","jIndices","firstIndex","lastIndex","k","push","_k","l","length","_i"],"mappings":"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","sourcesContent":["import { factory } from '../../../utils/factory.js';\r\nimport { createSolveValidation } from './utils/solveValidation.js';\r\nvar name = 'lsolve';\r\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\r\nexport var createLsolve = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    divideScalar,\r\n    multiplyScalar,\r\n    subtract,\r\n    equalScalar,\r\n    DenseMatrix\r\n  } = _ref;\r\n  var solveValidation = createSolveValidation({\r\n    DenseMatrix\r\n  });\r\n\r\n  /**\r\n   * Finds one solution of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix. Throws an error if there's no solution.\r\n   *\r\n   * `L * x = b`\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lsolve(L, b)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    const a = [[-2, 3], [2, 1]]\r\n   *    const b = [11, 9]\r\n   *    const x = lsolve(a, b)  // [[-5.5], [20]]\r\n   *\r\n   * See also:\r\n   *\r\n   *    lsolveAll, lup, slu, usolve, lusolve\r\n   *\r\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\r\n   * @param {Matrix, Array} b       A column vector with the b values\r\n   *\r\n   * @return {DenseMatrix | Array}  A column vector with the linear system solution (x)\r\n   */\r\n  return typed(name, {\r\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\r\n      return _sparseForwardSubstitution(m, b);\r\n    },\r\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\r\n      return _denseForwardSubstitution(m, b);\r\n    },\r\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\r\n      var m = matrix(a);\r\n      var r = _denseForwardSubstitution(m, b);\r\n      return r.valueOf();\r\n    }\r\n  });\r\n  function _denseForwardSubstitution(m, b) {\r\n    // validate matrix and vector, return copy of column vector b\r\n    b = solveValidation(m, b, true);\r\n    var bdata = b._data;\r\n    var rows = m._size[0];\r\n    var columns = m._size[1];\r\n\r\n    // result\r\n    var x = [];\r\n    var mdata = m._data;\r\n\r\n    // loop columns\r\n    for (var j = 0; j < columns; j++) {\r\n      var bj = bdata[j][0] || 0;\r\n      var xj = void 0;\r\n      if (!equalScalar(bj, 0)) {\r\n        // non-degenerate row, find solution\r\n\r\n        var vjj = mdata[j][j];\r\n        if (equalScalar(vjj, 0)) {\r\n          throw new Error('Linear system cannot be solved since matrix is singular');\r\n        }\r\n        xj = divideScalar(bj, vjj);\r\n\r\n        // loop rows\r\n        for (var i = j + 1; i < rows; i++) {\r\n          bdata[i] = [subtract(bdata[i][0] || 0, multiplyScalar(xj, mdata[i][j]))];\r\n        }\r\n      } else {\r\n        // degenerate row, we can choose any value\r\n        xj = 0;\r\n      }\r\n      x[j] = [xj];\r\n    }\r\n    return new DenseMatrix({\r\n      data: x,\r\n      size: [rows, 1]\r\n    });\r\n  }\r\n  function _sparseForwardSubstitution(m, b) {\r\n    // validate matrix and vector, return copy of column vector b\r\n    b = solveValidation(m, b, true);\r\n    var bdata = b._data;\r\n    var rows = m._size[0];\r\n    var columns = m._size[1];\r\n    var values = m._values;\r\n    var index = m._index;\r\n    var ptr = m._ptr;\r\n\r\n    // result\r\n    var x = [];\r\n\r\n    // loop columns\r\n    for (var j = 0; j < columns; j++) {\r\n      var bj = bdata[j][0] || 0;\r\n      if (!equalScalar(bj, 0)) {\r\n        // non-degenerate row, find solution\r\n\r\n        var vjj = 0;\r\n        // matrix values & indices (column j)\r\n        var jValues = [];\r\n        var jIndices = [];\r\n\r\n        // first and last index in the column\r\n        var firstIndex = ptr[j];\r\n        var lastIndex = ptr[j + 1];\r\n\r\n        // values in column, find value at [j, j]\r\n        for (var k = firstIndex; k < lastIndex; k++) {\r\n          var i = index[k];\r\n\r\n          // check row (rows are not sorted!)\r\n          if (i === j) {\r\n            vjj = values[k];\r\n          } else if (i > j) {\r\n            // store lower triangular\r\n            jValues.push(values[k]);\r\n            jIndices.push(i);\r\n          }\r\n        }\r\n\r\n        // at this point we must have a value in vjj\r\n        if (equalScalar(vjj, 0)) {\r\n          throw new Error('Linear system cannot be solved since matrix is singular');\r\n        }\r\n        var xj = divideScalar(bj, vjj);\r\n        for (var _k = 0, l = jIndices.length; _k < l; _k++) {\r\n          var _i = jIndices[_k];\r\n          bdata[_i] = [subtract(bdata[_i][0] || 0, multiplyScalar(xj, jValues[_k]))];\r\n        }\r\n        x[j] = [xj];\r\n      } else {\r\n        // degenerate row, we can choose any value\r\n        x[j] = [0];\r\n      }\r\n    }\r\n    return new DenseMatrix({\r\n      data: x,\r\n      size: [rows, 1]\r\n    });\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}