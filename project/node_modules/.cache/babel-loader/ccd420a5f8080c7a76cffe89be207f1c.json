{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'matrixFromColumns';\nvar dependencies = ['typed', 'matrix', 'flatten', 'size'];\nexport var createMatrixFromColumns = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    flatten,\n    size\n  } = _ref;\n  /**\r\n   * Create a dense matrix from vectors as individual columns.\r\n   * If you pass row vectors, they will be transposed (but not conjugated!)\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.matrixFromColumns(...arr)\r\n   *    math.matrixFromColumns(col1, col2)\r\n   *    math.matrixFromColumns(col1, col2, col3)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.matrixFromColumns([1, 2, 3], [[4],[5],[6]])\r\n   *    math.matrixFromColumns(...vectors)\r\n   *\r\n   * See also:\r\n   *\r\n   *    matrix, matrixFromRows, matrixFromFunction, zeros\r\n   *\r\n   * @param {... Array | Matrix} cols Multiple columns\r\n   * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned\r\n   */\n\n  return typed(name, {\n    '...Array': function Array(arr) {\n      return _createArray(arr);\n    },\n    '...Matrix': function Matrix(arr) {\n      return matrix(_createArray(arr.map(m => m.toArray())));\n    } // TODO implement this properly for SparseMatrix\n\n  });\n\n  function _createArray(arr) {\n    if (arr.length === 0) throw new TypeError('At least one column is needed to construct a matrix.');\n    var N = checkVectorTypeAndReturnLength(arr[0]); // create an array with empty rows\n\n    var result = [];\n\n    for (var i = 0; i < N; i++) {\n      result[i] = [];\n    } // loop columns\n\n\n    for (var col of arr) {\n      var colLength = checkVectorTypeAndReturnLength(col);\n\n      if (colLength !== N) {\n        throw new TypeError('The vectors had different length: ' + (N | 0) + ' ≠ ' + (colLength | 0));\n      }\n\n      var f = flatten(col); // push a value to each row\n\n      for (var _i = 0; _i < N; _i++) {\n        result[_i].push(f[_i]);\n      }\n    }\n\n    return result;\n  }\n\n  function checkVectorTypeAndReturnLength(vec) {\n    var s = size(vec);\n\n    if (s.length === 1) {\n      // 1D vector\n      return s[0];\n    } else if (s.length === 2) {\n      // 2D vector\n      if (s[0] === 1) {\n        // row vector\n        return s[1];\n      } else if (s[1] === 1) {\n        // col vector\n        return s[0];\n      } else {\n        throw new TypeError('At least one of the arguments is not a vector.');\n      }\n    } else {\n      throw new TypeError('Only one- or two-dimensional vectors are supported.');\n    }\n  }\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js"],"names":["factory","name","dependencies","createMatrixFromColumns","_ref","typed","matrix","flatten","size","Array","arr","_createArray","Matrix","map","m","toArray","length","TypeError","N","checkVectorTypeAndReturnLength","result","i","col","colLength","f","_i","push","vec","s"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory.js';\r\nvar name = 'matrixFromColumns';\r\nvar dependencies = ['typed', 'matrix', 'flatten', 'size'];\r\nexport var createMatrixFromColumns = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    flatten,\r\n    size\r\n  } = _ref;\r\n  /**\r\n   * Create a dense matrix from vectors as individual columns.\r\n   * If you pass row vectors, they will be transposed (but not conjugated!)\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.matrixFromColumns(...arr)\r\n   *    math.matrixFromColumns(col1, col2)\r\n   *    math.matrixFromColumns(col1, col2, col3)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.matrixFromColumns([1, 2, 3], [[4],[5],[6]])\r\n   *    math.matrixFromColumns(...vectors)\r\n   *\r\n   * See also:\r\n   *\r\n   *    matrix, matrixFromRows, matrixFromFunction, zeros\r\n   *\r\n   * @param {... Array | Matrix} cols Multiple columns\r\n   * @return { number[][] | Matrix } if at least one of the arguments is an array, an array will be returned\r\n   */\r\n  return typed(name, {\r\n    '...Array': function Array(arr) {\r\n      return _createArray(arr);\r\n    },\r\n    '...Matrix': function Matrix(arr) {\r\n      return matrix(_createArray(arr.map(m => m.toArray())));\r\n    }\r\n\r\n    // TODO implement this properly for SparseMatrix\r\n  });\r\n\r\n  function _createArray(arr) {\r\n    if (arr.length === 0) throw new TypeError('At least one column is needed to construct a matrix.');\r\n    var N = checkVectorTypeAndReturnLength(arr[0]);\r\n\r\n    // create an array with empty rows\r\n    var result = [];\r\n    for (var i = 0; i < N; i++) {\r\n      result[i] = [];\r\n    }\r\n\r\n    // loop columns\r\n    for (var col of arr) {\r\n      var colLength = checkVectorTypeAndReturnLength(col);\r\n      if (colLength !== N) {\r\n        throw new TypeError('The vectors had different length: ' + (N | 0) + ' ≠ ' + (colLength | 0));\r\n      }\r\n      var f = flatten(col);\r\n\r\n      // push a value to each row\r\n      for (var _i = 0; _i < N; _i++) {\r\n        result[_i].push(f[_i]);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  function checkVectorTypeAndReturnLength(vec) {\r\n    var s = size(vec);\r\n    if (s.length === 1) {\r\n      // 1D vector\r\n      return s[0];\r\n    } else if (s.length === 2) {\r\n      // 2D vector\r\n      if (s[0] === 1) {\r\n        // row vector\r\n        return s[1];\r\n      } else if (s[1] === 1) {\r\n        // col vector\r\n        return s[0];\r\n      } else {\r\n        throw new TypeError('At least one of the arguments is not a vector.');\r\n      }\r\n    } else {\r\n      throw new TypeError('Only one- or two-dimensional vectors are supported.');\r\n    }\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}