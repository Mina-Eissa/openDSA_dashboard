{"ast":null,"code":"import { createTemplate, measureElementRect, logBase, removeElement } from '../utils/helper';\nimport { ChartLocation, stringToNumber, appendElement, withIn } from '../utils/helper';\nimport { Rect } from '@syncfusion/ej2-svg-base';\nimport { getPoint } from '../utils/helper';\nimport { createElement, updateBlazorTemplate } from '@syncfusion/ej2-base';\nimport { annotationRender } from '../model/constants';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\r\n * Annotation Module handles the Annotation for chart and accumulation series.\r\n */\n\nvar AnnotationBase =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor for chart and accumulation annotation\r\n   *\r\n   * @param control\r\n   */\n  function AnnotationBase(control) {\n    this.control = control;\n  }\n  /**\r\n   * Method to render the annotation for chart and accumulation series.\r\n   *\r\n   * @private\r\n   * @param annotation\r\n   * @param index\r\n   */\n\n\n  AnnotationBase.prototype.render = function (annotation, index) {\n    this.isChart = this.control.getModuleName() === 'chart';\n    this.annotation = annotation;\n    var childElement = createTemplate(createElement('div', {\n      id: this.control.element.id + '_Annotation_' + index,\n      styles: 'position: absolute; z-index: 1' //by default z-index set for annotation elements\n\n    }), index, annotation.content, this.control);\n    return childElement;\n  };\n  /**\r\n   * Method to calculate the location for annotation - coordinate unit as pixel.\r\n   *\r\n   * @private\r\n   * @param location\r\n   */\n\n\n  AnnotationBase.prototype.setAnnotationPixelValue = function (location) {\n    var rect = this.annotation.region === 'Chart' ? new Rect(0, 0, this.control.availableSize.width, this.control.availableSize.height) : this.isChart ? this.control.chartAxisLayoutPanel.seriesClipRect : this.control.series[0].accumulationBound;\n    location.x = (typeof this.annotation.x !== 'string' ? typeof this.annotation.x === 'number' ? this.annotation.x : 0 : stringToNumber(this.annotation.x, rect.width)) + rect.x;\n    location.y = (typeof this.annotation.y === 'number' ? this.annotation.y : stringToNumber(this.annotation.y, rect.height)) + rect.y;\n    return true;\n  };\n  /**\r\n   * Method to calculate the location for annotation - coordinate unit as point.\r\n   *\r\n   * @private\r\n   * @param location\r\n   */\n\n\n  AnnotationBase.prototype.setAnnotationPointValue = function (location) {\n    var symbolLocation = new ChartLocation(0, 0);\n\n    if (this.isChart) {\n      var chart = this.control;\n      var annotation = this.annotation;\n      var xAxisName = annotation.xAxisName;\n      var yAxisName = annotation.yAxisName;\n      var isInverted = chart.requireInvertedAxis;\n      var stockChart = this.control.stockChart;\n      var xAxis = void 0;\n      var yAxis = void 0;\n      var xValue = void 0;\n\n      for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n        var axis = _a[_i];\n\n        if (xAxisName === axis.name || xAxisName == null && axis.name === 'primaryXAxis') {\n          xAxis = axis;\n\n          if (xAxis.valueType.indexOf('Category') > -1) {\n            var xAnnotation = xAxis.valueType === 'DateTimeCategory' ? annotation.x.getTime().toString() : annotation.x;\n\n            if (xAxis.labels.indexOf(xAnnotation) < 0) {\n              return false;\n            } else {\n              xValue = xAxis.labels.indexOf(xAnnotation);\n            }\n          } else if (xAxis.valueType === 'DateTime') {\n            var option = {\n              skeleton: 'full',\n              type: 'dateTime'\n            };\n            xValue = typeof this.annotation.x === 'object' || typeof new Date(this.annotation.x) === 'object' ? Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({\n              val: annotation.x\n            }).val)))) : 0;\n          } else {\n            xValue = +annotation.x;\n          }\n        } else if (yAxisName === axis.name || yAxisName == null && axis.name === 'primaryYAxis') {\n          yAxis = axis;\n        }\n      }\n\n      if (xAxis && yAxis && withIn(xAxis.valueType === 'Logarithmic' ? logBase(xValue, xAxis.logBase) : xValue, xAxis.visibleRange) && withIn(yAxis.valueType === 'Logarithmic' ? logBase(+annotation.y, yAxis.logBase) : +annotation.y, yAxis.visibleRange)) {\n        symbolLocation = getPoint(xValue, +annotation.y, xAxis, yAxis, isInverted);\n        location.x = symbolLocation.x + (isInverted ? yAxis.rect.x : xAxis.rect.x); // for stockchart, stockchart's toolbar height and title size is added for annotation content\n\n        location.y = symbolLocation.y + (isInverted ? xAxis.rect.y : yAxis.rect.y) + (stockChart && stockChart.enablePeriodSelector ? stockChart.toolbarHeight + stockChart.titleSize.height : 0);\n      } else {\n        return false;\n      }\n\n      return true;\n    } else {\n      return this.setAccumulationPointValue(location);\n    }\n  };\n  /**\r\n   * To process the annotation for accumulation chart\r\n   *\r\n   * @param annotation\r\n   * @param index\r\n   * @param parentElement\r\n   */\n\n\n  AnnotationBase.prototype.processAnnotation = function (annotation, index, parentElement) {\n    var chart = this.control;\n    var location = new ChartLocation(0, 0);\n    var annotationElement = this.render(annotation, index);\n\n    var annotationRendered = function () {\n      annotationElement.style.transform = 'translate(-50%, -50%)';\n    };\n\n    annotationRendered.bind(location, this);\n\n    if (this['setAnnotation' + annotation.coordinateUnits + 'Value'](location)) {\n      this.setElementStyle(location, annotationElement, parentElement);\n    } else if (this.control.redraw) {\n      removeElement(annotationElement.id);\n    }\n\n    updateBlazorTemplate((this.control.element.id + 'Annotation' + index).replace(/[^a-zA-Z0-9]/g, ''), 'ContentTemplate', chart.stockChart ? chart.stockChart.annotations[index] : this.control.annotations[index], undefined, annotationRendered);\n  };\n  /**\r\n   * Method to calculate the location for annotation - coordinate unit as point in accumulation chart.\r\n   *\r\n   * @private\r\n   * @param location\r\n   */\n\n\n  AnnotationBase.prototype.setAccumulationPointValue = function (location) {\n    var accumulation = this.control;\n    var point;\n\n    for (var _i = 0, _a = accumulation.visibleSeries[0].points; _i < _a.length; _i++) {\n      var accPoint = _a[_i];\n\n      if (typeof accPoint.x === 'object') {\n        if (Date.parse(accPoint.x) === Date.parse(this.annotation.x) && accPoint.y === this.annotation.y) {\n          point = accPoint;\n          break;\n        }\n      } else {\n        if (accPoint.x == this.annotation.x && accPoint.y == this.annotation.y) {\n          point = accPoint;\n          break;\n        }\n      }\n    }\n\n    if (point && point.visible) {\n      location.x = point.symbolLocation.x;\n      location.y = point.symbolLocation.y;\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\r\n   * Method to set the element style for accumulation / chart annotation.\r\n   *\r\n   * @private\r\n   * @param location\r\n   * @param element\r\n   * @param parentElement\r\n   */\n\n\n  AnnotationBase.prototype.setElementStyle = function (location, element, parentElement) {\n    var elementRect = measureElementRect(element, this.control.redraw);\n    var argsData = {\n      cancel: false,\n      name: annotationRender,\n      content: element,\n      location: location\n    };\n    this.control.trigger(annotationRender, argsData);\n\n    if (!argsData.cancel) {\n      argsData.content.style.left = this.setAlignmentValue(this.annotation.horizontalAlignment, elementRect.width, argsData.location.x) + 'px';\n      argsData.content.style.top = this.setAlignmentValue(this.annotation.verticalAlignment, elementRect.height, argsData.location.y) + 'px';\n      argsData.content.setAttribute('aria-label', this.annotation.description || 'Annotation');\n      appendElement(argsData.content, parentElement, this.control.redraw, true, 'left', 'top');\n    }\n  };\n  /**\r\n   * Method to calculate the alignment value for annotation.\r\n   *\r\n   * @private\r\n   * @param alignment\r\n   * @param size\r\n   * @param value\r\n   */\n\n\n  AnnotationBase.prototype.setAlignmentValue = function (alignment, size, value) {\n    switch (alignment) {\n      case 'Top':\n      case 'Near':\n        value -= size;\n        break;\n\n      case 'Bottom':\n      case 'Far':\n        value += 0;\n        break;\n\n      case 'Middle':\n      case 'Center':\n        value -= size / 2;\n        break;\n    }\n\n    return value;\n  };\n\n  return AnnotationBase;\n}();\n\nexport { AnnotationBase };","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/common/annotation/annotation.js"],"names":["createTemplate","measureElementRect","logBase","removeElement","ChartLocation","stringToNumber","appendElement","withIn","Rect","getPoint","createElement","updateBlazorTemplate","annotationRender","DataUtil","AnnotationBase","control","prototype","render","annotation","index","isChart","getModuleName","childElement","id","element","styles","content","setAnnotationPixelValue","location","rect","region","availableSize","width","height","chartAxisLayoutPanel","seriesClipRect","series","accumulationBound","x","y","setAnnotationPointValue","symbolLocation","chart","xAxisName","yAxisName","isInverted","requireInvertedAxis","stockChart","xAxis","yAxis","xValue","_i","_a","axisCollections","length","axis","name","valueType","indexOf","xAnnotation","getTime","toString","labels","option","skeleton","type","Date","parse","intl","getDateParser","getDateFormat","parseJson","val","visibleRange","enablePeriodSelector","toolbarHeight","titleSize","setAccumulationPointValue","processAnnotation","parentElement","annotationElement","annotationRendered","style","transform","bind","coordinateUnits","setElementStyle","redraw","replace","annotations","undefined","accumulation","point","visibleSeries","points","accPoint","visible","elementRect","argsData","cancel","trigger","left","setAlignmentValue","horizontalAlignment","top","verticalAlignment","setAttribute","description","alignment","size","value"],"mappings":"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","sourcesContent":["import { createTemplate, measureElementRect, logBase, removeElement } from '../utils/helper';\r\nimport { ChartLocation, stringToNumber, appendElement, withIn } from '../utils/helper';\r\nimport { Rect } from '@syncfusion/ej2-svg-base';\r\nimport { getPoint } from '../utils/helper';\r\nimport { createElement, updateBlazorTemplate } from '@syncfusion/ej2-base';\r\nimport { annotationRender } from '../model/constants';\r\nimport { DataUtil } from '@syncfusion/ej2-data';\r\n/**\r\n * Annotation Module handles the Annotation for chart and accumulation series.\r\n */\r\nvar AnnotationBase = /** @class */ (function () {\r\n    /**\r\n     * Constructor for chart and accumulation annotation\r\n     *\r\n     * @param control\r\n     */\r\n    function AnnotationBase(control) {\r\n        this.control = control;\r\n    }\r\n    /**\r\n     * Method to render the annotation for chart and accumulation series.\r\n     *\r\n     * @private\r\n     * @param annotation\r\n     * @param index\r\n     */\r\n    AnnotationBase.prototype.render = function (annotation, index) {\r\n        this.isChart = this.control.getModuleName() === 'chart';\r\n        this.annotation = annotation;\r\n        var childElement = createTemplate(createElement('div', {\r\n            id: this.control.element.id + '_Annotation_' + index,\r\n            styles: 'position: absolute; z-index: 1' //by default z-index set for annotation elements\r\n        }), index, annotation.content, this.control);\r\n        return childElement;\r\n    };\r\n    /**\r\n     * Method to calculate the location for annotation - coordinate unit as pixel.\r\n     *\r\n     * @private\r\n     * @param location\r\n     */\r\n    AnnotationBase.prototype.setAnnotationPixelValue = function (location) {\r\n        var rect = this.annotation.region === 'Chart' ?\r\n            new Rect(0, 0, this.control.availableSize.width, this.control.availableSize.height) :\r\n            this.isChart ?\r\n                this.control.chartAxisLayoutPanel.seriesClipRect :\r\n                this.control.series[0].accumulationBound;\r\n        location.x = ((typeof this.annotation.x !== 'string') ?\r\n            ((typeof this.annotation.x === 'number') ? this.annotation.x : 0) :\r\n            stringToNumber(this.annotation.x, rect.width)) + rect.x;\r\n        location.y = ((typeof this.annotation.y === 'number') ? this.annotation.y :\r\n            stringToNumber(this.annotation.y, rect.height)) + rect.y;\r\n        return true;\r\n    };\r\n    /**\r\n     * Method to calculate the location for annotation - coordinate unit as point.\r\n     *\r\n     * @private\r\n     * @param location\r\n     */\r\n    AnnotationBase.prototype.setAnnotationPointValue = function (location) {\r\n        var symbolLocation = new ChartLocation(0, 0);\r\n        if (this.isChart) {\r\n            var chart = this.control;\r\n            var annotation = this.annotation;\r\n            var xAxisName = annotation.xAxisName;\r\n            var yAxisName = annotation.yAxisName;\r\n            var isInverted = chart.requireInvertedAxis;\r\n            var stockChart = this.control.stockChart;\r\n            var xAxis = void 0;\r\n            var yAxis = void 0;\r\n            var xValue = void 0;\r\n            for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\r\n                var axis = _a[_i];\r\n                if (xAxisName === axis.name || (xAxisName == null && axis.name === 'primaryXAxis')) {\r\n                    xAxis = axis;\r\n                    if (xAxis.valueType.indexOf('Category') > -1) {\r\n                        var xAnnotation = xAxis.valueType === 'DateTimeCategory' ? (annotation.x.getTime()).toString() :\r\n                            annotation.x;\r\n                        if (xAxis.labels.indexOf(xAnnotation) < 0) {\r\n                            return false;\r\n                        }\r\n                        else {\r\n                            xValue = xAxis.labels.indexOf(xAnnotation);\r\n                        }\r\n                    }\r\n                    else if (xAxis.valueType === 'DateTime') {\r\n                        var option = { skeleton: 'full', type: 'dateTime' };\r\n                        xValue = (typeof this.annotation.x === 'object' || typeof new Date(this.annotation.x) === 'object') ?\r\n                            Date.parse(chart.intl.getDateParser(option)(chart.intl.getDateFormat(option)(new Date(DataUtil.parse.parseJson({ val: annotation.x }).val)))) : 0;\r\n                    }\r\n                    else {\r\n                        xValue = +annotation.x;\r\n                    }\r\n                }\r\n                else if (yAxisName === axis.name || (yAxisName == null && axis.name === 'primaryYAxis')) {\r\n                    yAxis = axis;\r\n                }\r\n            }\r\n            if (xAxis && yAxis && withIn(xAxis.valueType === 'Logarithmic' ? logBase(xValue, xAxis.logBase) : xValue, xAxis.visibleRange) && withIn(yAxis.valueType === 'Logarithmic' ? logBase(+annotation.y, yAxis.logBase) : +annotation.y, yAxis.visibleRange)) {\r\n                symbolLocation = getPoint(xValue, +annotation.y, xAxis, yAxis, isInverted);\r\n                location.x = symbolLocation.x + (isInverted ? yAxis.rect.x : xAxis.rect.x);\r\n                // for stockchart, stockchart's toolbar height and title size is added for annotation content\r\n                location.y = symbolLocation.y + (isInverted ? xAxis.rect.y : yAxis.rect.y) +\r\n                    ((stockChart && stockChart.enablePeriodSelector) ? stockChart.toolbarHeight + stockChart.titleSize.height : 0);\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        else {\r\n            return this.setAccumulationPointValue(location);\r\n        }\r\n    };\r\n    /**\r\n     * To process the annotation for accumulation chart\r\n     *\r\n     * @param annotation\r\n     * @param index\r\n     * @param parentElement\r\n     */\r\n    AnnotationBase.prototype.processAnnotation = function (annotation, index, parentElement) {\r\n        var chart = this.control;\r\n        var location = new ChartLocation(0, 0);\r\n        var annotationElement = this.render(annotation, index);\r\n        var annotationRendered = function () {\r\n            annotationElement.style.transform = 'translate(-50%, -50%)';\r\n        };\r\n        annotationRendered.bind(location, this);\r\n        if (this['setAnnotation' + annotation.coordinateUnits + 'Value'](location)) {\r\n            this.setElementStyle(location, annotationElement, parentElement);\r\n        }\r\n        else if (this.control.redraw) {\r\n            removeElement(annotationElement.id);\r\n        }\r\n        updateBlazorTemplate((this.control.element.id + 'Annotation' + index).replace(/[^a-zA-Z0-9]/g, ''), 'ContentTemplate', chart.stockChart ? chart.stockChart.annotations[index] : this.control.annotations[index], undefined, annotationRendered);\r\n    };\r\n    /**\r\n     * Method to calculate the location for annotation - coordinate unit as point in accumulation chart.\r\n     *\r\n     * @private\r\n     * @param location\r\n     */\r\n    AnnotationBase.prototype.setAccumulationPointValue = function (location) {\r\n        var accumulation = this.control;\r\n        var point;\r\n        for (var _i = 0, _a = accumulation.visibleSeries[0].points; _i < _a.length; _i++) {\r\n            var accPoint = _a[_i];\r\n            if (typeof accPoint.x === 'object') {\r\n                if (Date.parse(accPoint.x) === Date.parse(this.annotation.x) &&\r\n                    accPoint.y === this.annotation.y) {\r\n                    point = accPoint;\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                if (accPoint.x == this.annotation.x && accPoint.y == this.annotation.y) {\r\n                    point = accPoint;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (point && point.visible) {\r\n            location.x = point.symbolLocation.x;\r\n            location.y = point.symbolLocation.y;\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    };\r\n    /**\r\n     * Method to set the element style for accumulation / chart annotation.\r\n     *\r\n     * @private\r\n     * @param location\r\n     * @param element\r\n     * @param parentElement\r\n     */\r\n    AnnotationBase.prototype.setElementStyle = function (location, element, parentElement) {\r\n        var elementRect = measureElementRect(element, this.control.redraw);\r\n        var argsData = {\r\n            cancel: false, name: annotationRender, content: element,\r\n            location: location\r\n        };\r\n        this.control.trigger(annotationRender, argsData);\r\n        if (!argsData.cancel) {\r\n            argsData.content.style.left = this.setAlignmentValue(this.annotation.horizontalAlignment, elementRect.width, argsData.location.x) + 'px';\r\n            argsData.content.style.top = this.setAlignmentValue(this.annotation.verticalAlignment, elementRect.height, argsData.location.y) + 'px';\r\n            argsData.content.setAttribute('aria-label', this.annotation.description || 'Annotation');\r\n            appendElement(argsData.content, parentElement, this.control.redraw, true, 'left', 'top');\r\n        }\r\n    };\r\n    /**\r\n     * Method to calculate the alignment value for annotation.\r\n     *\r\n     * @private\r\n     * @param alignment\r\n     * @param size\r\n     * @param value\r\n     */\r\n    AnnotationBase.prototype.setAlignmentValue = function (alignment, size, value) {\r\n        switch (alignment) {\r\n            case 'Top':\r\n            case 'Near':\r\n                value -= size;\r\n                break;\r\n            case 'Bottom':\r\n            case 'Far':\r\n                value += 0;\r\n                break;\r\n            case 'Middle':\r\n            case 'Center':\r\n                value -= (size / 2);\r\n                break;\r\n        }\r\n        return value;\r\n    };\r\n    return AnnotationBase;\r\n}());\r\nexport { AnnotationBase };\r\n"]},"metadata":{},"sourceType":"module"}