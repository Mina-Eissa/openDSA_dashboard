{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'Matrix';\nvar dependencies = [];\nexport var createMatrixClass = /* #__PURE__ */factory(name, dependencies, () => {\n  /**\r\n   * @constructor Matrix\r\n   *\r\n   * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional\r\n   * array. A matrix can be constructed as:\r\n   *\r\n   *     let matrix = math.matrix(data)\r\n   *\r\n   * Matrix contains the functions to resize, get and set values, get the size,\r\n   * clone the matrix and to convert the matrix to a vector, array, or scalar.\r\n   * Furthermore, one can iterate over the matrix using map and forEach.\r\n   * The internal Array of the Matrix can be accessed using the function valueOf.\r\n   *\r\n   * Example usage:\r\n   *\r\n   *     let matrix = math.matrix([[1, 2], [3, 4]])\r\n   *     matix.size()              // [2, 2]\r\n   *     matrix.resize([3, 2], 5)\r\n   *     matrix.valueOf()          // [[1, 2], [3, 4], [5, 5]]\r\n   *     matrix.subset([1,2])       // 3 (indexes are zero-based)\r\n   *\r\n   */\n  function Matrix() {\n    if (!(this instanceof Matrix)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n  }\n  /**\r\n   * Attach type information\r\n   */\n\n\n  Matrix.prototype.type = 'Matrix';\n  Matrix.prototype.isMatrix = true;\n  /**\r\n   * Get the storage format used by the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.storage()   // retrieve storage format\r\n   *\r\n   * @return {string}           The storage format.\r\n   */\n\n  Matrix.prototype.storage = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke storage on a Matrix interface');\n  };\n  /**\r\n   * Get the datatype of the data stored in the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.datatype()    // retrieve matrix datatype\r\n   *\r\n   * @return {string}           The datatype.\r\n   */\n\n\n  Matrix.prototype.datatype = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke datatype on a Matrix interface');\n  };\n  /**\r\n   * Create a new Matrix With the type of the current matrix instance\r\n   * @param {Array | Object} data\r\n   * @param {string} [datatype]\r\n   */\n\n\n  Matrix.prototype.create = function (data, datatype) {\n    throw new Error('Cannot invoke create on a Matrix interface');\n  };\n  /**\r\n   * Get a subset of the matrix, or replace a subset of the matrix.\r\n   *\r\n   * Usage:\r\n   *     const subset = matrix.subset(index)               // retrieve subset\r\n   *     const value = matrix.subset(index, replacement)   // replace subset\r\n   *\r\n   * @param {Index} index\r\n   * @param {Array | Matrix | *} [replacement]\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be filled with zeros.\r\n   */\n\n\n  Matrix.prototype.subset = function (index, replacement, defaultValue) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke subset on a Matrix interface');\n  };\n  /**\r\n   * Get a single element from the matrix.\r\n   * @param {number[]} index   Zero-based index\r\n   * @return {*} value\r\n   */\n\n\n  Matrix.prototype.get = function (index) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke get on a Matrix interface');\n  };\n  /**\r\n   * Replace a single element in the matrix.\r\n   * @param {number[]} index   Zero-based index\r\n   * @param {*} value\r\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be left undefined.\r\n   * @return {Matrix} self\r\n   */\n\n\n  Matrix.prototype.set = function (index, value, defaultValue) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke set on a Matrix interface');\n  };\n  /**\r\n   * Resize the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (resize in place).\r\n   *\r\n   * @param {number[]} size           The new size the matrix should have.\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\r\n   *                                  If not provided, the matrix elements will\r\n   *                                  be filled with zeros.\r\n   * @param {boolean} [copy]          Return a resized copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The resized matrix\r\n   */\n\n\n  Matrix.prototype.resize = function (size, defaultValue) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke resize on a Matrix interface');\n  };\n  /**\r\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\r\n   *\r\n   * @param {number[]} size           The new size the matrix should have.\r\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The reshaped matrix\r\n   */\n\n\n  Matrix.prototype.reshape = function (size, defaultValue) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke reshape on a Matrix interface');\n  };\n  /**\r\n   * Create a clone of the matrix\r\n   * @return {Matrix} clone\r\n   */\n\n\n  Matrix.prototype.clone = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke clone on a Matrix interface');\n  };\n  /**\r\n   * Retrieve the size of the matrix.\r\n   * @returns {number[]} size\r\n   */\n\n\n  Matrix.prototype.size = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke size on a Matrix interface');\n  };\n  /**\r\n   * Create a new matrix with the results of the callback function executed on\r\n   * each entry of the matrix.\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\r\n   *\r\n   * @return {Matrix} matrix\r\n   */\n\n\n  Matrix.prototype.map = function (callback, skipZeros) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke map on a Matrix interface');\n  };\n  /**\r\n   * Execute a callback function on each entry of the matrix.\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   */\n\n\n  Matrix.prototype.forEach = function (callback) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke forEach on a Matrix interface');\n  };\n  /**\r\n   * Iterate over the matrix elements\r\n   * @return {Iterable<{ value, index: number[] }>}\r\n   */\n\n\n  Matrix.prototype[Symbol.iterator] = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot iterate a Matrix interface');\n  };\n  /**\r\n   * Create an Array with a copy of the data of the Matrix\r\n   * @returns {Array} array\r\n   */\n\n\n  Matrix.prototype.toArray = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke toArray on a Matrix interface');\n  };\n  /**\r\n   * Get the primitive value of the Matrix: a multidimensional array\r\n   * @returns {Array} array\r\n   */\n\n\n  Matrix.prototype.valueOf = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke valueOf on a Matrix interface');\n  };\n  /**\r\n   * Get a string representation of the matrix, with optional formatting options.\r\n   * @param {Object | number | Function} [options]  Formatting options. See\r\n   *                                                lib/utils/number:format for a\r\n   *                                                description of the available\r\n   *                                                options.\r\n   * @returns {string} str\r\n   */\n\n\n  Matrix.prototype.format = function (options) {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke format on a Matrix interface');\n  };\n  /**\r\n   * Get a string representation of the matrix\r\n   * @returns {string} str\r\n   */\n\n\n  Matrix.prototype.toString = function () {\n    // must be implemented by each of the Matrix implementations\n    throw new Error('Cannot invoke toString on a Matrix interface');\n  };\n\n  return Matrix;\n}, {\n  isClass: true\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/type/matrix/Matrix.js"],"names":["factory","name","dependencies","createMatrixClass","Matrix","SyntaxError","prototype","type","isMatrix","storage","Error","datatype","create","data","subset","index","replacement","defaultValue","get","set","value","resize","size","reshape","clone","map","callback","skipZeros","forEach","Symbol","iterator","toArray","valueOf","format","options","toString","isClass"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory.js';\r\nvar name = 'Matrix';\r\nvar dependencies = [];\r\nexport var createMatrixClass = /* #__PURE__ */factory(name, dependencies, () => {\r\n  /**\r\n   * @constructor Matrix\r\n   *\r\n   * A Matrix is a wrapper around an Array. A matrix can hold a multi dimensional\r\n   * array. A matrix can be constructed as:\r\n   *\r\n   *     let matrix = math.matrix(data)\r\n   *\r\n   * Matrix contains the functions to resize, get and set values, get the size,\r\n   * clone the matrix and to convert the matrix to a vector, array, or scalar.\r\n   * Furthermore, one can iterate over the matrix using map and forEach.\r\n   * The internal Array of the Matrix can be accessed using the function valueOf.\r\n   *\r\n   * Example usage:\r\n   *\r\n   *     let matrix = math.matrix([[1, 2], [3, 4]])\r\n   *     matix.size()              // [2, 2]\r\n   *     matrix.resize([3, 2], 5)\r\n   *     matrix.valueOf()          // [[1, 2], [3, 4], [5, 5]]\r\n   *     matrix.subset([1,2])       // 3 (indexes are zero-based)\r\n   *\r\n   */\r\n  function Matrix() {\r\n    if (!(this instanceof Matrix)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attach type information\r\n   */\r\n  Matrix.prototype.type = 'Matrix';\r\n  Matrix.prototype.isMatrix = true;\r\n\r\n  /**\r\n   * Get the storage format used by the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.storage()   // retrieve storage format\r\n   *\r\n   * @return {string}           The storage format.\r\n   */\r\n  Matrix.prototype.storage = function () {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke storage on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Get the datatype of the data stored in the matrix.\r\n   *\r\n   * Usage:\r\n   *     const format = matrix.datatype()    // retrieve matrix datatype\r\n   *\r\n   * @return {string}           The datatype.\r\n   */\r\n  Matrix.prototype.datatype = function () {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke datatype on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Create a new Matrix With the type of the current matrix instance\r\n   * @param {Array | Object} data\r\n   * @param {string} [datatype]\r\n   */\r\n  Matrix.prototype.create = function (data, datatype) {\r\n    throw new Error('Cannot invoke create on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Get a subset of the matrix, or replace a subset of the matrix.\r\n   *\r\n   * Usage:\r\n   *     const subset = matrix.subset(index)               // retrieve subset\r\n   *     const value = matrix.subset(index, replacement)   // replace subset\r\n   *\r\n   * @param {Index} index\r\n   * @param {Array | Matrix | *} [replacement]\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be filled with zeros.\r\n   */\r\n  Matrix.prototype.subset = function (index, replacement, defaultValue) {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke subset on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Get a single element from the matrix.\r\n   * @param {number[]} index   Zero-based index\r\n   * @return {*} value\r\n   */\r\n  Matrix.prototype.get = function (index) {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke get on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Replace a single element in the matrix.\r\n   * @param {number[]} index   Zero-based index\r\n   * @param {*} value\r\n   * @param {*} [defaultValue]        Default value, filled in on new entries when\r\n   *                                  the matrix is resized. If not provided,\r\n   *                                  new matrix elements will be left undefined.\r\n   * @return {Matrix} self\r\n   */\r\n  Matrix.prototype.set = function (index, value, defaultValue) {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke set on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Resize the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (resize in place).\r\n   *\r\n   * @param {number[]} size           The new size the matrix should have.\r\n   * @param {*} [defaultValue=0]      Default value, filled in on new entries.\r\n   *                                  If not provided, the matrix elements will\r\n   *                                  be filled with zeros.\r\n   * @param {boolean} [copy]          Return a resized copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The resized matrix\r\n   */\r\n  Matrix.prototype.resize = function (size, defaultValue) {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke resize on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Reshape the matrix to the given size. Returns a copy of the matrix when\r\n   * `copy=true`, otherwise return the matrix itself (reshape in place).\r\n   *\r\n   * @param {number[]} size           The new size the matrix should have.\r\n   * @param {boolean} [copy]          Return a reshaped copy of the matrix\r\n   *\r\n   * @return {Matrix}                 The reshaped matrix\r\n   */\r\n  Matrix.prototype.reshape = function (size, defaultValue) {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke reshape on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Create a clone of the matrix\r\n   * @return {Matrix} clone\r\n   */\r\n  Matrix.prototype.clone = function () {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke clone on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Retrieve the size of the matrix.\r\n   * @returns {number[]} size\r\n   */\r\n  Matrix.prototype.size = function () {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke size on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Create a new matrix with the results of the callback function executed on\r\n   * each entry of the matrix.\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   * @param {boolean} [skipZeros] Invoke callback function for non-zero values only.\r\n   *\r\n   * @return {Matrix} matrix\r\n   */\r\n  Matrix.prototype.map = function (callback, skipZeros) {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke map on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Execute a callback function on each entry of the matrix.\r\n   * @param {Function} callback   The callback function is invoked with three\r\n   *                              parameters: the value of the element, the index\r\n   *                              of the element, and the Matrix being traversed.\r\n   */\r\n  Matrix.prototype.forEach = function (callback) {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke forEach on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Iterate over the matrix elements\r\n   * @return {Iterable<{ value, index: number[] }>}\r\n   */\r\n  Matrix.prototype[Symbol.iterator] = function () {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot iterate a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Create an Array with a copy of the data of the Matrix\r\n   * @returns {Array} array\r\n   */\r\n  Matrix.prototype.toArray = function () {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke toArray on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Get the primitive value of the Matrix: a multidimensional array\r\n   * @returns {Array} array\r\n   */\r\n  Matrix.prototype.valueOf = function () {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke valueOf on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Get a string representation of the matrix, with optional formatting options.\r\n   * @param {Object | number | Function} [options]  Formatting options. See\r\n   *                                                lib/utils/number:format for a\r\n   *                                                description of the available\r\n   *                                                options.\r\n   * @returns {string} str\r\n   */\r\n  Matrix.prototype.format = function (options) {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke format on a Matrix interface');\r\n  };\r\n\r\n  /**\r\n   * Get a string representation of the matrix\r\n   * @returns {string} str\r\n   */\r\n  Matrix.prototype.toString = function () {\r\n    // must be implemented by each of the Matrix implementations\r\n    throw new Error('Cannot invoke toString on a Matrix interface');\r\n  };\r\n  return Matrix;\r\n}, {\r\n  isClass: true\r\n});"]},"metadata":{},"sourceType":"module"}