{"ast":null,"code":"/* eslint-disable jsdoc/require-returns */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable jsdoc/require-param */\n\n/* eslint-disable @typescript-eslint/no-inferrable-types */\nimport { ChartLocation, RectOption, isCollide, isOverlap } from '../../common/utils/helper';\nimport { markerAnimate, appendChildElement, getVisiblePoints } from '../../common/utils/helper';\nimport { getLabelText, convertHexToColor, calculateRect, textElement, colorNameToHex } from '../../common/utils/helper';\nimport { measureText, TextOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { textRender } from '../../common/model/constants';\nimport { createTemplate, getFontStyle, getElement, measureElementRect, templateAnimate, withIn, withInBounds } from '../../common/utils/helper';\nimport { createElement, getValue, extend } from '@syncfusion/ej2-base';\nimport { getPoint, getRotatedRectangleCoordinates, isRotatedRectIntersect } from '../../common/utils/helper';\n/**\r\n * `DataLabel` module is used to render data label for the data point.\r\n */\n\nvar DataLabel =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor for the data label module.\r\n   *\r\n   * @private\r\n   */\n  function DataLabel(chart) {\n    this.errorHeight = 0;\n    this.chart = chart;\n  }\n\n  DataLabel.prototype.initPrivateVariables = function (series, marker) {\n    var transform = '';\n    var clipPath = '';\n    var render = series.chart.renderer;\n    var index = series.index === undefined ? series.category : series.index;\n\n    if (series.chart.chartAreaType === 'Cartesian') {\n      transform = 'translate(' + series.clipRect.x + ',' + series.clipRect.y + ')';\n      clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';\n    }\n\n    if (marker.dataLabel.visible) {\n      series.shapeElement = render.createGroup({\n        'id': this.chart.element.id + 'ShapeGroup' + index,\n        'transform': transform,\n        'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\n      });\n      series.textElement = render.createGroup({\n        'id': this.chart.element.id + 'TextGroup' + index,\n        'transform': transform,\n        'clip-path': clipPath\n      });\n    }\n\n    this.markerHeight = series.type === 'Scatter' || marker.visible ? marker.height / 2 : 0;\n    this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\n    this.calculateErrorHeight(series, series.marker.dataLabel.position);\n    this.chartBackground = this.chart.chartArea.background === 'transparent' ? this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\n  };\n\n  DataLabel.prototype.calculateErrorHeight = function (series, position) {\n    if (!series.errorBar.visible) {\n      return null;\n    } else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\n      var direction = series.errorBar.direction;\n      var positiveHeight = this.chart.errorBarModule.positiveHeight;\n      var negativeHeight = this.chart.errorBarModule.negativeHeight;\n\n      if (this.isRectSeries(series)) {\n        if (position === 'Top' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Minus') {\n            this.errorHeight = negativeHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n\n        if (position === 'Outer' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Plus') {\n            this.errorHeight = positiveHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n      } else {\n        if (position === 'Top' || position === 'Outer' || position === 'Auto') {\n          if ((direction === 'Both' || direction === 'Plus') && !series.chart.isTransposed) {\n            this.errorHeight = positiveHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n\n        if (position === 'Bottom' || position === 'Auto') {\n          if (direction === 'Both' || direction === 'Minus') {\n            this.errorHeight = negativeHeight;\n          } else {\n            this.errorHeight = 0;\n          }\n        }\n      }\n    } else {\n      this.errorHeight = 0;\n    }\n  };\n\n  DataLabel.prototype.isRectSeries = function (series) {\n    return series.isRectSeries || series.type === 'RangeArea' || series.type === 'SplineRangeArea';\n  };\n  /**\r\n   * Render the data label for series.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  DataLabel.prototype.render = function (series, chart, dataLabel) {\n    // initialize the private variable\n    this.initPrivateVariables(series, series.marker);\n    var rect;\n    var labelLocation = {\n      x: 0,\n      y: 0\n    };\n    var rgbValue;\n    var contrast;\n    var argsData;\n    var border;\n    var textSize;\n    var angle;\n    var degree;\n    this.inverted = chart.requireInvertedAxis;\n    this.yAxisInversed = series.yAxis.isAxisInverse;\n    var redraw = chart.redraw;\n    var isDataLabelOverlap = false;\n    var coordinatesAfterRotation = [];\n    var templateId = chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\n    var element = createElement('div', {\n      id: templateId\n    });\n    var visiblePoints = getVisiblePoints(series);\n    var point;\n    var rectCenterX;\n    var rectCenterY; // Data label point iteration started\n\n    for (var i = 0; i < visiblePoints.length; i++) {\n      point = visiblePoints[i];\n\n      if (!dataLabel.showZero && (point.y !== 0 || point.y === 0 && series.emptyPointSettings.mode === 'Zero')) {\n        return null;\n      }\n\n      this.margin = dataLabel.margin;\n      var labelText = [];\n      var labelLength = void 0;\n      var xPos = void 0;\n      var yPos = void 0;\n      var xValue = void 0;\n      var yValue = void 0;\n      var isRender = true;\n      var clip = series.clipRect;\n      var shapeRect = void 0;\n      isDataLabelOverlap = false;\n      angle = degree = dataLabel.angle;\n      border = {\n        width: dataLabel.border.width,\n        color: dataLabel.border.color\n      };\n      var argsFont = extend({}, getValue('properties', dataLabel.font), null, true);\n\n      if (point.symbolLocations.length && point.symbolLocations[0] || series.type === 'BoxAndWhisker' && point.regions.length) {\n        labelText = getLabelText(point, series, chart);\n        labelLength = labelText.length;\n\n        for (var i_1 = 0; i_1 < labelLength; i_1++) {\n          argsData = {\n            cancel: false,\n            name: textRender,\n            series: series,\n            point: point,\n            text: labelText[i_1],\n            border: border,\n            color: dataLabel.fill,\n            template: dataLabel.template,\n            font: argsFont,\n            location: labelLocation,\n            textSize: measureText(labelText[i_1], dataLabel.font)\n          };\n          chart.trigger(textRender, argsData);\n\n          if (!argsData.cancel) {\n            this.fontBackground = argsData.color;\n            this.isDataLabelShape(argsData);\n            this.markerHeight = series.type === 'Bubble' ? point.regions[0].height / 2 : this.markerHeight;\n\n            if (argsData.template !== null) {\n              this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i_1, redraw);\n            } else {\n              textSize = measureText(argsData.text, dataLabel.font);\n              rect = this.calculateTextPosition(point, series, textSize, dataLabel, i_1); // To check whether the polar radar chart datalabel intersects the axis label or not\n\n              if (chart.chartAreaType === 'PolarRadar') {\n                for (var _i = 0, _a = chart.chartAxisLayoutPanel.visibleAxisLabelRect; _i < _a.length; _i++) {\n                  var rectRegion = _a[_i];\n\n                  if (isOverlap(new Rect(rect.x, rect.y, rect.width, rect.height), rectRegion)) {\n                    isRender = false;\n                    break;\n                  }\n                }\n              }\n\n              var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height); //let notOverlapping: boolean;\n\n              if (dataLabel.enableRotation) {\n                var rectCoordinates = this.getRectanglePoints(rect);\n                rectCenterX = rect.x + rect.width / 2;\n                rectCenterY = rect.y + rect.height / 2;\n                coordinatesAfterRotation = getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle);\n                isDataLabelOverlap = this.isDataLabelOverlapWithChartBound(coordinatesAfterRotation, chart, clip);\n\n                if (!isDataLabelOverlap) {\n                  this.chart.rotatedDataLabelCollections.push(coordinatesAfterRotation);\n                  var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;\n\n                  for (var index = currentPointIndex; index >= 0; index--) {\n                    if (this.chart.rotatedDataLabelCollections[currentPointIndex] && this.chart.rotatedDataLabelCollections[index - 1] && isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {\n                      isDataLabelOverlap = true;\n                      this.chart.rotatedDataLabelCollections[currentPointIndex] = null;\n                      break;\n                    }\n                  }\n                }\n              } else {\n                isDataLabelOverlap = isCollide(rect, chart.dataLabelCollections, clip);\n              }\n\n              if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None') && isRender) {\n                chart.dataLabelCollections.push(actualRect);\n\n                if (this.isShape) {\n                  shapeRect = chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i_1, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry), new Int32Array([clip.x, clip.y]));\n\n                  if (series.shapeElement) {\n                    series.shapeElement.appendChild(shapeRect);\n                  }\n                } // Checking the font color\n\n\n                rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n                contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\n                xPos = rect.x + this.margin.left + textSize.width / 2 + labelLocation.x;\n                yPos = rect.y + this.margin.top + textSize.height * 3 / 4 + labelLocation.y;\n                labelLocation = {\n                  x: 0,\n                  y: 0\n                };\n\n                if (angle !== 0 && dataLabel.enableRotation) {\n                  // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);\n                  xValue = rectCenterX; //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +\n                  // (dataLabel.margin.bottom) / 2;\n\n                  yValue = rectCenterY;\n                  degree = angle > 360 ? angle - 360 : angle < -360 ? angle + 360 : angle;\n                } else {\n                  degree = 0;\n                  xValue = rect.x;\n                  yValue = rect.y;\n                }\n\n                textElement(chart.renderer, new TextOption(this.commonId + point.index + '_Text_' + i_1, xPos, yPos, 'middle', argsData.text, 'rotate(' + degree + ',' + xValue + ',' + yValue + ')', 'auto', degree), argsData.font, argsData.font.color || (contrast >= 128 || series.type === 'Hilo' ? 'black' : 'white'), series.textElement, false, redraw, true, false, series.chart.duration, series.clipRect, null, null, chart.enableCanvas);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (element.childElementCount) {\n      if (!chart.enableCanvas) {\n        appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw, // eslint-disable-next-line @typescript-eslint/indent\n        false, 'x', 'y', null, '', false, false, null, chart.duration);\n      } else {\n        getElement(chart.element.id + '_Secondary_Element').appendChild(element);\n      }\n    }\n  };\n  /**\r\n   * Get rect coordinates\r\n   */\n\n\n  DataLabel.prototype.getRectanglePoints = function (rect) {\n    var loc1 = new ChartLocation(rect.x, rect.y);\n    var loc2 = new ChartLocation(rect.x + rect.width, rect.y);\n    var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n    var loc4 = new ChartLocation(rect.x, rect.y + rect.height);\n    return [loc1, loc2, loc3, loc4];\n  };\n\n  DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {\n    for (var index = 0; index < rectCoordinates.length; index++) {\n      if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\r\n   * Render the data label template.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\n    this.margin = {\n      left: 0,\n      right: 0,\n      bottom: 0,\n      top: 0\n    };\n    var clip = series.clipRect;\n    var childElement = createTemplate(createElement('div', {\n      id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_' + point.index + (labelIndex ? '_' + labelIndex : ''),\n      styles: 'position: absolute;background-color:' + data.color + ';' + getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\n    }), point.index, data.template, this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);\n    this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);\n  };\n\n  DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {\n    var elementRect = measureElementRect(childElement, redraw, isReactCallback);\n    var rect = this.calculateTextPosition(point, series, {\n      width: elementRect.width,\n      height: elementRect.height\n    }, dataLabel, labelIndex);\n    var clipWidth = 0;\n    var clipHeight = 0;\n    var isOverlap = false;\n\n    if (isReactCallback) {\n      isOverlap = elementRect.width === 0 || elementRect.height === 0; // To check the data label already overlap before react callback call\n      // clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?\n      //     (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;\n      // clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;\n    }\n\n    childElement.style.left = (this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth + 'px';\n    childElement.style.top = (this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight + 'px';\n    var rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\n    var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\n    var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\n    childElement.style.color = dataLabel.font.color || (Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000) >= 128 ? 'black' : 'white');\n\n    if (childElement.childElementCount && !isOverlap && (!isCollide(rect, this.chart.dataLabelCollections, clip) || dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined || withIn(point.yValue, series.yAxis.visibleRange) || series.type.indexOf('Stacking') > -1 || series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange)) && withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y && parseFloat(childElement.style.left) >= hAxis.rect.x && parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height && parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\n      this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\n      appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\n\n      if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {\n        this.doDataLabelAnimation(series, childElement);\n      } else if (this.chart.enableCanvas) {\n        parentElement.appendChild(childElement);\n      }\n    }\n  };\n\n  DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\n    var labelRegion = labelIndex > 1 ? series.type === 'Candle' ? point.regions[1] : point.regions[0] : point.regions[0];\n\n    if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n      labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];\n    }\n\n    var location;\n    location = this.getLabelLocation(point, series, textSize, labelIndex);\n    var padding = 5;\n    var clipRect = series.clipRect; // calculating alignment\n\n    if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\n      this.locationX = location.x;\n      var alignmentValue = textSize.height + this.borderWidth * 2 + this.markerHeight + this.margin.bottom + this.margin.top + padding;\n      location.y = dataLabel.position === 'Auto' ? location.y : this.calculateAlignment(alignmentValue, location.y, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false); // calculating position\n\n      location.y = !this.isRectSeries(series) || series.type === 'BoxAndWhisker' ? this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) : this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n\n      if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\n        location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);\n      }\n    } else {\n      this.locationY = location.y;\n      var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\n      location.x = dataLabel.position === 'Auto' ? location.x : this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\n      location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\n    }\n\n    var rect = calculateRect(location, textSize, this.margin); // Checking the condition whether data Label has been exist the clip rect\n\n    if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) && !(rect.y > clipRect.y + clipRect.height || rect.x > clipRect.x + clipRect.width || rect.x + rect.width < 0 || rect.y + rect.height < 0)) {\n      rect.x = rect.x < 0 ? padding : rect.x;\n      rect.y = rect.y < 0 && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;\n      rect.x -= rect.x + rect.width > clipRect.x + clipRect.width ? rect.x + rect.width - (clipRect.x + clipRect.width) + padding : 0;\n      rect.y -= rect.y + rect.height > clipRect.y + clipRect.height ? rect.y + rect.height - (clipRect.y + clipRect.height) + padding : 0;\n      this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n    }\n\n    return rect;\n  }; // Calculation label location for polar column draw types\n\n\n  DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {\n    var padding = 5;\n    var columnRadius;\n    var chartWidth = this.chart.availableSize.width;\n    var alignmentSign = alignment === 'Center' ? 0 : alignment === 'Far' ? 1 : -1;\n    var angle = point.regionData.startAngle - 0.5 * Math.PI + (point.regionData.endAngle - point.regionData.startAngle) / 2;\n\n    if (labelIndex === 0) {\n      columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;\n    } else {\n      columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius : point.regionData.radius;\n    }\n\n    this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n\n    if (series.drawType.indexOf('Stacking') > -1) {\n      position = position === 'Outer' ? 'Top' : position;\n    } else if (series.drawType.indexOf('Range') > -1) {\n      position = position === 'Outer' || position === 'Top' ? position : 'Auto';\n    }\n\n    if (position === 'Outer') {\n      columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight : columnRadius - 2 * padding - this.markerHeight;\n    } else if (position === 'Middle') {\n      columnRadius = columnRadius / 2 + padding;\n\n      if (series.drawType === 'StackingColumn') {\n        columnRadius = point.regionData.innerRadius + (point.regionData.radius - point.regionData.innerRadius) / 2 + padding - size.height / 2;\n      }\n    } else if (position === 'Top') {\n      columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight : columnRadius + 2 * padding + this.markerHeight;\n    } else if (position === 'Bottom') {\n      columnRadius = 2 * padding;\n      columnRadius += series.drawType === 'StackingColumn' ? point.regionData.innerRadius + this.markerHeight : 0;\n    } else {\n      if (labelIndex === 0) {\n        columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding : series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\n      } else {\n        columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\n      }\n    }\n\n    columnRadius += alignmentValue * alignmentSign;\n    location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle); // To change x location based on text anchor for column and stackingcolumn chart\n\n    if (series.drawType === 'StackingColumn') {\n      location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 : location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x;\n    } else if (series.drawType === 'Column') {\n      location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 : location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x;\n    }\n\n    location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\n    return location;\n  };\n  /**\r\n   * Get the label location\r\n   */\n\n\n  DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\n    var location = new ChartLocation(0, 0);\n    var labelRegion = series.type === 'Candle' && labelIndex > 1 ? point.regions[1] : point.regions[0];\n\n    if (series.type === 'HiloOpenClose') {\n      labelRegion = labelIndex === 2 ? point.regions[1] : point.regions[2];\n    }\n\n    var xAxis = series.xAxis;\n    var yAxis = series.yAxis;\n    var isInverted = series.chart.requireInvertedAxis;\n\n    if (series.type === 'BoxAndWhisker') {\n      this.markerHeight = 0;\n\n      switch (labelIndex) {\n        case 0:\n          location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);\n          break;\n\n        case 1:\n          location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);\n          break;\n\n        case 2:\n          location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);\n          break;\n\n        case 3:\n          location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\n          break;\n\n        case 4:\n          location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\n          break;\n\n        default:\n          {\n            location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\n            this.markerHeight = series.marker.height / 2;\n            break;\n          }\n      }\n\n      if (isInverted) {\n        location.y = point.regions[0].y + point.regions[0].height / 2;\n      } else {\n        location.x = point.regions[0].x + point.regions[0].width / 2;\n      }\n    } else if (labelIndex === 0 || labelIndex === 1) {\n      location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\n    } else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\n      location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\n    } else if (isInverted) {\n      location = {\n        x: labelRegion.x + labelRegion.width / 2,\n        y: labelRegion.y\n      };\n    } else {\n      location = {\n        x: labelRegion.x + labelRegion.width,\n        y: labelRegion.y + labelRegion.height / 2\n      };\n    } //Aligning the label at the beginning of the tick, when tick size is less than text size\n\n\n    if (labelIndex > 1 && series.type === 'HiloOpenClose') {\n      if (series.chart.requireInvertedAxis) {\n        var height = labelRegion.height;\n        location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n      } else {\n        var width = labelRegion.width;\n        location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\n      }\n    }\n\n    return location;\n  };\n\n  DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\n    if (series.chart.chartAreaType === 'PolarRadar') {\n      return null;\n    }\n\n    var padding = 5;\n    var margin = this.margin;\n    var textLength = !this.inverted ? textSize.height : textSize.width;\n    var extraSpace = this.borderWidth + textLength / 2 + (position !== 'Outer' && series.type.indexOf('Column') > -1 && Math.abs(rect.height - textSize.height) < padding ? 0 : padding);\n\n    if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {\n      position = position === 'Outer' ? 'Top' : position;\n    } else if (series.type.indexOf('Range') > -1) {\n      position = position === 'Outer' || position === 'Top' ? position : 'Auto';\n    } else if (series.type === 'Waterfall') {\n      position = position === 'Auto' ? 'Middle' : position;\n    }\n\n    switch (position) {\n      case 'Bottom':\n        labelLocation = !this.inverted ? isMinus ? labelLocation - rect.height + extraSpace + margin.top : labelLocation + rect.height - extraSpace - margin.bottom : isMinus ? labelLocation + rect.width - extraSpace - margin.left : labelLocation - rect.width + extraSpace + margin.right;\n        break;\n\n      case 'Middle':\n        labelLocation = labelLocation = !this.inverted ? isMinus ? labelLocation - rect.height / 2 : labelLocation + rect.height / 2 : isMinus ? labelLocation + rect.width / 2 : labelLocation - rect.width / 2;\n        break;\n\n      case 'Auto':\n        labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\n        break;\n\n      default:\n        extraSpace += this.errorHeight;\n        labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, extraSpace, isMinus);\n        break;\n    }\n\n    var check = !this.inverted ? labelLocation < rect.y || labelLocation > rect.y + rect.height : labelLocation < rect.x || labelLocation > rect.x + rect.width;\n    this.fontBackground = check ? this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground : this.fontBackground === 'transparent' ? point.color || series.interior : this.fontBackground;\n    var seriesLength = series.chart.series.length;\n\n    if (position === 'Outer' && series.type.indexOf('Stacking') > -1 && seriesLength - 1 > series.index) {\n      var nextSeries = void 0;\n      var nextSeriesPoint = void 0;\n\n      for (var i = series.index + 1; i < seriesLength; i++) {\n        nextSeries = series.chart.series[i];\n        nextSeriesPoint = nextSeries.points[point.index];\n\n        if (nextSeries.type.indexOf('Stacking') > -1 && nextSeries.type.indexOf('100') === -1) {\n          this.fontBackground = nextSeriesPoint && (nextSeriesPoint.yValue < 0 && point.yValue < 0 || nextSeriesPoint.yValue > 0 && point.yValue > 0) ? nextSeriesPoint ? nextSeriesPoint.color : nextSeries.interior : this.fontBackground;\n          break;\n        }\n      }\n    }\n\n    return labelLocation;\n  };\n\n  DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\n    var padding = 5;\n\n    if (series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && series.type !== 'SplineRangeArea' && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\n      position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\n    }\n\n    this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\n\n    switch (position) {\n      case 'Top':\n      case 'Outer':\n        labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding - this.errorHeight;\n        break;\n\n      case 'Bottom':\n        labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding + this.errorHeight;\n        break;\n\n      case 'Auto':\n        labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\n        break;\n    }\n\n    return labelLocation;\n  };\n\n  DataLabel.prototype.isDataLabelShape = function (style) {\n    this.isShape = style.color !== 'transparent' || style.border.width > 0;\n    this.borderWidth = style.border.width;\n\n    if (!this.isShape) {\n      this.margin = {\n        left: 0,\n        right: 0,\n        bottom: 0,\n        top: 0\n      };\n    }\n  };\n\n  DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\n    var location;\n    var labelRect;\n    var isOverLap = true;\n    var position = 0;\n    var collection = this.chart.dataLabelCollections;\n    var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\n\n    while (isOverLap && position < finalPosition) {\n      var actualPosition = this.getPosition(position);\n\n      if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {\n        actualPosition = 'Top';\n        position++;\n      }\n\n      location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);\n\n      if (!this.inverted) {\n        labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);\n        isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\n      } else {\n        labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);\n        isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.x + labelRect.width > series.clipRect.width;\n      }\n\n      position++;\n    }\n\n    return location;\n  }; // alignment calculation assigned here\n\n\n  DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\n    switch (alignment) {\n      case 'Far':\n        labelLocation = !this.inverted ? isMinus ? labelLocation + value : labelLocation - value : isMinus ? labelLocation - value : labelLocation + value;\n        break;\n\n      case 'Near':\n        labelLocation = !this.inverted ? isMinus ? labelLocation - value : labelLocation + value : isMinus ? labelLocation + value : labelLocation - value;\n        break;\n      // eslint-disable-next-line no-self-assign\n\n      case 'Center':\n        labelLocation = labelLocation;\n        break;\n    }\n\n    return labelLocation;\n  }; //calculation for top and outer position of datalabel for rect series\n\n\n  DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus) {\n    var margin = this.margin;\n    var top;\n\n    switch (series.type) {\n      case 'RangeColumn':\n      case 'RangeArea':\n      case 'SplineRangeArea':\n      case 'Hilo':\n        top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;\n        location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n        break;\n\n      case 'Candle':\n        top = (index === 0 || index === 2) && !this.yAxisInversed || (index === 1 || index === 3) && this.yAxisInversed;\n        location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\n        break;\n\n      case 'HiloOpenClose':\n        if (index <= 1) {\n          top = index === 0 && !this.yAxisInversed || index === 1 && this.yAxisInversed;\n          location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\n        } else {\n          if (this.yAxisInversed) {\n            location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\n          } else {\n            location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\n          }\n        }\n\n        break;\n\n      default:\n        if (isMinus && position === 'Top' || !isMinus && position === 'Outer') {\n          location = !this.inverted ? location - extraSpace - margin.bottom - this.markerHeight : location + extraSpace + margin.left + this.markerHeight;\n        } else {\n          location = !this.inverted ? location + extraSpace + margin.top + this.markerHeight : location - extraSpace - margin.right - this.markerHeight;\n        }\n\n        break;\n    }\n\n    return location;\n  };\n  /**\r\n   * Updates the label location\r\n   */\n\n\n  DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\n    if (inside === void 0) {\n      inside = false;\n    }\n\n    if (!this.inverted) {\n      if (top) {\n        location = position === 'Outer' && !inside ? location - extraSpace - margin.bottom - this.markerHeight : location + extraSpace + margin.top + this.markerHeight;\n      } else {\n        location = position === 'Outer' && !inside ? location + rect.height + extraSpace + margin.top + this.markerHeight : location + rect.height - extraSpace - margin.bottom - this.markerHeight;\n      }\n    } else {\n      if (top) {\n        location = position === 'Outer' && !inside ? location + extraSpace + margin.left + this.markerHeight : location - extraSpace - margin.right - this.markerHeight;\n      } else {\n        location = position === 'Outer' && !inside ? location - rect.width - extraSpace - margin.right - this.markerHeight : location - rect.width + extraSpace + margin.left + this.markerHeight;\n      }\n    }\n\n    return location;\n  };\n\n  DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\n    var points = series.points;\n    var index = point.index;\n    var yValue = points[index].yValue;\n    var position;\n    var nextPoint = points.length - 1 > index ? points[index + 1] : null;\n    var previousPoint = index > 0 ? points[index - 1] : null;\n    var yLocation;\n    var isOverLap = true;\n    var labelRect;\n    var isBottom;\n    var positionIndex;\n    var collection = this.chart.dataLabelCollections;\n\n    if (series.type === 'Bubble') {\n      position = 'Top';\n    } else if (series.type.indexOf('Step') > -1) {\n      position = 'Top';\n\n      if (index) {\n        position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue !== this.yAxisInversed || yValue === previousPoint.yValue ? 'Top' : 'Bottom';\n      }\n    } else if (series.type === 'BoxAndWhisker') {\n      if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\n        position = series.yAxis.isAxisInverse ? 'Bottom' : 'Top';\n      } else if (labelIndex === 2 || labelIndex === 4) {\n        position = series.yAxis.isAxisInverse ? 'Top' : 'Bottom';\n      } else {\n        isOverLap = false;\n        position = 'Middle';\n        yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\n      }\n    } else {\n      if (index === 0) {\n        position = !nextPoint || !nextPoint.visible || yValue > nextPoint.yValue || yValue < nextPoint.yValue && this.yAxisInversed ? 'Top' : 'Bottom';\n      } else if (index === points.length - 1) {\n        position = !previousPoint || !previousPoint.visible || yValue > previousPoint.yValue || yValue < previousPoint.yValue && this.yAxisInversed ? 'Top' : 'Bottom';\n      } else {\n        if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\n          position = 'Top';\n        } else if (!nextPoint.visible || !previousPoint) {\n          position = nextPoint.yValue > yValue || previousPoint && previousPoint.yValue > yValue ? 'Bottom' : 'Top';\n        } else {\n          var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\n          var intersectY = slope * index + (nextPoint.yValue - slope * (index + 1));\n          position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' : intersectY < yValue ? 'Bottom' : 'Top';\n        }\n      }\n    }\n\n    isBottom = position === 'Bottom';\n    positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\n\n    while (isOverLap && positionIndex < 4) {\n      yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\n      labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);\n      isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y + labelRect.height > series.clipRect.height;\n      positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\n      isBottom = false;\n    }\n\n    return yLocation;\n  };\n  /**\r\n   * Animates the data label.\r\n   *\r\n   * @param  {Series} series - Data label of the series gets animated.\r\n   * @returns {void}\r\n   */\n\n\n  DataLabel.prototype.doDataLabelAnimation = function (series, element) {\n    var shapeElements = series.shapeElement.childNodes;\n    var textNode = series.textElement.childNodes;\n    var delay = series.animation.delay + series.animation.duration;\n    var duration = series.chart.animated ? series.chart.duration : 200;\n    var location;\n    var length = element ? 1 : textNode.length;\n    var tempElement;\n\n    for (var i = 0; i < length; i++) {\n      tempElement = textNode[i];\n\n      if (element) {\n        element.style.visibility = 'hidden';\n        templateAnimate(element, delay, duration, 'ZoomIn');\n      } else {\n        location = new ChartLocation(+tempElement.getAttribute('x') + +tempElement.getAttribute('width') / 2, +tempElement.getAttribute('y') + +tempElement.getAttribute('height') / 2);\n        markerAnimate(tempElement, delay, duration, series, null, location, true);\n\n        if (shapeElements[i]) {\n          tempElement = shapeElements[i];\n          location = new ChartLocation(+tempElement.getAttribute('x') + +tempElement.getAttribute('width') / 2, +tempElement.getAttribute('y') + +tempElement.getAttribute('height') / 2);\n          markerAnimate(tempElement, delay, duration, series, null, location, true);\n        }\n      }\n    }\n  };\n\n  DataLabel.prototype.getPosition = function (index) {\n    return ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index];\n  };\n  /**\r\n   * Get module name.\r\n   */\n\n\n  DataLabel.prototype.getModuleName = function () {\n    // Returns the module name\n    return 'DataLabel';\n  };\n  /**\r\n   * To destroy the dataLabel for series.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  DataLabel.prototype.destroy = function () {// Destroy method performed here\n  };\n\n  return DataLabel;\n}();\n\nexport { DataLabel };","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/chart/series/data-label.js"],"names":["ChartLocation","RectOption","isCollide","isOverlap","markerAnimate","appendChildElement","getVisiblePoints","getLabelText","convertHexToColor","calculateRect","textElement","colorNameToHex","measureText","TextOption","Rect","textRender","createTemplate","getFontStyle","getElement","measureElementRect","templateAnimate","withIn","withInBounds","createElement","getValue","extend","getPoint","getRotatedRectangleCoordinates","isRotatedRectIntersect","DataLabel","chart","errorHeight","prototype","initPrivateVariables","series","marker","transform","clipPath","render","renderer","index","undefined","category","chartAreaType","clipRect","x","y","element","id","dataLabel","visible","shapeElement","createGroup","markerHeight","type","height","commonId","calculateErrorHeight","position","chartBackground","chartArea","background","themeStyle","errorBar","direction","positiveHeight","errorBarModule","negativeHeight","isRectSeries","isTransposed","rect","labelLocation","rgbValue","contrast","argsData","border","textSize","angle","degree","inverted","requireInvertedAxis","yAxisInversed","yAxis","isAxisInverse","redraw","isDataLabelOverlap","coordinatesAfterRotation","templateId","visiblePoints","point","rectCenterX","rectCenterY","i","length","showZero","emptyPointSettings","mode","margin","labelText","labelLength","xPos","yPos","xValue","yValue","isRender","clip","shapeRect","width","color","argsFont","font","symbolLocations","regions","i_1","cancel","name","text","fill","template","location","trigger","fontBackground","isDataLabelShape","createDataLabelTemplate","calculateTextPosition","_i","_a","chartAxisLayoutPanel","visibleAxisLabelRect","rectRegion","actualRect","enableRotation","rectCoordinates","getRectanglePoints","isDataLabelOverlapWithChartBound","rotatedDataLabelCollections","push","currentPointIndex","dataLabelCollections","labelIntersectAction","isShape","drawRectangle","opacity","rx","ry","Int32Array","appendChild","Math","round","r","g","b","left","top","duration","enableCanvas","childElementCount","loc1","loc2","loc3","loc4","initialClipRect","parentElement","data","labelIndex","right","bottom","childElement","styles","calculateTemplateLabelSize","isReactCallback","elementRect","clipWidth","clipHeight","style","vAxis","xAxis","hAxis","seriesType","visibleRange","indexOf","stackedValues","endValues","parseFloat","animation","enable","animateSeries","doDataLabelAnimation","labelRegion","getLabelLocation","padding","locationX","alignmentValue","borderWidth","calculateAlignment","alignment","calculatePathPosition","calculateRectPosition","calculatePolarRectPosition","locationY","size","columnRadius","chartWidth","availableSize","alignmentSign","regionData","startAngle","PI","endAngle","radius","innerRadius","drawType","cos","sin","isInverted","median","maximum","minimum","upperQuartile","lowerQuartile","outliers","isMinus","textLength","extraSpace","abs","calculateRectActualPosition","calculateTopAndOuterPosition","check","interior","seriesLength","nextSeries","nextSeriesPoint","points","calculatePathActualPosition","labelRect","isOverLap","collection","finalPosition","actualPosition","getPosition","value","updateLabelLocation","inside","markerSize","nextPoint","previousPoint","yLocation","isBottom","positionIndex","slope","intersectY","shapeElements","childNodes","textNode","delay","animated","tempElement","visibility","getAttribute","getModuleName","destroy"],"mappings":"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","sourcesContent":["/* eslint-disable jsdoc/require-returns */\r\n/* eslint-disable valid-jsdoc */\r\n/* eslint-disable jsdoc/require-param */\r\n/* eslint-disable @typescript-eslint/no-inferrable-types */\r\nimport { ChartLocation, RectOption, isCollide, isOverlap } from '../../common/utils/helper';\r\nimport { markerAnimate, appendChildElement, getVisiblePoints } from '../../common/utils/helper';\r\nimport { getLabelText, convertHexToColor, calculateRect, textElement, colorNameToHex } from '../../common/utils/helper';\r\nimport { measureText, TextOption, Rect } from '@syncfusion/ej2-svg-base';\r\nimport { textRender } from '../../common/model/constants';\r\nimport { createTemplate, getFontStyle, getElement, measureElementRect, templateAnimate, withIn, withInBounds } from '../../common/utils/helper';\r\nimport { createElement, getValue, extend } from '@syncfusion/ej2-base';\r\nimport { getPoint, getRotatedRectangleCoordinates, isRotatedRectIntersect } from '../../common/utils/helper';\r\n/**\r\n * `DataLabel` module is used to render data label for the data point.\r\n */\r\nvar DataLabel = /** @class */ (function () {\r\n    /**\r\n     * Constructor for the data label module.\r\n     *\r\n     * @private\r\n     */\r\n    function DataLabel(chart) {\r\n        this.errorHeight = 0;\r\n        this.chart = chart;\r\n    }\r\n    DataLabel.prototype.initPrivateVariables = function (series, marker) {\r\n        var transform = '';\r\n        var clipPath = '';\r\n        var render = series.chart.renderer;\r\n        var index = (series.index === undefined) ? series.category : series.index;\r\n        if (series.chart.chartAreaType === 'Cartesian') {\r\n            transform = 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')';\r\n            clipPath = 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')';\r\n        }\r\n        if (marker.dataLabel.visible) {\r\n            series.shapeElement = render.createGroup({\r\n                'id': this.chart.element.id + 'ShapeGroup' + index,\r\n                'transform': transform,\r\n                'clip-path': 'url(#' + this.chart.element.id + '_ChartSeriesClipRect_' + index + ')'\r\n            });\r\n            series.textElement = render.createGroup({\r\n                'id': this.chart.element.id + 'TextGroup' + index,\r\n                'transform': transform,\r\n                'clip-path': clipPath\r\n            });\r\n        }\r\n        this.markerHeight = ((series.type === 'Scatter' || marker.visible)) ? (marker.height / 2) : 0;\r\n        this.commonId = this.chart.element.id + '_Series_' + index + '_Point_';\r\n        this.calculateErrorHeight(series, series.marker.dataLabel.position);\r\n        this.chartBackground = this.chart.chartArea.background === 'transparent' ?\r\n            this.chart.background || this.chart.themeStyle.background : this.chart.chartArea.background;\r\n    };\r\n    DataLabel.prototype.calculateErrorHeight = function (series, position) {\r\n        if (!series.errorBar.visible) {\r\n            return null;\r\n        }\r\n        else if (series.errorBar.visible && this.chart.chartAreaType !== 'PolarRadar') {\r\n            var direction = series.errorBar.direction;\r\n            var positiveHeight = this.chart.errorBarModule.positiveHeight;\r\n            var negativeHeight = this.chart.errorBarModule.negativeHeight;\r\n            if (this.isRectSeries(series)) {\r\n                if (position === 'Top' || position === 'Auto') {\r\n                    if (direction === 'Both' || direction === 'Minus') {\r\n                        this.errorHeight = negativeHeight;\r\n                    }\r\n                    else {\r\n                        this.errorHeight = 0;\r\n                    }\r\n                }\r\n                if (position === 'Outer' || position === 'Auto') {\r\n                    if (direction === 'Both' || direction === 'Plus') {\r\n                        this.errorHeight = positiveHeight;\r\n                    }\r\n                    else {\r\n                        this.errorHeight = 0;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (position === 'Top' || position === 'Outer' || position === 'Auto') {\r\n                    if ((direction === 'Both' || direction === 'Plus') && (!series.chart.isTransposed)) {\r\n                        this.errorHeight = positiveHeight;\r\n                    }\r\n                    else {\r\n                        this.errorHeight = 0;\r\n                    }\r\n                }\r\n                if (position === 'Bottom' || position === 'Auto') {\r\n                    if (direction === 'Both' || direction === 'Minus') {\r\n                        this.errorHeight = negativeHeight;\r\n                    }\r\n                    else {\r\n                        this.errorHeight = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.errorHeight = 0;\r\n        }\r\n    };\r\n    DataLabel.prototype.isRectSeries = function (series) {\r\n        return series.isRectSeries || series.type === 'RangeArea' || series.type === 'SplineRangeArea';\r\n    };\r\n    /**\r\n     * Render the data label for series.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    DataLabel.prototype.render = function (series, chart, dataLabel) {\r\n        // initialize the private variable\r\n        this.initPrivateVariables(series, series.marker);\r\n        var rect;\r\n        var labelLocation = { x: 0, y: 0 };\r\n        var rgbValue;\r\n        var contrast;\r\n        var argsData;\r\n        var border;\r\n        var textSize;\r\n        var angle;\r\n        var degree;\r\n        this.inverted = chart.requireInvertedAxis;\r\n        this.yAxisInversed = series.yAxis.isAxisInverse;\r\n        var redraw = chart.redraw;\r\n        var isDataLabelOverlap = false;\r\n        var coordinatesAfterRotation = [];\r\n        var templateId = chart.element.id + '_Series_' +\r\n            (series.index === undefined ? series.category : series.index) + '_DataLabelCollections';\r\n        var element = createElement('div', {\r\n            id: templateId\r\n        });\r\n        var visiblePoints = getVisiblePoints(series);\r\n        var point;\r\n        var rectCenterX;\r\n        var rectCenterY;\r\n        // Data label point iteration started\r\n        for (var i = 0; i < visiblePoints.length; i++) {\r\n            point = visiblePoints[i];\r\n            if (!dataLabel.showZero && ((point.y !== 0) || (point.y === 0 && series.emptyPointSettings.mode === 'Zero'))) {\r\n                return null;\r\n            }\r\n            this.margin = dataLabel.margin;\r\n            var labelText = [];\r\n            var labelLength = void 0;\r\n            var xPos = void 0;\r\n            var yPos = void 0;\r\n            var xValue = void 0;\r\n            var yValue = void 0;\r\n            var isRender = true;\r\n            var clip = series.clipRect;\r\n            var shapeRect = void 0;\r\n            isDataLabelOverlap = false;\r\n            angle = degree = dataLabel.angle;\r\n            border = { width: dataLabel.border.width, color: dataLabel.border.color };\r\n            var argsFont = (extend({}, getValue('properties', dataLabel.font), null, true));\r\n            if ((point.symbolLocations.length && point.symbolLocations[0]) ||\r\n                (series.type === 'BoxAndWhisker' && point.regions.length)) {\r\n                labelText = getLabelText(point, series, chart);\r\n                labelLength = labelText.length;\r\n                for (var i_1 = 0; i_1 < labelLength; i_1++) {\r\n                    argsData = {\r\n                        cancel: false, name: textRender, series: series,\r\n                        point: point, text: labelText[i_1], border: border,\r\n                        color: dataLabel.fill, template: dataLabel.template, font: argsFont, location: labelLocation,\r\n                        textSize: measureText(labelText[i_1], dataLabel.font)\r\n                    };\r\n                    chart.trigger(textRender, argsData);\r\n                    if (!argsData.cancel) {\r\n                        this.fontBackground = argsData.color;\r\n                        this.isDataLabelShape(argsData);\r\n                        this.markerHeight = series.type === 'Bubble' ? (point.regions[0].height / 2) : this.markerHeight;\r\n                        if (argsData.template !== null) {\r\n                            this.createDataLabelTemplate(element, series, dataLabel, point, argsData, i_1, redraw);\r\n                        }\r\n                        else {\r\n                            textSize = measureText(argsData.text, dataLabel.font);\r\n                            rect = this.calculateTextPosition(point, series, textSize, dataLabel, i_1);\r\n                            // To check whether the polar radar chart datalabel intersects the axis label or not\r\n                            if (chart.chartAreaType === 'PolarRadar') {\r\n                                for (var _i = 0, _a = chart.chartAxisLayoutPanel.visibleAxisLabelRect; _i < _a.length; _i++) {\r\n                                    var rectRegion = _a[_i];\r\n                                    if (isOverlap(new Rect(rect.x, rect.y, rect.width, rect.height), rectRegion)) {\r\n                                        isRender = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            var actualRect = new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height);\r\n                            //let notOverlapping: boolean;\r\n                            if (dataLabel.enableRotation) {\r\n                                var rectCoordinates = this.getRectanglePoints(rect);\r\n                                rectCenterX = rect.x + (rect.width / 2);\r\n                                rectCenterY = (rect.y + (rect.height / 2));\r\n                                coordinatesAfterRotation = getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle);\r\n                                isDataLabelOverlap = this.isDataLabelOverlapWithChartBound(coordinatesAfterRotation, chart, clip);\r\n                                if (!isDataLabelOverlap) {\r\n                                    this.chart.rotatedDataLabelCollections.push(coordinatesAfterRotation);\r\n                                    var currentPointIndex = this.chart.rotatedDataLabelCollections.length - 1;\r\n                                    for (var index = currentPointIndex; index >= 0; index--) {\r\n                                        if (this.chart.rotatedDataLabelCollections[currentPointIndex] &&\r\n                                            this.chart.rotatedDataLabelCollections[index - 1] &&\r\n                                            isRotatedRectIntersect(this.chart.rotatedDataLabelCollections[currentPointIndex], this.chart.rotatedDataLabelCollections[index - 1])) {\r\n                                            isDataLabelOverlap = true;\r\n                                            this.chart.rotatedDataLabelCollections[currentPointIndex] = null;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                isDataLabelOverlap = isCollide(rect, chart.dataLabelCollections, clip);\r\n                            }\r\n                            if ((!isDataLabelOverlap || dataLabel.labelIntersectAction === 'None') && isRender) {\r\n                                chart.dataLabelCollections.push(actualRect);\r\n                                if (this.isShape) {\r\n                                    shapeRect = chart.renderer.drawRectangle(new RectOption(this.commonId + point.index + '_TextShape_' + i_1, argsData.color, argsData.border, dataLabel.opacity, rect, dataLabel.rx, dataLabel.ry), new Int32Array([clip.x, clip.y]));\r\n                                    if (series.shapeElement) {\r\n                                        series.shapeElement.appendChild(shapeRect);\r\n                                    }\r\n                                }\r\n                                // Checking the font color\r\n                                rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\r\n                                contrast = Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000);\r\n                                xPos = (rect.x + this.margin.left + textSize.width / 2) + labelLocation.x;\r\n                                yPos = (rect.y + this.margin.top + textSize.height * 3 / 4) + labelLocation.y;\r\n                                labelLocation = { x: 0, y: 0 };\r\n                                if (angle !== 0 && dataLabel.enableRotation) {\r\n                                    // xValue = xPos - (dataLabel.margin.left) / 2 + (dataLabel.margin.right / 2);\r\n                                    xValue = rectCenterX;\r\n                                    //yValue = yPos - (dataLabel.margin.top) / 2 - (textSize.height / dataLabel.margin.top) +\r\n                                    // (dataLabel.margin.bottom) / 2;\r\n                                    yValue = rectCenterY;\r\n                                    degree = (angle > 360) ? angle - 360 : (angle < -360) ? angle + 360 : angle;\r\n                                }\r\n                                else {\r\n                                    degree = 0;\r\n                                    xValue = rect.x;\r\n                                    yValue = rect.y;\r\n                                }\r\n                                textElement(chart.renderer, new TextOption(this.commonId + point.index + '_Text_' + i_1, xPos, yPos, 'middle', argsData.text, 'rotate(' + degree + ',' + (xValue) + ',' + (yValue) + ')', 'auto', degree), argsData.font, argsData.font.color ||\r\n                                    ((contrast >= 128 || series.type === 'Hilo') ? 'black' : 'white'), series.textElement, false, redraw, true, false, series.chart.duration, series.clipRect, null, null, chart.enableCanvas);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (element.childElementCount) {\r\n            if (!chart.enableCanvas) {\r\n                appendChildElement(chart.enableCanvas, getElement(chart.element.id + '_Secondary_Element'), element, chart.redraw, \r\n                // eslint-disable-next-line @typescript-eslint/indent\r\n                false, 'x', 'y', null, '', false, false, null, chart.duration);\r\n            }\r\n            else {\r\n                getElement(chart.element.id + '_Secondary_Element').appendChild(element);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Get rect coordinates\r\n     */\r\n    DataLabel.prototype.getRectanglePoints = function (rect) {\r\n        var loc1 = new ChartLocation(rect.x, rect.y);\r\n        var loc2 = new ChartLocation(rect.x + rect.width, rect.y);\r\n        var loc3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\r\n        var loc4 = new ChartLocation(rect.x, rect.y + rect.height);\r\n        return [loc1, loc2, loc3, loc4];\r\n    };\r\n    DataLabel.prototype.isDataLabelOverlapWithChartBound = function (rectCoordinates, chart, clip) {\r\n        for (var index = 0; index < rectCoordinates.length; index++) {\r\n            if (!withInBounds(rectCoordinates[index].x + clip.x, rectCoordinates[index].y + clip.y, chart.initialClipRect)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Render the data label template.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    DataLabel.prototype.createDataLabelTemplate = function (parentElement, series, dataLabel, point, data, labelIndex, redraw) {\r\n        this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\r\n        var clip = series.clipRect;\r\n        var childElement = createTemplate(createElement('div', {\r\n            id: this.chart.element.id + '_Series_' + (series.index === undefined ? series.category : series.index) + '_DataLabel_'\r\n                + point.index + (labelIndex ? ('_' + labelIndex) : ''),\r\n            styles: 'position: absolute;background-color:' + data.color + ';' +\r\n                getFontStyle(dataLabel.font) + ';border:' + data.border.width + 'px solid ' + data.border.color + ';'\r\n        }), point.index, data.template, this.chart, point, series, this.chart.element.id + '_DataLabel', labelIndex);\r\n        this.calculateTemplateLabelSize(parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw);\r\n    };\r\n    DataLabel.prototype.calculateTemplateLabelSize = function (parentElement, childElement, point, series, dataLabel, labelIndex, clip, redraw, isReactCallback) {\r\n        var elementRect = measureElementRect(childElement, redraw, isReactCallback);\r\n        var rect = this.calculateTextPosition(point, series, { width: elementRect.width, height: elementRect.height }, dataLabel, labelIndex);\r\n        var clipWidth = 0;\r\n        var clipHeight = 0;\r\n        var isOverlap = false;\r\n        if (isReactCallback) {\r\n            isOverlap = (elementRect.width === 0 || elementRect.height === 0); // To check the data label already overlap before react callback call\r\n            // clipWidth = ((series.clipRect.x + rect.x) + elementRect.width) > parentElement.clientWidth ?\r\n            //     (parentElement.clientWidth - (series.clipRect.x + rect.x)) : 0;\r\n            // clipHeight = (series.points.length - 1 === point.index) ? elementRect.height / 2 : 0;\r\n        }\r\n        childElement.style.left = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.x) + rect.x - clipWidth) + 'px';\r\n        childElement.style.top = ((this.chart.chartAreaType === 'PolarRadar' ? 0 : series.clipRect.y) + rect.y + clipHeight) + 'px';\r\n        var rgbValue = convertHexToColor(colorNameToHex(this.fontBackground));\r\n        var vAxis = series.chart.requireInvertedAxis ? series.xAxis : series.yAxis;\r\n        var hAxis = series.chart.requireInvertedAxis ? series.yAxis : series.xAxis;\r\n        childElement.style.color = dataLabel.font.color ||\r\n            ((Math.round((rgbValue.r * 299 + rgbValue.g * 587 + rgbValue.b * 114) / 1000)) >= 128 ? 'black' : 'white');\r\n        if (childElement.childElementCount && !isOverlap && (!isCollide(rect, this.chart.dataLabelCollections, clip) ||\r\n            dataLabel.labelIntersectAction === 'None') && (series.seriesType !== 'XY' || point.yValue === undefined ||\r\n            withIn(point.yValue, series.yAxis.visibleRange) || (series.type.indexOf('Stacking') > -1) ||\r\n            (series.type.indexOf('100') > -1 && withIn(series.stackedValues.endValues[point.index], series.yAxis.visibleRange))) &&\r\n            withIn(point.xValue, series.xAxis.visibleRange) && parseFloat(childElement.style.top) >= vAxis.rect.y &&\r\n            parseFloat(childElement.style.left) >= hAxis.rect.x &&\r\n            parseFloat(childElement.style.top) <= vAxis.rect.y + vAxis.rect.height &&\r\n            parseFloat(childElement.style.left) <= hAxis.rect.x + hAxis.rect.width) {\r\n            this.chart.dataLabelCollections.push(new Rect(rect.x + clip.x, rect.y + clip.y, rect.width, rect.height));\r\n            appendChildElement(this.chart.enableCanvas, parentElement, childElement, redraw, true, 'left', 'top');\r\n            if (series.animation.enable && this.chart.animateSeries && !this.chart.enableCanvas) {\r\n                this.doDataLabelAnimation(series, childElement);\r\n            }\r\n            else if (this.chart.enableCanvas) {\r\n                parentElement.appendChild(childElement);\r\n            }\r\n        }\r\n    };\r\n    DataLabel.prototype.calculateTextPosition = function (point, series, textSize, dataLabel, labelIndex) {\r\n        var labelRegion = labelIndex > 1 ? (series.type === 'Candle') ? point.regions[1] : point.regions[0] : point.regions[0];\r\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\r\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\r\n        }\r\n        var location;\r\n        location = this.getLabelLocation(point, series, textSize, labelIndex);\r\n        var padding = 5;\r\n        var clipRect = series.clipRect;\r\n        // calculating alignment\r\n        if (!this.chart.requireInvertedAxis || !this.isRectSeries(series) || series.type === 'BoxAndWhisker') {\r\n            this.locationX = location.x;\r\n            var alignmentValue = textSize.height + (this.borderWidth * 2) + this.markerHeight +\r\n                this.margin.bottom + this.margin.top + padding;\r\n            location.y = (dataLabel.position === 'Auto') ? location.y :\r\n                this.calculateAlignment(alignmentValue, location.y, dataLabel.alignment, this.isRectSeries(series) ? point.yValue < 0 : false);\r\n            // calculating position\r\n            location.y = (!this.isRectSeries(series) || series.type === 'BoxAndWhisker') ?\r\n                this.calculatePathPosition(location.y, dataLabel.position, series, point, textSize, labelIndex) :\r\n                this.calculateRectPosition(location.y, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\r\n            if (this.isRectSeries(series) && this.chart.chartAreaType === 'PolarRadar') {\r\n                location = this.calculatePolarRectPosition(location, dataLabel.position, series, point, textSize, labelIndex, dataLabel.alignment, alignmentValue);\r\n            }\r\n        }\r\n        else {\r\n            this.locationY = location.y;\r\n            var alignmentValue = textSize.width + this.borderWidth + this.margin.left + this.margin.right - padding;\r\n            location.x = dataLabel.position === 'Auto' ? location.x :\r\n                this.calculateAlignment(alignmentValue, location.x, dataLabel.alignment, point.yValue < 0);\r\n            location.x = this.calculateRectPosition(location.x, labelRegion, point.yValue < 0 !== this.yAxisInversed, dataLabel.position, series, textSize, labelIndex, point);\r\n        }\r\n        var rect = calculateRect(location, textSize, this.margin);\r\n        // Checking the condition whether data Label has been exist the clip rect\r\n        if (!(dataLabel.enableRotation === true && dataLabel.angle !== 0) &&\r\n            !((rect.y > (clipRect.y + clipRect.height)) || (rect.x > (clipRect.x + clipRect.width)) ||\r\n                (rect.x + rect.width < 0) || (rect.y + rect.height < 0))) {\r\n            rect.x = rect.x < 0 ? padding : rect.x;\r\n            rect.y = (rect.y < 0) && !(dataLabel.labelIntersectAction === 'None') ? padding : rect.y;\r\n            rect.x -= (rect.x + rect.width) > (clipRect.x + clipRect.width) ? (rect.x + rect.width)\r\n                - (clipRect.x + clipRect.width) + padding : 0;\r\n            rect.y -= (rect.y + rect.height) > (clipRect.y + clipRect.height) ? (rect.y + rect.height)\r\n                - (clipRect.y + clipRect.height) + padding : 0;\r\n            this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\r\n        }\r\n        return rect;\r\n    };\r\n    // Calculation label location for polar column draw types\r\n    DataLabel.prototype.calculatePolarRectPosition = function (location, position, series, point, size, labelIndex, alignment, alignmentValue) {\r\n        var padding = 5;\r\n        var columnRadius;\r\n        var chartWidth = this.chart.availableSize.width;\r\n        var alignmentSign = (alignment === 'Center') ? 0 : (alignment === 'Far' ? 1 : -1);\r\n        var angle = (point.regionData.startAngle - 0.5 * Math.PI) + (point.regionData.endAngle - point.regionData.startAngle) / 2;\r\n        if (labelIndex === 0) {\r\n            columnRadius = point.regionData.radius < point.regionData.innerRadius ? point.regionData.innerRadius\r\n                : point.regionData.radius;\r\n        }\r\n        else {\r\n            columnRadius = point.regionData.radius > point.regionData.innerRadius ? point.regionData.innerRadius\r\n                : point.regionData.radius;\r\n        }\r\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\r\n        if (series.drawType.indexOf('Stacking') > -1) {\r\n            position = position === 'Outer' ? 'Top' : position;\r\n        }\r\n        else if (series.drawType.indexOf('Range') > -1) {\r\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\r\n        }\r\n        if (position === 'Outer') {\r\n            columnRadius = labelIndex === 0 ? columnRadius + 2 * padding + this.markerHeight :\r\n                columnRadius - 2 * padding - this.markerHeight;\r\n        }\r\n        else if (position === 'Middle') {\r\n            columnRadius = columnRadius / 2 + padding;\r\n            if (series.drawType === 'StackingColumn') {\r\n                columnRadius = point.regionData.innerRadius + ((point.regionData.radius - point.regionData.innerRadius) / 2)\r\n                    + padding - (size.height / 2);\r\n            }\r\n        }\r\n        else if (position === 'Top') {\r\n            columnRadius = labelIndex === 0 ? columnRadius - 2 * padding - this.markerHeight :\r\n                columnRadius + 2 * padding + this.markerHeight;\r\n        }\r\n        else if (position === 'Bottom') {\r\n            columnRadius = 2 * padding;\r\n            columnRadius += (series.drawType === 'StackingColumn') ? (point.regionData.innerRadius + this.markerHeight) : 0;\r\n        }\r\n        else {\r\n            if (labelIndex === 0) {\r\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius - padding :\r\n                    series.drawType === 'StackingColumn' ? columnRadius - 2 * padding : columnRadius + 2 * padding;\r\n            }\r\n            else {\r\n                columnRadius = columnRadius >= series.chart.radius ? columnRadius + padding : columnRadius - 2 * padding;\r\n            }\r\n        }\r\n        columnRadius += (alignmentValue * alignmentSign);\r\n        location.x = series.clipRect.width / 2 + series.clipRect.x + columnRadius * Math.cos(angle);\r\n        // To change x location based on text anchor for column and stackingcolumn chart\r\n        if (series.drawType === 'StackingColumn') {\r\n            location.x = location.x < chartWidth / 2 ? location.x + size.width / 2 :\r\n                (location.x > chartWidth / 2 ? location.x - size.width / 2 : location.x);\r\n        }\r\n        else if (series.drawType === 'Column') {\r\n            location.x = location.x < chartWidth / 2 ? location.x - size.width / 2 :\r\n                (location.x > chartWidth / 2 ? location.x + size.width / 2 : location.x);\r\n        }\r\n        location.y = series.clipRect.height / 2 + series.clipRect.y + columnRadius * Math.sin(angle);\r\n        return location;\r\n    };\r\n    /**\r\n     * Get the label location\r\n     */\r\n    DataLabel.prototype.getLabelLocation = function (point, series, textSize, labelIndex) {\r\n        var location = new ChartLocation(0, 0);\r\n        var labelRegion = (series.type === 'Candle' && labelIndex > 1) ? point.regions[1] : point.regions[0];\r\n        if (series.type === 'HiloOpenClose') {\r\n            labelRegion = (labelIndex === 2) ? point.regions[1] : point.regions[2];\r\n        }\r\n        var xAxis = series.xAxis;\r\n        var yAxis = series.yAxis;\r\n        var isInverted = series.chart.requireInvertedAxis;\r\n        if (series.type === 'BoxAndWhisker') {\r\n            this.markerHeight = 0;\r\n            switch (labelIndex) {\r\n                case 0:\r\n                    location = getPoint(point.xValue, point.median, xAxis, yAxis, isInverted);\r\n                    break;\r\n                case 1:\r\n                    location = getPoint(point.xValue, point.maximum, xAxis, yAxis, isInverted);\r\n                    break;\r\n                case 2:\r\n                    location = getPoint(point.xValue, point.minimum, xAxis, yAxis, isInverted);\r\n                    break;\r\n                case 3:\r\n                    location = getPoint(point.xValue, point.upperQuartile, xAxis, yAxis, isInverted);\r\n                    break;\r\n                case 4:\r\n                    location = getPoint(point.xValue, point.lowerQuartile, xAxis, yAxis, isInverted);\r\n                    break;\r\n                default: {\r\n                    location = getPoint(point.xValue, point.outliers[labelIndex - 5], xAxis, yAxis, isInverted);\r\n                    this.markerHeight = series.marker.height / 2;\r\n                    break;\r\n                }\r\n            }\r\n            if (isInverted) {\r\n                location.y = point.regions[0].y + (point.regions[0].height / 2);\r\n            }\r\n            else {\r\n                location.x = point.regions[0].x + (point.regions[0].width / 2);\r\n            }\r\n        }\r\n        else if (labelIndex === 0 || labelIndex === 1) {\r\n            location = new ChartLocation(point.symbolLocations[0].x, point.symbolLocations[0].y);\r\n        }\r\n        else if ((labelIndex === 2 || labelIndex === 3) && series.type === 'Candle') {\r\n            location = new ChartLocation(point.symbolLocations[1].x, point.symbolLocations[1].y);\r\n        }\r\n        else if (isInverted) {\r\n            location = { x: labelRegion.x + (labelRegion.width) / 2, y: labelRegion.y };\r\n        }\r\n        else {\r\n            location = { x: labelRegion.x + labelRegion.width, y: labelRegion.y + (labelRegion.height) / 2 };\r\n        }\r\n        //Aligning the label at the beginning of the tick, when tick size is less than text size\r\n        if (labelIndex > 1 && series.type === 'HiloOpenClose') {\r\n            if (series.chart.requireInvertedAxis) {\r\n                var height = labelRegion.height;\r\n                location.y = labelRegion.y + height / 2 + 2 * (labelIndex === 2 ? 1 : -1);\r\n            }\r\n            else {\r\n                var width = labelRegion.width;\r\n                location.x = labelRegion.x + width / 2 + 2 * (labelIndex === 2 ? 1 : -1);\r\n            }\r\n        }\r\n        return location;\r\n    };\r\n    DataLabel.prototype.calculateRectPosition = function (labelLocation, rect, isMinus, position, series, textSize, labelIndex, point) {\r\n        if (series.chart.chartAreaType === 'PolarRadar') {\r\n            return null;\r\n        }\r\n        var padding = 5;\r\n        var margin = this.margin;\r\n        var textLength = !this.inverted ? textSize.height : textSize.width;\r\n        var extraSpace = this.borderWidth + textLength / 2 + (position !== 'Outer' && series.type.indexOf('Column') > -1 &&\r\n            (Math.abs(rect.height - textSize.height) < padding) ? 0 : padding);\r\n        if (series.type === 'StackingColumn100' || series.type === 'StackingBar100') {\r\n            position = (position === 'Outer') ? 'Top' : position;\r\n        }\r\n        else if (series.type.indexOf('Range') > -1) {\r\n            position = (position === 'Outer' || position === 'Top') ? position : 'Auto';\r\n        }\r\n        else if (series.type === 'Waterfall') {\r\n            position = position === 'Auto' ? 'Middle' : position;\r\n        }\r\n        switch (position) {\r\n            case 'Bottom':\r\n                labelLocation = !this.inverted ?\r\n                    isMinus ? (labelLocation - rect.height + extraSpace + margin.top) :\r\n                        (labelLocation + rect.height - extraSpace - margin.bottom) :\r\n                    isMinus ? (labelLocation + rect.width - extraSpace - margin.left) :\r\n                        (labelLocation - rect.width + extraSpace + margin.right);\r\n                break;\r\n            case 'Middle':\r\n                labelLocation = labelLocation = !this.inverted ?\r\n                    (isMinus ? labelLocation - (rect.height / 2) : labelLocation + (rect.height / 2)) :\r\n                    (isMinus ? labelLocation + (rect.width / 2) : labelLocation - (rect.width / 2));\r\n                break;\r\n            case 'Auto':\r\n                labelLocation = this.calculateRectActualPosition(labelLocation, rect, isMinus, series, textSize, labelIndex, point);\r\n                break;\r\n            default:\r\n                extraSpace += this.errorHeight;\r\n                labelLocation = this.calculateTopAndOuterPosition(labelLocation, rect, position, series, labelIndex, extraSpace, isMinus);\r\n                break;\r\n        }\r\n        var check = !this.inverted ? (labelLocation < rect.y || labelLocation > rect.y + rect.height) :\r\n            (labelLocation < rect.x || labelLocation > rect.x + rect.width);\r\n        this.fontBackground = check ?\r\n            (this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground)\r\n            : this.fontBackground === 'transparent' ? (point.color || series.interior) : this.fontBackground;\r\n        var seriesLength = series.chart.series.length;\r\n        if (position === 'Outer' && (series.type.indexOf('Stacking') > -1) && ((seriesLength - 1) > series.index)) {\r\n            var nextSeries = void 0;\r\n            var nextSeriesPoint = void 0;\r\n            for (var i = series.index + 1; i < seriesLength; i++) {\r\n                nextSeries = series.chart.series[i];\r\n                nextSeriesPoint = nextSeries.points[point.index];\r\n                if ((nextSeries.type.indexOf('Stacking') > -1) && (nextSeries.type.indexOf('100') === -1)) {\r\n                    this.fontBackground = (nextSeriesPoint && ((nextSeriesPoint.yValue < 0 && point.yValue < 0) ||\r\n                        (nextSeriesPoint.yValue > 0 && point.yValue > 0))) ? (nextSeriesPoint ? nextSeriesPoint.color :\r\n                        nextSeries.interior) : this.fontBackground;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return labelLocation;\r\n    };\r\n    DataLabel.prototype.calculatePathPosition = function (labelLocation, position, series, point, size, labelIndex) {\r\n        var padding = 5;\r\n        if ((series.type.indexOf('Area') > -1 && series.type !== 'RangeArea' && series.type !== 'SplineRangeArea')\r\n            && this.yAxisInversed && series.marker.dataLabel.position !== 'Auto') {\r\n            position = position === 'Top' ? 'Bottom' : position === 'Bottom' ? 'Top' : position;\r\n        }\r\n        this.fontBackground = this.fontBackground === 'transparent' ? this.chartBackground : this.fontBackground;\r\n        switch (position) {\r\n            case 'Top':\r\n            case 'Outer':\r\n                labelLocation = labelLocation - this.markerHeight - this.borderWidth - size.height / 2 - this.margin.bottom - padding -\r\n                    this.errorHeight;\r\n                break;\r\n            case 'Bottom':\r\n                labelLocation = labelLocation + this.markerHeight + this.borderWidth + size.height / 2 + this.margin.top + padding +\r\n                    this.errorHeight;\r\n                break;\r\n            case 'Auto':\r\n                labelLocation = this.calculatePathActualPosition(labelLocation, this.markerHeight, series, point, size, labelIndex);\r\n                break;\r\n        }\r\n        return labelLocation;\r\n    };\r\n    DataLabel.prototype.isDataLabelShape = function (style) {\r\n        this.isShape = (style.color !== 'transparent' || style.border.width > 0);\r\n        this.borderWidth = style.border.width;\r\n        if (!this.isShape) {\r\n            this.margin = { left: 0, right: 0, bottom: 0, top: 0 };\r\n        }\r\n    };\r\n    DataLabel.prototype.calculateRectActualPosition = function (labelLocation, rect, isMinus, series, size, labelIndex, point) {\r\n        var location;\r\n        var labelRect;\r\n        var isOverLap = true;\r\n        var position = 0;\r\n        var collection = this.chart.dataLabelCollections;\r\n        var finalPosition = series.type.indexOf('Range') !== -1 || series.type === 'Hilo' ? 2 : 4;\r\n        while (isOverLap && position < finalPosition) {\r\n            var actualPosition = this.getPosition(position);\r\n            if (series.type.indexOf('Stacking') > -1 && actualPosition === 'Outer') {\r\n                actualPosition = 'Top';\r\n                position++;\r\n            }\r\n            location = this.calculateRectPosition(labelLocation, rect, isMinus, actualPosition, series, size, labelIndex, point);\r\n            if (!this.inverted) {\r\n                labelRect = calculateRect(new ChartLocation(this.locationX, location), size, this.margin);\r\n                isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect) || labelRect.y > series.clipRect.height;\r\n            }\r\n            else {\r\n                labelRect = calculateRect(new ChartLocation(location, this.locationY), size, this.margin);\r\n                isOverLap = labelRect.x < 0 || isCollide(labelRect, collection, series.clipRect) ||\r\n                    labelRect.x + labelRect.width > series.clipRect.width;\r\n            }\r\n            position++;\r\n        }\r\n        return location;\r\n    };\r\n    // alignment calculation assigned here\r\n    DataLabel.prototype.calculateAlignment = function (value, labelLocation, alignment, isMinus) {\r\n        switch (alignment) {\r\n            case 'Far':\r\n                labelLocation = !this.inverted ? (isMinus ? labelLocation + value : labelLocation - value) :\r\n                    (isMinus ? labelLocation - value : labelLocation + value);\r\n                break;\r\n            case 'Near':\r\n                labelLocation = !this.inverted ? (isMinus ? labelLocation - value : labelLocation + value) :\r\n                    (isMinus ? labelLocation + value : labelLocation - value);\r\n                break;\r\n            // eslint-disable-next-line no-self-assign\r\n            case 'Center':\r\n                labelLocation = labelLocation;\r\n                break;\r\n        }\r\n        return labelLocation;\r\n    };\r\n    //calculation for top and outer position of datalabel for rect series\r\n    DataLabel.prototype.calculateTopAndOuterPosition = function (location, rect, position, series, index, extraSpace, isMinus) {\r\n        var margin = this.margin;\r\n        var top;\r\n        switch (series.type) {\r\n            case 'RangeColumn':\r\n            case 'RangeArea':\r\n            case 'SplineRangeArea':\r\n            case 'Hilo':\r\n                top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\r\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\r\n                break;\r\n            case 'Candle':\r\n                top = (index === 0 || index === 2) && !this.yAxisInversed\r\n                    || (index === 1 || index === 3) && this.yAxisInversed;\r\n                location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top, index > 1);\r\n                break;\r\n            case 'HiloOpenClose':\r\n                if (index <= 1) {\r\n                    top = (index === 0 && !this.yAxisInversed) || (index === 1 && this.yAxisInversed);\r\n                    location = this.updateLabelLocation(position, location, extraSpace, margin, rect, top);\r\n                }\r\n                else {\r\n                    if (this.yAxisInversed) {\r\n                        location = !this.inverted ? location + extraSpace + margin.top : location - extraSpace - margin.right;\r\n                    }\r\n                    else {\r\n                        location = !this.inverted ? location - extraSpace - margin.bottom : location + extraSpace + margin.left;\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                if ((isMinus && position === 'Top') || (!isMinus && position === 'Outer')) {\r\n                    location = !this.inverted ? location - extraSpace - margin.bottom - this.markerHeight :\r\n                        location + extraSpace + margin.left + this.markerHeight;\r\n                }\r\n                else {\r\n                    location = !this.inverted ? location + extraSpace + margin.top + this.markerHeight :\r\n                        location - extraSpace - margin.right - this.markerHeight;\r\n                }\r\n                break;\r\n        }\r\n        return location;\r\n    };\r\n    /**\r\n     * Updates the label location\r\n     */\r\n    DataLabel.prototype.updateLabelLocation = function (position, location, extraSpace, margin, rect, top, inside) {\r\n        if (inside === void 0) { inside = false; }\r\n        if (!this.inverted) {\r\n            if (top) {\r\n                location = (position === 'Outer' && !inside) ? location - extraSpace - margin.bottom - this.markerHeight :\r\n                    location + extraSpace + margin.top + this.markerHeight;\r\n            }\r\n            else {\r\n                location = (position === 'Outer' && !inside) ? location + rect.height + extraSpace + margin.top + this.markerHeight :\r\n                    location + rect.height - extraSpace - margin.bottom - this.markerHeight;\r\n            }\r\n        }\r\n        else {\r\n            if (top) {\r\n                location = (position === 'Outer' && !inside) ? location + extraSpace + margin.left + this.markerHeight :\r\n                    location - extraSpace - margin.right - this.markerHeight;\r\n            }\r\n            else {\r\n                location = (position === 'Outer' && !inside) ? location - rect.width - extraSpace - margin.right - this.markerHeight :\r\n                    location - rect.width + extraSpace + margin.left + this.markerHeight;\r\n            }\r\n        }\r\n        return location;\r\n    };\r\n    DataLabel.prototype.calculatePathActualPosition = function (y, markerSize, series, point, size, labelIndex) {\r\n        var points = series.points;\r\n        var index = point.index;\r\n        var yValue = points[index].yValue;\r\n        var position;\r\n        var nextPoint = points.length - 1 > index ? points[index + 1] : null;\r\n        var previousPoint = index > 0 ? points[index - 1] : null;\r\n        var yLocation;\r\n        var isOverLap = true;\r\n        var labelRect;\r\n        var isBottom;\r\n        var positionIndex;\r\n        var collection = this.chart.dataLabelCollections;\r\n        if (series.type === 'Bubble') {\r\n            position = 'Top';\r\n        }\r\n        else if (series.type.indexOf('Step') > -1) {\r\n            position = 'Top';\r\n            if (index) {\r\n                position = (!previousPoint || !previousPoint.visible || (yValue > previousPoint.yValue !== this.yAxisInversed)\r\n                    || yValue === previousPoint.yValue) ? 'Top' : 'Bottom';\r\n            }\r\n        }\r\n        else if (series.type === 'BoxAndWhisker') {\r\n            if (labelIndex === 1 || labelIndex === 3 || labelIndex > 4) {\r\n                position = series.yAxis.isAxisInverse ? 'Bottom' : 'Top';\r\n            }\r\n            else if (labelIndex === 2 || labelIndex === 4) {\r\n                position = series.yAxis.isAxisInverse ? 'Top' : 'Bottom';\r\n            }\r\n            else {\r\n                isOverLap = false;\r\n                position = 'Middle';\r\n                yLocation = this.calculatePathPosition(y, position, series, point, size, labelIndex);\r\n            }\r\n        }\r\n        else {\r\n            if (index === 0) {\r\n                position = (!nextPoint || !nextPoint.visible || yValue > nextPoint.yValue ||\r\n                    (yValue < nextPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\r\n            }\r\n            else if (index === points.length - 1) {\r\n                position = (!previousPoint || !previousPoint.visible || yValue > previousPoint.yValue ||\r\n                    (yValue < previousPoint.yValue && this.yAxisInversed)) ? 'Top' : 'Bottom';\r\n            }\r\n            else {\r\n                if (!nextPoint.visible && !(previousPoint && previousPoint.visible)) {\r\n                    position = 'Top';\r\n                }\r\n                else if (!nextPoint.visible || !previousPoint) {\r\n                    position = (nextPoint.yValue > yValue || (previousPoint && previousPoint.yValue > yValue)) ?\r\n                        'Bottom' : 'Top';\r\n                }\r\n                else {\r\n                    var slope = (nextPoint.yValue - previousPoint.yValue) / 2;\r\n                    var intersectY = (slope * index) + (nextPoint.yValue - (slope * (index + 1)));\r\n                    position = !this.yAxisInversed ? intersectY < yValue ? 'Top' : 'Bottom' :\r\n                        intersectY < yValue ? 'Bottom' : 'Top';\r\n                }\r\n            }\r\n        }\r\n        isBottom = position === 'Bottom';\r\n        positionIndex = ['Outer', 'Top', 'Bottom', 'Middle', 'Auto'].indexOf(position);\r\n        while (isOverLap && positionIndex < 4) {\r\n            yLocation = this.calculatePathPosition(y, this.getPosition(positionIndex), series, point, size, labelIndex);\r\n            labelRect = calculateRect(new ChartLocation(this.locationX, yLocation), size, this.margin);\r\n            isOverLap = labelRect.y < 0 || isCollide(labelRect, collection, series.clipRect)\r\n                || (labelRect.y + labelRect.height) > series.clipRect.height;\r\n            positionIndex = isBottom ? positionIndex - 1 : positionIndex + 1;\r\n            isBottom = false;\r\n        }\r\n        return yLocation;\r\n    };\r\n    /**\r\n     * Animates the data label.\r\n     *\r\n     * @param  {Series} series - Data label of the series gets animated.\r\n     * @returns {void}\r\n     */\r\n    DataLabel.prototype.doDataLabelAnimation = function (series, element) {\r\n        var shapeElements = series.shapeElement.childNodes;\r\n        var textNode = series.textElement.childNodes;\r\n        var delay = series.animation.delay + series.animation.duration;\r\n        var duration = series.chart.animated ? series.chart.duration : 200;\r\n        var location;\r\n        var length = element ? 1 : textNode.length;\r\n        var tempElement;\r\n        for (var i = 0; i < length; i++) {\r\n            tempElement = textNode[i];\r\n            if (element) {\r\n                element.style.visibility = 'hidden';\r\n                templateAnimate(element, delay, duration, 'ZoomIn');\r\n            }\r\n            else {\r\n                location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\r\n                markerAnimate(tempElement, delay, duration, series, null, location, true);\r\n                if (shapeElements[i]) {\r\n                    tempElement = shapeElements[i];\r\n                    location = new ChartLocation((+tempElement.getAttribute('x')) + ((+tempElement.getAttribute('width')) / 2), (+tempElement.getAttribute('y')) + ((+tempElement.getAttribute('height')) / 2));\r\n                    markerAnimate(tempElement, delay, duration, series, null, location, true);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    DataLabel.prototype.getPosition = function (index) {\r\n        return (['Outer', 'Top', 'Bottom', 'Middle', 'Auto'][index]);\r\n    };\r\n    /**\r\n     * Get module name.\r\n     */\r\n    DataLabel.prototype.getModuleName = function () {\r\n        // Returns the module name\r\n        return 'DataLabel';\r\n    };\r\n    /**\r\n     * To destroy the dataLabel for series.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    DataLabel.prototype.destroy = function () {\r\n        // Destroy method performed here\r\n    };\r\n    return DataLabel;\r\n}());\r\nexport { DataLabel };\r\n"]},"metadata":{},"sourceType":"module"}