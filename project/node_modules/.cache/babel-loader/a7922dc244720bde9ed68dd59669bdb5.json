{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { valueToCoefficient, textElement, firstToLowerCase } from '../../common/utils/helper';\nimport { PathOption, Rect, measureText, TextOption } from '@syncfusion/ej2-svg-base';\nimport { DateTime } from '../../chart/axis/date-time-axis';\nimport { VisibleLabels } from '../../chart/axis/axis';\n/**\r\n * class for axis\r\n */\n\nvar RangeNavigatorAxis =\n/** @class */\nfunction (_super) {\n  __extends(RangeNavigatorAxis, _super);\n\n  function RangeNavigatorAxis(range) {\n    var _this = _super.call(this) || this;\n\n    _this.firstLevelLabels = [];\n    _this.secondLevelLabels = [];\n    _this.rangeNavigator = range;\n    return _this;\n  }\n  /**\r\n   * To render grid lines of axis\r\n   */\n\n\n  RangeNavigatorAxis.prototype.renderGridLines = function () {\n    var pointX = 0;\n    var control = this.rangeNavigator;\n    var majorGridLines = control.majorGridLines;\n    var majorTickLines = control.majorTickLines;\n    var majorGrid = '';\n    var majorTick = '';\n    var rect = control.bounds;\n    var chartAxis = control.chartSeries.xAxis;\n    var disabledColor = control.disableRangeSelector ? 'transparent' : null;\n    this.gridLines = control.renderer.createGroup({\n      id: control.element.id + '_GridLines'\n    });\n    var tick = control.tickPosition === 'Outside' || control.series.length === 0 ? rect.y + rect.height + majorTickLines.height : rect.y + rect.height - majorTickLines.height; //Gridlines\n\n    this.firstLevelLabels = [];\n    chartAxis.labelStyle = control.labelStyle;\n    chartAxis.skeleton = control.skeleton;\n    chartAxis.skeletonType = control.skeletonType;\n    chartAxis.isChart = false;\n\n    if (control.valueType === 'DateTime') {\n      this.calculateDateTimeNiceInterval(chartAxis, rect, chartAxis.doubleRange.start, chartAxis.doubleRange.end, chartAxis.isChart);\n      this.actualIntervalType = chartAxis.actualIntervalType;\n      this.findAxisLabels(chartAxis);\n    }\n\n    this.firstLevelLabels = chartAxis.visibleLabels;\n    this.lowerValues = [];\n    var labelLength = chartAxis.visibleLabels.length;\n\n    for (var i = 0; i < labelLength; i++) {\n      this.lowerValues.push(this.firstLevelLabels[i].value);\n      pointX = valueToCoefficient(this.firstLevelLabels[i].value, chartAxis) * rect.width + rect.x;\n\n      if (pointX >= rect.x && rect.x + rect.width >= pointX) {\n        majorGrid = majorGrid.concat('M ' + pointX + ' ' + (control.bounds.y + control.bounds.height) + ' L ' + pointX + ' ' + control.bounds.y + ' ');\n        majorTick = majorTick.concat('M ' + pointX + ' ' + (rect.y + rect.height) + ' L ' + pointX + ' ' + tick + ' ');\n      }\n    }\n\n    var options = new PathOption(control.element.id + '_MajorGridLine', 'transparent', majorGridLines.width, control.series.length ? disabledColor || majorGridLines.color || control.themeStyle.gridLineColor : 'transparent', 1, majorGridLines.dashArray, majorGrid);\n    this.gridLines.appendChild(control.renderer.drawPath(options));\n    options = new PathOption(control.element.id + '_MajorTickLine', 'transparent', majorTickLines.width, disabledColor || majorTickLines.color || control.themeStyle.gridLineColor, 1, majorGridLines.dashArray, majorTick);\n    this.gridLines.appendChild(control.renderer.drawPath(options));\n  };\n  /**\r\n   * To render of axis labels\r\n   */\n\n\n  RangeNavigatorAxis.prototype.renderAxisLabels = function () {\n    var axis = this.rangeNavigator.chartSeries.xAxis;\n    var control = this.rangeNavigator;\n    var pointY;\n    var labelElement = control.renderer.createGroup({\n      id: control.element.id + '_AxisLabels'\n    });\n    var firstLevelElement = control.renderer.createGroup({\n      id: control.element.id + '_FirstLevelAxisLabels'\n    });\n    var secondLevelElement = control.renderer.createGroup({\n      id: control.element.id + '_SecondLevelAxisLabels'\n    });\n    var secondaryAxis = axis;\n    pointY = this.findLabelY(control, false);\n    this.placeAxisLabels(axis, pointY, '_AxisLabel_', control, firstLevelElement);\n    secondaryAxis.intervalType = secondaryAxis.actualIntervalType = control.groupBy || this.getSecondaryLabelType(axis.actualIntervalType);\n    secondaryAxis.labelFormat = '';\n\n    if (control.enableGrouping && control.valueType === 'DateTime' && this.actualIntervalType !== 'Years') {\n      secondaryAxis.visibleRange.interval = 1;\n      secondaryAxis.visibleLabels = [];\n      this.findAxisLabels(secondaryAxis);\n      this.secondLevelLabels = secondaryAxis.visibleLabels;\n      pointY = this.findLabelY(control, true);\n      var border = this.placeAxisLabels(secondaryAxis, pointY, '_SecondaryLabel_', control, secondLevelElement);\n      var path = new PathOption(control.element.id + '_SecondaryMajorLines', 'transparent', control.majorTickLines.width, control.majorTickLines.color || control.themeStyle.gridLineColor, 1, control.majorGridLines.dashArray, border);\n      this.gridLines.appendChild(control.renderer.drawPath(path));\n    }\n\n    control.chartSeries.xAxis.visibleLabels = control.chartSeries.xAxis.visibleLabels.concat(secondaryAxis.visibleLabels);\n    labelElement.style.cursor = axis.valueType === 'DateTime' ? 'cursor: pointer' : 'cursor: default';\n    labelElement.appendChild(firstLevelElement);\n    labelElement.appendChild(secondLevelElement); //gridlines and axis label append to element\n\n    control.svgObject.appendChild(this.gridLines);\n    control.svgObject.appendChild(labelElement);\n  };\n  /**\r\n   * To find secondary level label type\r\n   *\r\n   * @param {RangeIntervalType} type type of range interval\r\n   */\n\n\n  RangeNavigatorAxis.prototype.getSecondaryLabelType = function (type) {\n    var types = ['Years', 'Quarter', 'Months', 'Weeks', 'Days', 'Hours', 'Minutes', 'Seconds'];\n    return type === 'Years' ? 'Years' : types[types.indexOf(type) - 1];\n  };\n  /**\r\n   * To find labels for date time axis\r\n   *\r\n   * @param {Axis} axis range axis\r\n   */\n\n\n  RangeNavigatorAxis.prototype.findAxisLabels = function (axis) {\n    axis.visibleLabels = [];\n    var start = new Date(axis.visibleRange.min);\n    var nextInterval;\n    var text;\n    var interval = this.rangeNavigator.interval ? this.rangeNavigator.interval : 1;\n\n    switch (axis.actualIntervalType) {\n      case 'Years':\n        start = new Date(start.getFullYear(), 0, 1);\n        break;\n\n      case 'Quarter':\n        if (start.getMonth() <= 2) {\n          start = new Date(start.getFullYear(), 0, 1);\n        } else if (start.getMonth() <= 5) {\n          start = new Date(start.getFullYear(), 3, 1);\n        } else if (start.getMonth() <= 8) {\n          start = new Date(start.getFullYear(), 6, 1);\n        } else {\n          start = new Date(start.getFullYear(), 9, 1);\n        }\n\n        break;\n\n      case 'Months':\n        start = new Date(start.getFullYear(), start.getMonth());\n        break;\n\n      case 'Weeks':\n        start = new Date(start.getFullYear(), start.getMonth(), start.getDate() - start.getDay());\n        break;\n\n      case 'Days':\n        start = new Date(start.getFullYear(), start.getMonth(), start.getDate());\n        break;\n\n      case 'Hours':\n        start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours());\n        break;\n\n      case 'Minutes':\n        start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes());\n        break;\n\n      case 'Seconds':\n        start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes(), start.getSeconds());\n        break;\n    }\n\n    nextInterval = start.getTime();\n    this.rangeNavigator.format = this.rangeNavigator.intl.getDateFormat({\n      format: axis.labelFormat || '',\n      type: firstToLowerCase(axis.skeletonType),\n      skeleton: this.getSkeleton(axis, null, null)\n    });\n\n    while (nextInterval <= axis.visibleRange.max) {\n      text = this.dateFormats(this.rangeNavigator.format(new Date(nextInterval)), axis, axis.visibleLabels.length);\n      axis.visibleLabels.push(new VisibleLabels(text, nextInterval, this.rangeNavigator.labelStyle, text));\n      nextInterval = this.increaseDateTimeInterval(axis, nextInterval, interval).getTime();\n    }\n  };\n  /**\r\n   * To find date time formats for Quarter and week interval type\r\n   *\r\n   * @param {string} text text\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   */\n\n\n  RangeNavigatorAxis.prototype.dateFormats = function (text, axis, index) {\n    var changedText = text;\n    var isFirstLevel = this.rangeNavigator.enableGrouping && this.firstLevelLabels.length === 0;\n\n    switch (axis.actualIntervalType) {\n      case 'Quarter':\n        if (text.indexOf('Jan') > -1) {\n          changedText = !isFirstLevel ? text.replace('Jan', 'Quarter1') : 'Quarter1';\n        } else if (text.indexOf('Apr') > -1) {\n          changedText = !isFirstLevel ? text.replace('Apr', 'Quarter2') : 'Quarter2';\n        } else if (text.indexOf('Jul') > -1) {\n          changedText = !isFirstLevel ? text.replace('Jul', 'Quarter3') : 'Quarter3';\n        } else if (text.indexOf('Oct') > -1) {\n          changedText = !isFirstLevel ? text.replace('Oct', 'Quarter4') : 'Quarter4';\n        }\n\n        break;\n\n      case 'Weeks':\n        changedText = 'Week' + ++index;\n        break;\n\n      default:\n        changedText = text;\n        break;\n    }\n\n    return changedText;\n  };\n  /**\r\n   * To find the y co-ordinate for axis labels\r\n   *\r\n   * @param {RangeNavigator} control - rangeNavigator\r\n   * @param {boolean} isSecondary sets true if the axis is secondary axis\r\n   */\n\n\n  RangeNavigatorAxis.prototype.findLabelY = function (control, isSecondary) {\n    var pointY;\n    var reference = control.bounds.y + control.bounds.height;\n    var tickHeight = control.majorTickLines.height;\n    var textHeight = measureText('Quarter1 2011', control.labelStyle).height;\n    var padding = 8;\n\n    if (control.labelPosition === 'Outside' && control.tickPosition === 'Outside' || control.series.length === 0) {\n      pointY = reference + tickHeight + padding + textHeight * 0.75;\n    } else if (control.labelPosition === 'Inside' && control.tickPosition === 'Inside') {\n      pointY = reference - tickHeight - padding;\n    } else if (control.labelPosition === 'Inside' && control.tickPosition === 'Outside') {\n      pointY = reference - padding;\n    } else {\n      pointY = reference + padding + textHeight * 0.75;\n    }\n\n    if (isSecondary) {\n      padding = 15;\n\n      if (control.labelPosition === 'Outside' || control.series.length === 0) {\n        pointY += padding + textHeight * 0.75;\n      } else {\n        pointY = control.tickPosition === 'Outside' || control.series.length === 0 ? reference + tickHeight + padding + textHeight * 0.75 : reference + padding + textHeight * 0.75;\n      }\n    }\n\n    return pointY;\n  };\n  /**\r\n   * It places the axis labels and returns border for secondary axis labels\r\n   *\r\n   * @param {Axis} axis axis for the lables placed\r\n   * @param {number} pointY y co-ordinate for axis labels\r\n   * @param {string} id id for the axis elements\r\n   * @param {RangeNavigator} control range navigator\r\n   * @param {Element} labelElement parent element in which axis labels appended\r\n   */\n\n\n  RangeNavigatorAxis.prototype.placeAxisLabels = function (axis, pointY, id, control, labelElement) {\n    var maxLabels = axis.visibleLabels.length;\n    var label;\n    var prevLabel;\n    var pointX;\n    var rect = control.bounds;\n    var border = '';\n    var pointXGrid;\n    var disabledColor = control.disableRangeSelector ? 'transparent' : null;\n    var prevX = control.enableRtl ? rect.x + rect.width : rect.x;\n    var intervalType = axis.actualIntervalType;\n    var intervalInTime = control.valueType === 'DateTime' ? maxLabels > 1 ? axis.visibleLabels[1].value - axis.visibleLabels[0].value : (axis.visibleRange.max - axis.visibleLabels[0].value) / 2 : 0;\n\n    if (control.valueType === 'DateTime' && (intervalType === 'Quarter' || intervalType === 'Weeks')) {\n      this.findSuitableFormat(axis, control);\n    }\n\n    for (var i = 0, len = maxLabels; i < len; i++) {\n      label = axis.visibleLabels[i];\n      label.size = measureText(label.text, axis.labelStyle);\n\n      if (control.secondaryLabelAlignment === 'Middle') {\n        pointX = valueToCoefficient(label.value + intervalInTime / 2, axis) * rect.width + rect.x;\n      } else if (id.indexOf('Secondary') > -1) {\n        pointX = this.findAlignment(axis, i);\n      }\n\n      pointXGrid = valueToCoefficient(label.value, axis) * rect.width + rect.x; //edgelabelPlacements\n\n      if ((i === 0 || i === axis.visibleLabels.length - 1 && control.enableRtl) && pointX < rect.x) {\n        pointX = rect.x + label.size.width / 2;\n      }\n\n      if ((i === axis.visibleLabels.length - 1 || i === 0 && control.enableRtl) && pointX + label.size.width > rect.x + rect.width) {\n        pointX = rect.x + rect.width - label.size.width / 2;\n      } //secondary axis grid lines\n\n\n      if (id.indexOf('_SecondaryLabel_') > -1) {\n        if (pointX >= rect.x && rect.x + rect.width >= pointX) {\n          border = border.concat('M ' + pointXGrid + ' ' + pointY + ' L ' + pointXGrid + ' ' + (pointY - label.size.height));\n        }\n      } //smart axis label position,\n\n\n      if (control.labelIntersectAction === 'Hide' && i !== 0 && this.isIntersect(axis, pointX, label.size.width, prevX, prevLabel.size.width)) {\n        continue;\n      } //label alignment for single visible label\n\n\n      if (control.secondaryLabelAlignment === 'Middle' && axis.visibleLabels.length === 1) {\n        pointX = valueToCoefficient(label.value, axis) + (rect.x + rect.width / 2);\n      } //labelrender event\n\n\n      var labelStyle = control.labelStyle;\n      var style = {\n        size: labelStyle.size,\n        color: disabledColor || labelStyle.color || control.themeStyle.labelFontColor,\n        fontFamily: labelStyle.fontFamily,\n        fontStyle: labelStyle.fontStyle || control.labelStyle.fontStyle,\n        fontWeight: labelStyle.fontWeight || control.labelStyle.fontWeight,\n        opacity: labelStyle.opacity || control.labelStyle.opacity,\n        textAlignment: labelStyle.textAlignment || control.labelStyle.textAlignment,\n        textOverflow: labelStyle.textOverflow || control.labelStyle.textOverflow\n      };\n      var argsData = {\n        cancel: false,\n        name: 'labelRender',\n        text: label.text,\n        value: label.value,\n        labelStyle: style,\n        region: new Rect(pointX, pointY, label.size.width, label.size.height)\n      };\n      control.trigger('labelRender', argsData);\n\n      if (!argsData.cancel) {\n        control.labels.push(argsData);\n      } else {\n        continue;\n      }\n\n      textElement(this.rangeNavigator.renderer, new TextOption(this.rangeNavigator.element.id + id + i, pointX, pointY, 'middle', argsData.text), argsData.labelStyle, argsData.labelStyle.color || control.themeStyle.labelFontColor, labelElement).style.cursor = axis.valueType === 'DateTime' ? 'cursor: pointer' : 'cursor: default';\n      prevX = pointX;\n      prevLabel = label;\n    }\n\n    return border;\n  };\n  /**\r\n   * To check label is intersected with successive label or not\r\n   */\n\n\n  RangeNavigatorAxis.prototype.isIntersect = function (axis, currentX, currentWidth, prevX, prevWidth) {\n    return axis.isInversed ? currentX + currentWidth / 2 > prevX - prevWidth / 2 : currentX - currentWidth / 2 < prevX + prevWidth / 2;\n  };\n  /**\r\n   * To find suitable label format for Quarter and week Interval types\r\n   *\r\n   * @param {Axis} axis RangeNavigator axis\r\n   * @param {RangeNavigator} control RangeNavigator instance\r\n   */\n\n\n  RangeNavigatorAxis.prototype.findSuitableFormat = function (axis, control) {\n    var labels = axis.visibleLabels;\n    var labelLength = labels.length;\n    var bounds = control.bounds;\n    var prevX;\n    var currentX;\n    var interval = control.valueType === 'DateTime' ? labelLength > 1 ? labels[1].value - labels[0].value : axis.visibleRange.interval : 0;\n\n    for (var i = 0; i < labelLength; i++) {\n      currentX = valueToCoefficient(labels[i].value + interval / 2, axis) * bounds.width + bounds.x;\n      labels[i].size = measureText(labels[i].text, axis.labelStyle); //edgelabelPlacements\n\n      if (i === 0 && currentX < bounds.x) {\n        currentX = bounds.x + labels[i].size.width / 2;\n      }\n\n      if (axis.actualIntervalType === 'Quarter') {\n        if (i !== 0) {\n          if (labels[i].text.indexOf('Quarter') > -1 && this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {\n            labels.every(function (label) {\n              label.text = label.text.toString().replace('Quarter', 'QTR');\n              return true;\n            });\n            axis.visibleLabels = labels;\n            this.findSuitableFormat(axis, control);\n          } else {\n            if (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {\n              labels.every(function (label) {\n                label.text = label.text.toString().replace('QTR', 'Q');\n                return true;\n              });\n              axis.visibleLabels = labels;\n            }\n          }\n        }\n      } else if (axis.actualIntervalType === 'Weeks') {\n        if (i !== 0 && labels[i].text.indexOf('Week') > -1 && this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {\n          labels.every(function (label) {\n            label.text = label.text.toString().replace('Week', 'W');\n            return true;\n          });\n          axis.visibleLabels = labels;\n        }\n      }\n\n      prevX = currentX;\n    }\n  };\n  /**\r\n   * Alignment position for secondary level labels in date time axis\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index label index\r\n   */\n\n\n  RangeNavigatorAxis.prototype.findAlignment = function (axis, index) {\n    var label = axis.visibleLabels[index];\n    var nextLabel = axis.visibleLabels[index + 1];\n    var bounds = this.rangeNavigator.bounds;\n    return this.rangeNavigator.secondaryLabelAlignment === 'Near' ? valueToCoefficient(label.value, axis) * bounds.width + bounds.x + label.size.width / 2 : valueToCoefficient(nextLabel ? nextLabel.value : axis.visibleRange.max, axis) * bounds.width + bounds.x - label.size.width;\n  };\n\n  return RangeNavigatorAxis;\n}(DateTime);\n\nexport { RangeNavigatorAxis };","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/range-navigator/renderer/range-axis.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","valueToCoefficient","textElement","firstToLowerCase","PathOption","Rect","measureText","TextOption","DateTime","VisibleLabels","RangeNavigatorAxis","_super","range","_this","call","firstLevelLabels","secondLevelLabels","rangeNavigator","renderGridLines","pointX","control","majorGridLines","majorTickLines","majorGrid","majorTick","rect","bounds","chartAxis","chartSeries","xAxis","disabledColor","disableRangeSelector","gridLines","renderer","createGroup","id","element","tick","tickPosition","series","length","y","height","labelStyle","skeleton","skeletonType","isChart","valueType","calculateDateTimeNiceInterval","doubleRange","start","end","actualIntervalType","findAxisLabels","visibleLabels","lowerValues","labelLength","i","push","value","width","x","concat","options","color","themeStyle","gridLineColor","dashArray","appendChild","drawPath","renderAxisLabels","axis","pointY","labelElement","firstLevelElement","secondLevelElement","secondaryAxis","findLabelY","placeAxisLabels","intervalType","groupBy","getSecondaryLabelType","labelFormat","enableGrouping","visibleRange","interval","border","path","style","cursor","svgObject","type","types","indexOf","Date","min","nextInterval","text","getFullYear","getMonth","getDate","getDay","getHours","getMinutes","getSeconds","getTime","format","intl","getDateFormat","getSkeleton","max","dateFormats","increaseDateTimeInterval","index","changedText","isFirstLevel","replace","isSecondary","reference","tickHeight","textHeight","padding","labelPosition","maxLabels","label","prevLabel","pointXGrid","prevX","enableRtl","intervalInTime","findSuitableFormat","len","size","secondaryLabelAlignment","findAlignment","labelIntersectAction","isIntersect","labelFontColor","fontFamily","fontStyle","fontWeight","opacity","textAlignment","textOverflow","argsData","cancel","name","region","trigger","labels","currentX","currentWidth","prevWidth","isInversed","every","toString","nextLabel"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nimport { valueToCoefficient, textElement, firstToLowerCase } from '../../common/utils/helper';\r\nimport { PathOption, Rect, measureText, TextOption } from '@syncfusion/ej2-svg-base';\r\nimport { DateTime } from '../../chart/axis/date-time-axis';\r\nimport { VisibleLabels } from '../../chart/axis/axis';\r\n/**\r\n * class for axis\r\n */\r\nvar RangeNavigatorAxis = /** @class */ (function (_super) {\r\n    __extends(RangeNavigatorAxis, _super);\r\n    function RangeNavigatorAxis(range) {\r\n        var _this = _super.call(this) || this;\r\n        _this.firstLevelLabels = [];\r\n        _this.secondLevelLabels = [];\r\n        _this.rangeNavigator = range;\r\n        return _this;\r\n    }\r\n    /**\r\n     * To render grid lines of axis\r\n     */\r\n    RangeNavigatorAxis.prototype.renderGridLines = function () {\r\n        var pointX = 0;\r\n        var control = this.rangeNavigator;\r\n        var majorGridLines = control.majorGridLines;\r\n        var majorTickLines = control.majorTickLines;\r\n        var majorGrid = '';\r\n        var majorTick = '';\r\n        var rect = control.bounds;\r\n        var chartAxis = control.chartSeries.xAxis;\r\n        var disabledColor = (control.disableRangeSelector) ? 'transparent' : null;\r\n        this.gridLines = control.renderer.createGroup({ id: control.element.id + '_GridLines' });\r\n        var tick = (control.tickPosition === 'Outside' || control.series.length === 0) ?\r\n            rect.y + rect.height + majorTickLines.height : rect.y + rect.height - majorTickLines.height;\r\n        //Gridlines\r\n        this.firstLevelLabels = [];\r\n        chartAxis.labelStyle = control.labelStyle;\r\n        chartAxis.skeleton = control.skeleton;\r\n        chartAxis.skeletonType = control.skeletonType;\r\n        chartAxis.isChart = false;\r\n        if (control.valueType === 'DateTime') {\r\n            this.calculateDateTimeNiceInterval(chartAxis, rect, chartAxis.doubleRange.start, chartAxis.doubleRange.end, chartAxis.isChart);\r\n            this.actualIntervalType = chartAxis.actualIntervalType;\r\n            this.findAxisLabels(chartAxis);\r\n        }\r\n        this.firstLevelLabels = chartAxis.visibleLabels;\r\n        this.lowerValues = [];\r\n        var labelLength = chartAxis.visibleLabels.length;\r\n        for (var i = 0; i < labelLength; i++) {\r\n            this.lowerValues.push(this.firstLevelLabels[i].value);\r\n            pointX = (valueToCoefficient(this.firstLevelLabels[i].value, chartAxis) * rect.width) + rect.x;\r\n            if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {\r\n                majorGrid = majorGrid.concat('M ' + pointX + ' ' + (control.bounds.y + control.bounds.height) +\r\n                    ' L ' + pointX + ' ' + control.bounds.y + ' ');\r\n                majorTick = majorTick.concat('M ' + (pointX) + ' ' + (rect.y + rect.height) +\r\n                    ' L ' + (pointX) + ' ' + tick + ' ');\r\n            }\r\n        }\r\n        var options = new PathOption(control.element.id + '_MajorGridLine', 'transparent', majorGridLines.width, control.series.length ? disabledColor || majorGridLines.color || control.themeStyle.gridLineColor : 'transparent', 1, majorGridLines.dashArray, majorGrid);\r\n        this.gridLines.appendChild(control.renderer.drawPath(options));\r\n        options = new PathOption(control.element.id + '_MajorTickLine', 'transparent', majorTickLines.width, disabledColor || majorTickLines.color || control.themeStyle.gridLineColor, 1, majorGridLines.dashArray, majorTick);\r\n        this.gridLines.appendChild(control.renderer.drawPath(options));\r\n    };\r\n    /**\r\n     * To render of axis labels\r\n     */\r\n    RangeNavigatorAxis.prototype.renderAxisLabels = function () {\r\n        var axis = this.rangeNavigator.chartSeries.xAxis;\r\n        var control = this.rangeNavigator;\r\n        var pointY;\r\n        var labelElement = control.renderer.createGroup({ id: control.element.id + '_AxisLabels' });\r\n        var firstLevelElement = control.renderer.createGroup({ id: control.element.id + '_FirstLevelAxisLabels' });\r\n        var secondLevelElement = control.renderer.createGroup({ id: control.element.id + '_SecondLevelAxisLabels' });\r\n        var secondaryAxis = axis;\r\n        pointY = this.findLabelY(control, false);\r\n        this.placeAxisLabels(axis, pointY, '_AxisLabel_', control, firstLevelElement);\r\n        secondaryAxis.intervalType = secondaryAxis.actualIntervalType = (control.groupBy ||\r\n            this.getSecondaryLabelType(axis.actualIntervalType));\r\n        secondaryAxis.labelFormat = '';\r\n        if (control.enableGrouping && control.valueType === 'DateTime' && this.actualIntervalType !== 'Years') {\r\n            secondaryAxis.visibleRange.interval = 1;\r\n            secondaryAxis.visibleLabels = [];\r\n            this.findAxisLabels(secondaryAxis);\r\n            this.secondLevelLabels = secondaryAxis.visibleLabels;\r\n            pointY = this.findLabelY(control, true);\r\n            var border = this.placeAxisLabels(secondaryAxis, pointY, '_SecondaryLabel_', control, secondLevelElement);\r\n            var path = new PathOption(control.element.id + '_SecondaryMajorLines', 'transparent', control.majorTickLines.width, control.majorTickLines.color || control.themeStyle.gridLineColor, 1, control.majorGridLines.dashArray, border);\r\n            this.gridLines.appendChild(control.renderer.drawPath(path));\r\n        }\r\n        control.chartSeries.xAxis.visibleLabels = control.chartSeries.xAxis.visibleLabels.concat(secondaryAxis.visibleLabels);\r\n        labelElement.style.cursor = axis.valueType === 'DateTime' ? 'cursor: pointer' : 'cursor: default';\r\n        labelElement.appendChild(firstLevelElement);\r\n        labelElement.appendChild(secondLevelElement);\r\n        //gridlines and axis label append to element\r\n        control.svgObject.appendChild(this.gridLines);\r\n        control.svgObject.appendChild(labelElement);\r\n    };\r\n    /**\r\n     * To find secondary level label type\r\n     *\r\n     * @param {RangeIntervalType} type type of range interval\r\n     */\r\n    RangeNavigatorAxis.prototype.getSecondaryLabelType = function (type) {\r\n        var types = ['Years', 'Quarter', 'Months', 'Weeks', 'Days', 'Hours', 'Minutes', 'Seconds'];\r\n        return (type === 'Years' ? 'Years' : types[types.indexOf(type) - 1]);\r\n    };\r\n    /**\r\n     * To find labels for date time axis\r\n     *\r\n     * @param {Axis} axis range axis\r\n     */\r\n    RangeNavigatorAxis.prototype.findAxisLabels = function (axis) {\r\n        axis.visibleLabels = [];\r\n        var start = new Date(axis.visibleRange.min);\r\n        var nextInterval;\r\n        var text;\r\n        var interval = this.rangeNavigator.interval ? this.rangeNavigator.interval : 1;\r\n        switch (axis.actualIntervalType) {\r\n            case 'Years':\r\n                start = new Date(start.getFullYear(), 0, 1);\r\n                break;\r\n            case 'Quarter':\r\n                if (start.getMonth() <= 2) {\r\n                    start = new Date(start.getFullYear(), 0, 1);\r\n                }\r\n                else if (start.getMonth() <= 5) {\r\n                    start = new Date(start.getFullYear(), 3, 1);\r\n                }\r\n                else if (start.getMonth() <= 8) {\r\n                    start = new Date(start.getFullYear(), 6, 1);\r\n                }\r\n                else {\r\n                    start = new Date(start.getFullYear(), 9, 1);\r\n                }\r\n                break;\r\n            case 'Months':\r\n                start = new Date(start.getFullYear(), start.getMonth());\r\n                break;\r\n            case 'Weeks':\r\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate() - start.getDay());\r\n                break;\r\n            case 'Days':\r\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate());\r\n                break;\r\n            case 'Hours':\r\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours());\r\n                break;\r\n            case 'Minutes':\r\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes());\r\n                break;\r\n            case 'Seconds':\r\n                start = new Date(start.getFullYear(), start.getMonth(), start.getDate(), start.getHours(), start.getMinutes(), start.getSeconds());\r\n                break;\r\n        }\r\n        nextInterval = start.getTime();\r\n        this.rangeNavigator.format = this.rangeNavigator.intl.getDateFormat({\r\n            format: axis.labelFormat || '',\r\n            type: firstToLowerCase(axis.skeletonType), skeleton: this.getSkeleton(axis, null, null)\r\n        });\r\n        while (nextInterval <= axis.visibleRange.max) {\r\n            text = this.dateFormats(this.rangeNavigator.format(new Date(nextInterval)), axis, axis.visibleLabels.length);\r\n            axis.visibleLabels.push(new VisibleLabels(text, nextInterval, this.rangeNavigator.labelStyle, text));\r\n            nextInterval = this.increaseDateTimeInterval(axis, nextInterval, interval).getTime();\r\n        }\r\n    };\r\n    /**\r\n     * To find date time formats for Quarter and week interval type\r\n     *\r\n     * @param {string} text text\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     */\r\n    RangeNavigatorAxis.prototype.dateFormats = function (text, axis, index) {\r\n        var changedText = text;\r\n        var isFirstLevel = this.rangeNavigator.enableGrouping && this.firstLevelLabels.length === 0;\r\n        switch (axis.actualIntervalType) {\r\n            case 'Quarter':\r\n                if (text.indexOf('Jan') > -1) {\r\n                    changedText = !isFirstLevel ? text.replace('Jan', 'Quarter1') : 'Quarter1';\r\n                }\r\n                else if (text.indexOf('Apr') > -1) {\r\n                    changedText = !isFirstLevel ? text.replace('Apr', 'Quarter2') : 'Quarter2';\r\n                }\r\n                else if (text.indexOf('Jul') > -1) {\r\n                    changedText = !isFirstLevel ? text.replace('Jul', 'Quarter3') : 'Quarter3';\r\n                }\r\n                else if (text.indexOf('Oct') > -1) {\r\n                    changedText = !isFirstLevel ? text.replace('Oct', 'Quarter4') : 'Quarter4';\r\n                }\r\n                break;\r\n            case 'Weeks':\r\n                changedText = 'Week' + ++index;\r\n                break;\r\n            default:\r\n                changedText = text;\r\n                break;\r\n        }\r\n        return changedText;\r\n    };\r\n    /**\r\n     * To find the y co-ordinate for axis labels\r\n     *\r\n     * @param {RangeNavigator} control - rangeNavigator\r\n     * @param {boolean} isSecondary sets true if the axis is secondary axis\r\n     */\r\n    RangeNavigatorAxis.prototype.findLabelY = function (control, isSecondary) {\r\n        var pointY;\r\n        var reference = control.bounds.y + control.bounds.height;\r\n        var tickHeight = control.majorTickLines.height;\r\n        var textHeight = measureText('Quarter1 2011', control.labelStyle).height;\r\n        var padding = 8;\r\n        if ((control.labelPosition === 'Outside' && control.tickPosition === 'Outside') || control.series.length === 0) {\r\n            pointY = reference + tickHeight + padding + textHeight * 0.75;\r\n        }\r\n        else if (control.labelPosition === 'Inside' && control.tickPosition === 'Inside') {\r\n            pointY = reference - tickHeight - padding;\r\n        }\r\n        else if (control.labelPosition === 'Inside' && control.tickPosition === 'Outside') {\r\n            pointY = reference - padding;\r\n        }\r\n        else {\r\n            pointY = reference + padding + (textHeight * 0.75);\r\n        }\r\n        if (isSecondary) {\r\n            padding = 15;\r\n            if (control.labelPosition === 'Outside' || control.series.length === 0) {\r\n                pointY += padding + textHeight * 0.75;\r\n            }\r\n            else {\r\n                pointY = (control.tickPosition === 'Outside' || control.series.length === 0) ?\r\n                    reference + tickHeight + padding + textHeight * 0.75 : reference + padding + textHeight * 0.75;\r\n            }\r\n        }\r\n        return pointY;\r\n    };\r\n    /**\r\n     * It places the axis labels and returns border for secondary axis labels\r\n     *\r\n     * @param {Axis} axis axis for the lables placed\r\n     * @param {number} pointY y co-ordinate for axis labels\r\n     * @param {string} id id for the axis elements\r\n     * @param {RangeNavigator} control range navigator\r\n     * @param {Element} labelElement parent element in which axis labels appended\r\n     */\r\n    RangeNavigatorAxis.prototype.placeAxisLabels = function (axis, pointY, id, control, labelElement) {\r\n        var maxLabels = axis.visibleLabels.length;\r\n        var label;\r\n        var prevLabel;\r\n        var pointX;\r\n        var rect = control.bounds;\r\n        var border = '';\r\n        var pointXGrid;\r\n        var disabledColor = (control.disableRangeSelector) ? 'transparent' : null;\r\n        var prevX = control.enableRtl ? (rect.x + rect.width) : rect.x;\r\n        var intervalType = axis.actualIntervalType;\r\n        var intervalInTime = control.valueType === 'DateTime' ?\r\n            maxLabels > 1 ? (axis.visibleLabels[1].value - axis.visibleLabels[0].value) :\r\n                (axis.visibleRange.max - axis.visibleLabels[0].value) / 2 : 0;\r\n        if (control.valueType === 'DateTime' && (intervalType === 'Quarter' || intervalType === 'Weeks')) {\r\n            this.findSuitableFormat(axis, control);\r\n        }\r\n        for (var i = 0, len = maxLabels; i < len; i++) {\r\n            label = axis.visibleLabels[i];\r\n            label.size = measureText(label.text, axis.labelStyle);\r\n            if (control.secondaryLabelAlignment === 'Middle') {\r\n                pointX = (valueToCoefficient((label.value + intervalInTime / 2), axis) * rect.width) + rect.x;\r\n            }\r\n            else if ((id.indexOf('Secondary') > -1)) {\r\n                pointX = this.findAlignment(axis, i);\r\n            }\r\n            pointXGrid = (valueToCoefficient((label.value), axis) * rect.width) + rect.x;\r\n            //edgelabelPlacements\r\n            if ((i === 0 || (i === axis.visibleLabels.length - 1 && control.enableRtl)) && pointX < rect.x) {\r\n                pointX = rect.x + label.size.width / 2;\r\n            }\r\n            if ((i === axis.visibleLabels.length - 1 || (i === 0 && control.enableRtl)) &&\r\n                ((pointX + label.size.width) > (rect.x + rect.width))) {\r\n                pointX = rect.x + rect.width - label.size.width / 2;\r\n            }\r\n            //secondary axis grid lines\r\n            if (id.indexOf('_SecondaryLabel_') > -1) {\r\n                if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {\r\n                    border = border.concat('M ' + pointXGrid + ' ' + pointY +\r\n                        ' L ' + pointXGrid + ' ' + (pointY - label.size.height));\r\n                }\r\n            }\r\n            //smart axis label position,\r\n            if (control.labelIntersectAction === 'Hide' &&\r\n                i !== 0 && this.isIntersect(axis, pointX, label.size.width, prevX, prevLabel.size.width)) {\r\n                continue;\r\n            }\r\n            //label alignment for single visible label\r\n            if (control.secondaryLabelAlignment === 'Middle' && axis.visibleLabels.length === 1) {\r\n                pointX = valueToCoefficient(label.value, axis) + (rect.x + (rect.width / 2));\r\n            }\r\n            //labelrender event\r\n            var labelStyle = control.labelStyle;\r\n            var style = {\r\n                size: labelStyle.size, color: disabledColor || labelStyle.color || control.themeStyle.labelFontColor,\r\n                fontFamily: labelStyle.fontFamily,\r\n                fontStyle: labelStyle.fontStyle || control.labelStyle.fontStyle,\r\n                fontWeight: labelStyle.fontWeight || control.labelStyle.fontWeight,\r\n                opacity: labelStyle.opacity || control.labelStyle.opacity,\r\n                textAlignment: labelStyle.textAlignment || control.labelStyle.textAlignment,\r\n                textOverflow: labelStyle.textOverflow || control.labelStyle.textOverflow\r\n            };\r\n            var argsData = {\r\n                cancel: false, name: 'labelRender',\r\n                text: label.text, value: label.value, labelStyle: style,\r\n                region: new Rect(pointX, pointY, label.size.width, label.size.height)\r\n            };\r\n            control.trigger('labelRender', argsData);\r\n            if (!argsData.cancel) {\r\n                control.labels.push(argsData);\r\n            }\r\n            else {\r\n                continue;\r\n            }\r\n            textElement(this.rangeNavigator.renderer, new TextOption(this.rangeNavigator.element.id + id + i, pointX, pointY, 'middle', argsData.text), argsData.labelStyle, argsData.labelStyle.color || control.themeStyle.labelFontColor, labelElement).style.cursor = axis.valueType === 'DateTime' ? 'cursor: pointer' : 'cursor: default';\r\n            prevX = pointX;\r\n            prevLabel = label;\r\n        }\r\n        return border;\r\n    };\r\n    /**\r\n     * To check label is intersected with successive label or not\r\n     */\r\n    RangeNavigatorAxis.prototype.isIntersect = function (axis, currentX, currentWidth, prevX, prevWidth) {\r\n        return (axis.isInversed) ? (currentX + currentWidth / 2 > prevX - prevWidth / 2) :\r\n            (currentX - currentWidth / 2 < prevX + prevWidth / 2);\r\n    };\r\n    /**\r\n     * To find suitable label format for Quarter and week Interval types\r\n     *\r\n     * @param {Axis} axis RangeNavigator axis\r\n     * @param {RangeNavigator} control RangeNavigator instance\r\n     */\r\n    RangeNavigatorAxis.prototype.findSuitableFormat = function (axis, control) {\r\n        var labels = axis.visibleLabels;\r\n        var labelLength = labels.length;\r\n        var bounds = control.bounds;\r\n        var prevX;\r\n        var currentX;\r\n        var interval = control.valueType === 'DateTime' ?\r\n            labelLength > 1 ? (labels[1].value - labels[0].value) : axis.visibleRange.interval\r\n            : 0;\r\n        for (var i = 0; i < labelLength; i++) {\r\n            currentX = (valueToCoefficient((labels[i].value + interval / 2), axis) * bounds.width) + bounds.x;\r\n            labels[i].size = measureText(labels[i].text, axis.labelStyle);\r\n            //edgelabelPlacements\r\n            if (i === 0 && currentX < bounds.x) {\r\n                currentX = bounds.x + labels[i].size.width / 2;\r\n            }\r\n            if (axis.actualIntervalType === 'Quarter') {\r\n                if (i !== 0) {\r\n                    if ((labels[i].text.indexOf('Quarter') > -1) &&\r\n                        (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width))) {\r\n                        labels.every(function (label) {\r\n                            label.text = label.text.toString().replace('Quarter', 'QTR');\r\n                            return true;\r\n                        });\r\n                        axis.visibleLabels = labels;\r\n                        this.findSuitableFormat(axis, control);\r\n                    }\r\n                    else {\r\n                        if (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)) {\r\n                            labels.every(function (label) {\r\n                                label.text = label.text.toString().replace('QTR', 'Q');\r\n                                return true;\r\n                            });\r\n                            axis.visibleLabels = labels;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (axis.actualIntervalType === 'Weeks') {\r\n                if ((i !== 0) && ((labels[i].text.indexOf('Week') > -1) &&\r\n                    (this.isIntersect(axis, currentX, labels[i].size.width, prevX, labels[i - 1].size.width)))) {\r\n                    labels.every(function (label) {\r\n                        label.text = label.text.toString().replace('Week', 'W');\r\n                        return true;\r\n                    });\r\n                    axis.visibleLabels = labels;\r\n                }\r\n            }\r\n            prevX = currentX;\r\n        }\r\n    };\r\n    /**\r\n     * Alignment position for secondary level labels in date time axis\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index label index\r\n     */\r\n    RangeNavigatorAxis.prototype.findAlignment = function (axis, index) {\r\n        var label = axis.visibleLabels[index];\r\n        var nextLabel = axis.visibleLabels[index + 1];\r\n        var bounds = this.rangeNavigator.bounds;\r\n        return (this.rangeNavigator.secondaryLabelAlignment === 'Near' ?\r\n            (valueToCoefficient((label.value), axis) * bounds.width) + bounds.x + label.size.width / 2 :\r\n            (valueToCoefficient((nextLabel ? nextLabel.value : axis.visibleRange.max), axis) * bounds.width) + bounds.x - label.size.width);\r\n    };\r\n    return RangeNavigatorAxis;\r\n}(DateTime));\r\nexport { RangeNavigatorAxis };\r\n"]},"metadata":{},"sourceType":"module"}