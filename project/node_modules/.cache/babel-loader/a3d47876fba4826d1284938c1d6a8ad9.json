{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'kldivergence';\nvar dependencies = ['typed', 'matrix', 'divide', 'sum', 'multiply', 'map', 'dotDivide', 'log', 'isNumeric'];\nexport var createKldivergence = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divide,\n    sum,\n    multiply,\n    map,\n    dotDivide,\n    log,\n    isNumeric\n  } = _ref;\n  /**\r\n     * Calculate the Kullback-Leibler (KL) divergence  between two distributions\r\n     *\r\n     * Syntax:\r\n     *\r\n     *     math.kldivergence(x, y)\r\n     *\r\n     * Examples:\r\n     *\r\n     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153\r\n     *\r\n     *\r\n     * @param  {Array | Matrix} q    First vector\r\n     * @param  {Array | Matrix} p    Second vector\r\n     * @return {number}              Returns distance between q and p\r\n     */\n\n  return typed(name, {\n    'Array, Array': function ArrayArray(q, p) {\n      return _kldiv(matrix(q), matrix(p));\n    },\n    'Matrix, Array': function MatrixArray(q, p) {\n      return _kldiv(q, matrix(p));\n    },\n    'Array, Matrix': function ArrayMatrix(q, p) {\n      return _kldiv(matrix(q), p);\n    },\n    'Matrix, Matrix': function MatrixMatrix(q, p) {\n      return _kldiv(q, p);\n    }\n  });\n\n  function _kldiv(q, p) {\n    var plength = p.size().length;\n    var qlength = q.size().length;\n\n    if (plength > 1) {\n      throw new Error('first object must be one dimensional');\n    }\n\n    if (qlength > 1) {\n      throw new Error('second object must be one dimensional');\n    }\n\n    if (plength !== qlength) {\n      throw new Error('Length of two vectors must be equal');\n    } // Before calculation, apply normalization\n\n\n    var sumq = sum(q);\n\n    if (sumq === 0) {\n      throw new Error('Sum of elements in first object must be non zero');\n    }\n\n    var sump = sum(p);\n\n    if (sump === 0) {\n      throw new Error('Sum of elements in second object must be non zero');\n    }\n\n    var qnorm = divide(q, sum(q));\n    var pnorm = divide(p, sum(p));\n    var result = sum(multiply(qnorm, map(dotDivide(qnorm, pnorm), x => log(x))));\n\n    if (isNumeric(result)) {\n      return result;\n    } else {\n      return Number.NaN;\n    }\n  }\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/probability/kldivergence.js"],"names":["factory","name","dependencies","createKldivergence","_ref","typed","matrix","divide","sum","multiply","map","dotDivide","log","isNumeric","ArrayArray","q","p","_kldiv","MatrixArray","ArrayMatrix","MatrixMatrix","plength","size","length","qlength","Error","sumq","sump","qnorm","pnorm","result","x","Number","NaN"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory.js';\r\nvar name = 'kldivergence';\r\nvar dependencies = ['typed', 'matrix', 'divide', 'sum', 'multiply', 'map', 'dotDivide', 'log', 'isNumeric'];\r\nexport var createKldivergence = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    divide,\r\n    sum,\r\n    multiply,\r\n    map,\r\n    dotDivide,\r\n    log,\r\n    isNumeric\r\n  } = _ref;\r\n  /**\r\n     * Calculate the Kullback-Leibler (KL) divergence  between two distributions\r\n     *\r\n     * Syntax:\r\n     *\r\n     *     math.kldivergence(x, y)\r\n     *\r\n     * Examples:\r\n     *\r\n     *     math.kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])   //returns 0.24376698773121153\r\n     *\r\n     *\r\n     * @param  {Array | Matrix} q    First vector\r\n     * @param  {Array | Matrix} p    Second vector\r\n     * @return {number}              Returns distance between q and p\r\n     */\r\n  return typed(name, {\r\n    'Array, Array': function ArrayArray(q, p) {\r\n      return _kldiv(matrix(q), matrix(p));\r\n    },\r\n    'Matrix, Array': function MatrixArray(q, p) {\r\n      return _kldiv(q, matrix(p));\r\n    },\r\n    'Array, Matrix': function ArrayMatrix(q, p) {\r\n      return _kldiv(matrix(q), p);\r\n    },\r\n    'Matrix, Matrix': function MatrixMatrix(q, p) {\r\n      return _kldiv(q, p);\r\n    }\r\n  });\r\n  function _kldiv(q, p) {\r\n    var plength = p.size().length;\r\n    var qlength = q.size().length;\r\n    if (plength > 1) {\r\n      throw new Error('first object must be one dimensional');\r\n    }\r\n    if (qlength > 1) {\r\n      throw new Error('second object must be one dimensional');\r\n    }\r\n    if (plength !== qlength) {\r\n      throw new Error('Length of two vectors must be equal');\r\n    }\r\n\r\n    // Before calculation, apply normalization\r\n    var sumq = sum(q);\r\n    if (sumq === 0) {\r\n      throw new Error('Sum of elements in first object must be non zero');\r\n    }\r\n    var sump = sum(p);\r\n    if (sump === 0) {\r\n      throw new Error('Sum of elements in second object must be non zero');\r\n    }\r\n    var qnorm = divide(q, sum(q));\r\n    var pnorm = divide(p, sum(p));\r\n    var result = sum(multiply(qnorm, map(dotDivide(qnorm, pnorm), x => log(x))));\r\n    if (isNumeric(result)) {\r\n      return result;\r\n    } else {\r\n      return Number.NaN;\r\n    }\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}