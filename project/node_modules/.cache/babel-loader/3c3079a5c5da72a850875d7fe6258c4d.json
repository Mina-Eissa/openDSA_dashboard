{"ast":null,"code":"import { contains } from './array.js';\nimport { pickShallow } from './object.js';\n/**\r\n * Create a factory function, which can be used to inject dependencies.\r\n *\r\n * The created functions are memoized, a consecutive call of the factory\r\n * with the exact same inputs will return the same function instance.\r\n * The memoized cache is exposed on `factory.cache` and can be cleared\r\n * if needed.\r\n *\r\n * Example:\r\n *\r\n *     const name = 'log'\r\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\r\n *\r\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\r\n *       // ... create the function log here and return it\r\n *     }\r\n *\r\n * @param {string} name           Name of the function to be created\r\n * @param {string[]} dependencies The names of all required dependencies\r\n * @param {function} create       Callback function called with an object with all dependencies\r\n * @param {Object} [meta]         Optional object with meta information that will be attached\r\n *                                to the created factory function as property `meta`.\r\n * @returns {function}\r\n */\n\nexport function factory(name, dependencies, create, meta) {\n  function assertAndCreate(scope) {\n    // we only pass the requested dependencies to the factory function\n    // to prevent functions to rely on dependencies that are not explicitly\n    // requested.\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\n    assertDependencies(name, dependencies, scope);\n    return create(deps);\n  }\n\n  assertAndCreate.isFactory = true;\n  assertAndCreate.fn = name;\n  assertAndCreate.dependencies = dependencies.slice().sort();\n\n  if (meta) {\n    assertAndCreate.meta = meta;\n  }\n\n  return assertAndCreate;\n}\n/**\r\n * Sort all factories such that when loading in order, the dependencies are resolved.\r\n *\r\n * @param {Array} factories\r\n * @returns {Array} Returns a new array with the sorted factories.\r\n */\n\nexport function sortFactories(factories) {\n  var factoriesByName = {};\n  factories.forEach(factory => {\n    factoriesByName[factory.fn] = factory;\n  });\n\n  function containsDependency(factory, dependency) {\n    // TODO: detect circular references\n    if (isFactory(factory)) {\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\n        return true;\n      }\n\n      if (factory.dependencies.some(d => containsDependency(factoriesByName[d], dependency))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var sorted = [];\n\n  function addFactory(factory) {\n    var index = 0;\n\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\n      index++;\n    }\n\n    sorted.splice(index, 0, factory);\n  } // sort regular factory functions\n\n\n  factories.filter(isFactory).forEach(addFactory); // sort legacy factory functions AFTER the regular factory functions\n\n  factories.filter(factory => !isFactory(factory)).forEach(addFactory);\n  return sorted;\n} // TODO: comment or cleanup if unused in the end\n\nexport function create(factories) {\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  sortFactories(factories).forEach(factory => factory(scope));\n  return scope;\n}\n/**\r\n * Test whether an object is a factory. This is the case when it has\r\n * properties name, dependencies, and a function create.\r\n * @param {*} obj\r\n * @returns {boolean}\r\n */\n\nexport function isFactory(obj) {\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\n}\n/**\r\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\r\n *\r\n * Will throw an exception when there are dependencies missing.\r\n *\r\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\r\n * @param {string[]} dependencies\r\n * @param {Object} scope\r\n */\n\nexport function assertDependencies(name, dependencies, scope) {\n  var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals\n  .every(dependency => scope[dependency] !== undefined);\n\n  if (!allDefined) {\n    var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined); // TODO: create a custom error class for this, a MathjsError or something like that\n\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(d => \"\\\"\".concat(d, \"\\\"\")).join(', '), \".\"));\n  }\n}\nexport function isOptionalDependency(dependency) {\n  return dependency && dependency[0] === '?';\n}\nexport function stripOptionalNotation(dependency) {\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\n}","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/utils/factory.js"],"names":["contains","pickShallow","factory","name","dependencies","create","meta","assertAndCreate","scope","deps","map","stripOptionalNotation","assertDependencies","isFactory","fn","slice","sort","sortFactories","factories","factoriesByName","forEach","containsDependency","dependency","some","d","sorted","addFactory","index","length","splice","filter","arguments","undefined","obj","Array","isArray","allDefined","isOptionalDependency","every","missingDependencies","Error","concat","join"],"mappings":"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","sourcesContent":["import { contains } from './array.js';\r\nimport { pickShallow } from './object.js';\r\n\r\n/**\r\n * Create a factory function, which can be used to inject dependencies.\r\n *\r\n * The created functions are memoized, a consecutive call of the factory\r\n * with the exact same inputs will return the same function instance.\r\n * The memoized cache is exposed on `factory.cache` and can be cleared\r\n * if needed.\r\n *\r\n * Example:\r\n *\r\n *     const name = 'log'\r\n *     const dependencies = ['config', 'typed', 'divideScalar', 'Complex']\r\n *\r\n *     export const createLog = factory(name, dependencies, ({ typed, config, divideScalar, Complex }) => {\r\n *       // ... create the function log here and return it\r\n *     }\r\n *\r\n * @param {string} name           Name of the function to be created\r\n * @param {string[]} dependencies The names of all required dependencies\r\n * @param {function} create       Callback function called with an object with all dependencies\r\n * @param {Object} [meta]         Optional object with meta information that will be attached\r\n *                                to the created factory function as property `meta`.\r\n * @returns {function}\r\n */\r\nexport function factory(name, dependencies, create, meta) {\r\n  function assertAndCreate(scope) {\r\n    // we only pass the requested dependencies to the factory function\r\n    // to prevent functions to rely on dependencies that are not explicitly\r\n    // requested.\r\n    var deps = pickShallow(scope, dependencies.map(stripOptionalNotation));\r\n    assertDependencies(name, dependencies, scope);\r\n    return create(deps);\r\n  }\r\n  assertAndCreate.isFactory = true;\r\n  assertAndCreate.fn = name;\r\n  assertAndCreate.dependencies = dependencies.slice().sort();\r\n  if (meta) {\r\n    assertAndCreate.meta = meta;\r\n  }\r\n  return assertAndCreate;\r\n}\r\n\r\n/**\r\n * Sort all factories such that when loading in order, the dependencies are resolved.\r\n *\r\n * @param {Array} factories\r\n * @returns {Array} Returns a new array with the sorted factories.\r\n */\r\nexport function sortFactories(factories) {\r\n  var factoriesByName = {};\r\n  factories.forEach(factory => {\r\n    factoriesByName[factory.fn] = factory;\r\n  });\r\n  function containsDependency(factory, dependency) {\r\n    // TODO: detect circular references\r\n    if (isFactory(factory)) {\r\n      if (contains(factory.dependencies, dependency.fn || dependency.name)) {\r\n        return true;\r\n      }\r\n      if (factory.dependencies.some(d => containsDependency(factoriesByName[d], dependency))) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  var sorted = [];\r\n  function addFactory(factory) {\r\n    var index = 0;\r\n    while (index < sorted.length && !containsDependency(sorted[index], factory)) {\r\n      index++;\r\n    }\r\n    sorted.splice(index, 0, factory);\r\n  }\r\n\r\n  // sort regular factory functions\r\n  factories.filter(isFactory).forEach(addFactory);\r\n\r\n  // sort legacy factory functions AFTER the regular factory functions\r\n  factories.filter(factory => !isFactory(factory)).forEach(addFactory);\r\n  return sorted;\r\n}\r\n\r\n// TODO: comment or cleanup if unused in the end\r\nexport function create(factories) {\r\n  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n  sortFactories(factories).forEach(factory => factory(scope));\r\n  return scope;\r\n}\r\n\r\n/**\r\n * Test whether an object is a factory. This is the case when it has\r\n * properties name, dependencies, and a function create.\r\n * @param {*} obj\r\n * @returns {boolean}\r\n */\r\nexport function isFactory(obj) {\r\n  return typeof obj === 'function' && typeof obj.fn === 'string' && Array.isArray(obj.dependencies);\r\n}\r\n\r\n/**\r\n * Assert that all dependencies of a list with dependencies are available in the provided scope.\r\n *\r\n * Will throw an exception when there are dependencies missing.\r\n *\r\n * @param {string} name   Name for the function to be created. Used to generate a useful error message\r\n * @param {string[]} dependencies\r\n * @param {Object} scope\r\n */\r\nexport function assertDependencies(name, dependencies, scope) {\r\n  var allDefined = dependencies.filter(dependency => !isOptionalDependency(dependency)) // filter optionals\r\n  .every(dependency => scope[dependency] !== undefined);\r\n  if (!allDefined) {\r\n    var missingDependencies = dependencies.filter(dependency => scope[dependency] === undefined);\r\n\r\n    // TODO: create a custom error class for this, a MathjsError or something like that\r\n    throw new Error(\"Cannot create function \\\"\".concat(name, \"\\\", \") + \"some dependencies are missing: \".concat(missingDependencies.map(d => \"\\\"\".concat(d, \"\\\"\")).join(', '), \".\"));\r\n  }\r\n}\r\nexport function isOptionalDependency(dependency) {\r\n  return dependency && dependency[0] === '?';\r\n}\r\nexport function stripOptionalNotation(dependency) {\r\n  return dependency && dependency[0] === '?' ? dependency.slice(1) : dependency;\r\n}"]},"metadata":{},"sourceType":"module"}