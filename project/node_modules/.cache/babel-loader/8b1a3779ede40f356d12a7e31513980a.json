{"ast":null,"code":"import { factory } from '../../../utils/factory.js';\nvar name = 'broadcast';\nvar dependancies = ['concat'];\nexport var createBroadcast = /* #__PURE__ */factory(name, dependancies, _ref => {\n  var {\n    concat\n  } = _ref;\n  /**\r\n  * Broadcasts two matrices, and return both in an array\r\n  * It checks if it's possible with broadcasting rules\r\n  *\r\n  * @param {Matrix}   A      First Matrix\r\n  * @param {Matrix}   B      Second Matrix\r\n  *\r\n  * @return {Matrix[]}      [ broadcastedA, broadcastedB ]\r\n  */\n\n  return function (A, B) {\n    var N = Math.max(A._size.length, B._size.length); // max number of dims\n\n    if (A._size.length === B._size.length) {\n      if (A._size.every((dim, i) => dim === B._size[i])) {\n        // If matrices have the same size return them\n        return [A, B];\n      }\n    }\n\n    var sizeA = _padLeft(A._size, N, 0); // pad to the left to align dimensions to the right\n\n\n    var sizeB = _padLeft(B._size, N, 0); // pad to the left to align dimensions to the right\n    // calculate the max dimensions\n\n\n    var sizeMax = [];\n\n    for (var dim = 0; dim < N; dim++) {\n      sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);\n    } // check if the broadcasting rules applyes for both matrices\n\n\n    for (var _dim = 0; _dim < N; _dim++) {\n      _checkRules(sizeA, sizeMax, _dim);\n\n      _checkRules(sizeB, sizeMax, _dim);\n    } // reshape A or B if needed to make them ready for concat\n\n\n    var AA = A.clone();\n    var BB = B.clone();\n\n    if (AA._size.length < N) {\n      AA.reshape(_padLeft(AA._size, N, 1));\n    } else if (BB._size.length < N) {\n      BB.reshape(_padLeft(BB._size, N, 1));\n    } // stretches the matrices on each dimension to make them the same size\n\n\n    for (var _dim2 = 0; _dim2 < N; _dim2++) {\n      if (AA._size[_dim2] < sizeMax[_dim2]) {\n        AA = _stretch(AA, sizeMax[_dim2], _dim2);\n      }\n\n      if (BB._size[_dim2] < sizeMax[_dim2]) {\n        BB = _stretch(BB, sizeMax[_dim2], _dim2);\n      }\n    } // return the array with the two broadcasted matrices\n\n\n    return [AA, BB];\n  };\n\n  function _padLeft(shape, N, filler) {\n    // pads an array of dimensions with numbers to the left, unitl the number of dimensions is N\n    return [...Array(N - shape.length).fill(filler), ...shape];\n  }\n\n  function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {\n    // stretches a matrix up to a certain size in a certain dimension\n    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);\n  }\n\n  function _checkRules(shape, sizeMax, dim) {\n    if (shape[dim] < sizeMax[dim] & shape[dim] > 1) {\n      throw new Error(\"shape missmatch: missmatch is found in arg with shape (\".concat(shape, \") not possible to broadcast dimension \").concat(dim, \" with size \").concat(shape[dim], \" to size \").concat(sizeMax[dim]));\n    }\n  }\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js"],"names":["factory","name","dependancies","createBroadcast","_ref","concat","A","B","N","Math","max","_size","length","every","dim","i","sizeA","_padLeft","sizeB","sizeMax","_dim","_checkRules","AA","clone","BB","reshape","_dim2","_stretch","shape","filler","Array","fill","arrayToStretch","sizeToStretch","dimToStretch","Error"],"mappings":"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","sourcesContent":["import { factory } from '../../../utils/factory.js';\r\nvar name = 'broadcast';\r\nvar dependancies = ['concat'];\r\nexport var createBroadcast = /* #__PURE__ */factory(name, dependancies, _ref => {\r\n  var {\r\n    concat\r\n  } = _ref;\r\n  /**\r\n  * Broadcasts two matrices, and return both in an array\r\n  * It checks if it's possible with broadcasting rules\r\n  *\r\n  * @param {Matrix}   A      First Matrix\r\n  * @param {Matrix}   B      Second Matrix\r\n  *\r\n  * @return {Matrix[]}      [ broadcastedA, broadcastedB ]\r\n  */\r\n  return function (A, B) {\r\n    var N = Math.max(A._size.length, B._size.length); // max number of dims\r\n    if (A._size.length === B._size.length) {\r\n      if (A._size.every((dim, i) => dim === B._size[i])) {\r\n        // If matrices have the same size return them\r\n        return [A, B];\r\n      }\r\n    }\r\n    var sizeA = _padLeft(A._size, N, 0); // pad to the left to align dimensions to the right\r\n    var sizeB = _padLeft(B._size, N, 0); // pad to the left to align dimensions to the right\r\n\r\n    // calculate the max dimensions\r\n    var sizeMax = [];\r\n    for (var dim = 0; dim < N; dim++) {\r\n      sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);\r\n    }\r\n\r\n    // check if the broadcasting rules applyes for both matrices\r\n    for (var _dim = 0; _dim < N; _dim++) {\r\n      _checkRules(sizeA, sizeMax, _dim);\r\n      _checkRules(sizeB, sizeMax, _dim);\r\n    }\r\n\r\n    // reshape A or B if needed to make them ready for concat\r\n    var AA = A.clone();\r\n    var BB = B.clone();\r\n    if (AA._size.length < N) {\r\n      AA.reshape(_padLeft(AA._size, N, 1));\r\n    } else if (BB._size.length < N) {\r\n      BB.reshape(_padLeft(BB._size, N, 1));\r\n    }\r\n\r\n    // stretches the matrices on each dimension to make them the same size\r\n    for (var _dim2 = 0; _dim2 < N; _dim2++) {\r\n      if (AA._size[_dim2] < sizeMax[_dim2]) {\r\n        AA = _stretch(AA, sizeMax[_dim2], _dim2);\r\n      }\r\n      if (BB._size[_dim2] < sizeMax[_dim2]) {\r\n        BB = _stretch(BB, sizeMax[_dim2], _dim2);\r\n      }\r\n    }\r\n\r\n    // return the array with the two broadcasted matrices\r\n    return [AA, BB];\r\n  };\r\n  function _padLeft(shape, N, filler) {\r\n    // pads an array of dimensions with numbers to the left, unitl the number of dimensions is N\r\n    return [...Array(N - shape.length).fill(filler), ...shape];\r\n  }\r\n  function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {\r\n    // stretches a matrix up to a certain size in a certain dimension\r\n    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);\r\n  }\r\n  function _checkRules(shape, sizeMax, dim) {\r\n    if (shape[dim] < sizeMax[dim] & shape[dim] > 1) {\r\n      throw new Error(\"shape missmatch: missmatch is found in arg with shape (\".concat(shape, \") not possible to broadcast dimension \").concat(dim, \" with size \").concat(shape[dim], \" to size \").concat(sizeMax[dim]));\r\n    }\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}