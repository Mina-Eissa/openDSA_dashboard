{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode } from '../../utils/is.js';\nimport { forEach, map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'BlockNode';\nvar dependencies = ['ResultSet', 'Node'];\nexport var createBlockNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    ResultSet,\n    Node\n  } = _ref;\n\n  class BlockNode extends Node {\n    /**\r\n     * @constructor BlockNode\r\n     * @extends {Node}\r\n     * Holds a set with blocks\r\n     * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks\r\n     *            An array with blocks, where a block is constructed as an\r\n     *            Object with properties block, which is a Node, and visible,\r\n     *            which is a boolean. The property visible is optional and\r\n     *            is true by default\r\n     */\n    constructor(blocks) {\n      super(); // validate input, copy blocks\n\n      if (!Array.isArray(blocks)) throw new Error('Array expected');\n      this.blocks = blocks.map(function (block) {\n        var node = block && block.node;\n        var visible = block && block.visible !== undefined ? block.visible : true;\n        if (!isNode(node)) throw new TypeError('Property \"node\" must be a Node');\n\n        if (typeof visible !== 'boolean') {\n          throw new TypeError('Property \"visible\" must be a boolean');\n        }\n\n        return {\n          node,\n          visible\n        };\n      });\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isBlockNode() {\n      return true;\n    }\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\n\n\n    _compile(math, argNames) {\n      var evalBlocks = map(this.blocks, function (block) {\n        return {\n          evaluate: block.node._compile(math, argNames),\n          visible: block.visible\n        };\n      });\n      return function evalBlockNodes(scope, args, context) {\n        var results = [];\n        forEach(evalBlocks, function evalBlockNode(block) {\n          var result = block.evaluate(scope, args, context);\n\n          if (block.visible) {\n            results.push(result);\n          }\n        });\n        return new ResultSet(results);\n      };\n    }\n    /**\r\n     * Execute a callback for each of the child blocks of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\n\n\n    forEach(callback) {\n      for (var i = 0; i < this.blocks.length; i++) {\n        callback(this.blocks[i].node, 'blocks[' + i + '].node', this);\n      }\n    }\n    /**\r\n     * Create a new BlockNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {BlockNode} Returns a transformed copy of the node\r\n     */\n\n\n    map(callback) {\n      var blocks = [];\n\n      for (var i = 0; i < this.blocks.length; i++) {\n        var block = this.blocks[i];\n\n        var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));\n\n        blocks[i] = {\n          node,\n          visible: block.visible\n        };\n      }\n\n      return new BlockNode(blocks);\n    }\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {BlockNode}\r\n     */\n\n\n    clone() {\n      var blocks = this.blocks.map(function (block) {\n        return {\n          node: block.node,\n          visible: block.visible\n        };\n      });\n      return new BlockNode(blocks);\n    }\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\n\n\n    _toString(options) {\n      return this.blocks.map(function (param) {\n        return param.node.toString(options) + (param.visible ? '' : ';');\n      }).join('\\n');\n    }\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        blocks: this.blocks\n      };\n    }\n    /**\r\n     * Instantiate an BlockNode from its JSON representation\r\n     * @param {Object} json\r\n     *     An object structured like\r\n     *     `{\"mathjs\": \"BlockNode\", blocks: [{node: ..., visible: false}, ...]}`,\r\n     *     where mathjs is optional\r\n     * @returns {BlockNode}\r\n     */\n\n\n    static fromJSON(json) {\n      return new BlockNode(json.blocks);\n    }\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\n\n\n    toHTML(options) {\n      return this.blocks.map(function (param) {\n        return param.node.toHTML(options) + (param.visible ? '' : '<span class=\"math-separator\">;</span>');\n      }).join('<span class=\"math-separator\"><br /></span>');\n    }\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    _toTex(options) {\n      return this.blocks.map(function (param) {\n        return param.node.toTex(options) + (param.visible ? '' : ';');\n      }).join('\\\\;\\\\;\\n');\n    }\n\n  }\n\n  _defineProperty(BlockNode, \"name\", name);\n\n  return BlockNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/expression/node/BlockNode.js"],"names":["_defineProperty","isNode","forEach","map","factory","name","dependencies","createBlockNode","_ref","ResultSet","Node","BlockNode","constructor","blocks","Array","isArray","Error","block","node","visible","undefined","TypeError","type","isBlockNode","_compile","math","argNames","evalBlocks","evaluate","evalBlockNodes","scope","args","context","results","evalBlockNode","result","push","callback","i","length","_ifNode","clone","_toString","options","param","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isClass"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\r\nimport { isNode } from '../../utils/is.js';\r\nimport { forEach, map } from '../../utils/array.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'BlockNode';\r\nvar dependencies = ['ResultSet', 'Node'];\r\nexport var createBlockNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    ResultSet,\r\n    Node\r\n  } = _ref;\r\n  class BlockNode extends Node {\r\n    /**\r\n     * @constructor BlockNode\r\n     * @extends {Node}\r\n     * Holds a set with blocks\r\n     * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks\r\n     *            An array with blocks, where a block is constructed as an\r\n     *            Object with properties block, which is a Node, and visible,\r\n     *            which is a boolean. The property visible is optional and\r\n     *            is true by default\r\n     */\r\n    constructor(blocks) {\r\n      super();\r\n      // validate input, copy blocks\r\n      if (!Array.isArray(blocks)) throw new Error('Array expected');\r\n      this.blocks = blocks.map(function (block) {\r\n        var node = block && block.node;\r\n        var visible = block && block.visible !== undefined ? block.visible : true;\r\n        if (!isNode(node)) throw new TypeError('Property \"node\" must be a Node');\r\n        if (typeof visible !== 'boolean') {\r\n          throw new TypeError('Property \"visible\" must be a boolean');\r\n        }\r\n        return {\r\n          node,\r\n          visible\r\n        };\r\n      });\r\n    }\r\n    get type() {\r\n      return name;\r\n    }\r\n    get isBlockNode() {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n    _compile(math, argNames) {\r\n      var evalBlocks = map(this.blocks, function (block) {\r\n        return {\r\n          evaluate: block.node._compile(math, argNames),\r\n          visible: block.visible\r\n        };\r\n      });\r\n      return function evalBlockNodes(scope, args, context) {\r\n        var results = [];\r\n        forEach(evalBlocks, function evalBlockNode(block) {\r\n          var result = block.evaluate(scope, args, context);\r\n          if (block.visible) {\r\n            results.push(result);\r\n          }\r\n        });\r\n        return new ResultSet(results);\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Execute a callback for each of the child blocks of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n    forEach(callback) {\r\n      for (var i = 0; i < this.blocks.length; i++) {\r\n        callback(this.blocks[i].node, 'blocks[' + i + '].node', this);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Create a new BlockNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {BlockNode} Returns a transformed copy of the node\r\n     */\r\n    map(callback) {\r\n      var blocks = [];\r\n      for (var i = 0; i < this.blocks.length; i++) {\r\n        var block = this.blocks[i];\r\n        var node = this._ifNode(callback(block.node, 'blocks[' + i + '].node', this));\r\n        blocks[i] = {\r\n          node,\r\n          visible: block.visible\r\n        };\r\n      }\r\n      return new BlockNode(blocks);\r\n    }\r\n\r\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {BlockNode}\r\n     */\r\n    clone() {\r\n      var blocks = this.blocks.map(function (block) {\r\n        return {\r\n          node: block.node,\r\n          visible: block.visible\r\n        };\r\n      });\r\n      return new BlockNode(blocks);\r\n    }\r\n\r\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n    _toString(options) {\r\n      return this.blocks.map(function (param) {\r\n        return param.node.toString(options) + (param.visible ? '' : ';');\r\n      }).join('\\n');\r\n    }\r\n\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n      return {\r\n        mathjs: name,\r\n        blocks: this.blocks\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Instantiate an BlockNode from its JSON representation\r\n     * @param {Object} json\r\n     *     An object structured like\r\n     *     `{\"mathjs\": \"BlockNode\", blocks: [{node: ..., visible: false}, ...]}`,\r\n     *     where mathjs is optional\r\n     * @returns {BlockNode}\r\n     */\r\n    static fromJSON(json) {\r\n      return new BlockNode(json.blocks);\r\n    }\r\n\r\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     * @override\r\n     */\r\n    toHTML(options) {\r\n      return this.blocks.map(function (param) {\r\n        return param.node.toHTML(options) + (param.visible ? '' : '<span class=\"math-separator\">;</span>');\r\n      }).join('<span class=\"math-separator\"><br /></span>');\r\n    }\r\n\r\n    /**\r\n     * Get LaTeX representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    _toTex(options) {\r\n      return this.blocks.map(function (param) {\r\n        return param.node.toTex(options) + (param.visible ? '' : ';');\r\n      }).join('\\\\;\\\\;\\n');\r\n    }\r\n  }\r\n  _defineProperty(BlockNode, \"name\", name);\r\n  return BlockNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"]},"metadata":{},"sourceType":"module"}