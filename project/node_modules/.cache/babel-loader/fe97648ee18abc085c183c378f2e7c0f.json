{"ast":null,"code":"// (c) 2018, Mariusz Nowak\n// SPDX-License-Identifier: ISC\n// Derived from https://github.com/medikoo/lru-queue\nexport function lruQueue(limit) {\n  var size = 0;\n  var base = 1;\n  var queue = Object.create(null);\n  var map = Object.create(null);\n  var index = 0;\n\n  var del = function del(id) {\n    var oldIndex = map[id];\n    if (!oldIndex) return;\n    delete queue[oldIndex];\n    delete map[id];\n    --size;\n    if (base !== oldIndex) return;\n\n    if (!size) {\n      index = 0;\n      base = 1;\n      return;\n    }\n\n    while (!hasOwnProperty.call(queue, ++base)) {\n      continue;\n    }\n  };\n\n  limit = Math.abs(limit);\n  return {\n    hit: function hit(id) {\n      var oldIndex = map[id];\n      var nuIndex = ++index;\n      queue[nuIndex] = id;\n      map[id] = nuIndex;\n\n      if (!oldIndex) {\n        ++size;\n        if (size <= limit) return undefined;\n        id = queue[base];\n        del(id);\n        return id;\n      }\n\n      delete queue[oldIndex];\n      if (base !== oldIndex) return undefined;\n\n      while (!hasOwnProperty.call(queue, ++base)) {\n        continue;\n      }\n\n      return undefined;\n    },\n    delete: del,\n    clear: function clear() {\n      size = index = 0;\n      base = 1;\n      queue = Object.create(null);\n      map = Object.create(null);\n    }\n  };\n}","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/utils/lruQueue.js"],"names":["lruQueue","limit","size","base","queue","Object","create","map","index","del","id","oldIndex","hasOwnProperty","call","Math","abs","hit","nuIndex","undefined","delete","clear"],"mappings":"AAAA;AACA;AACA;AACA,OAAO,SAASA,QAAT,CAAkBC,KAAlB,EAAyB;AAC9B,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAZ;AACA,MAAIC,GAAG,GAAGF,MAAM,CAACC,MAAP,CAAc,IAAd,CAAV;AACA,MAAIE,KAAK,GAAG,CAAZ;;AACA,MAAIC,GAAG,GAAG,SAASA,GAAT,CAAaC,EAAb,EAAiB;AACzB,QAAIC,QAAQ,GAAGJ,GAAG,CAACG,EAAD,CAAlB;AACA,QAAI,CAACC,QAAL,EAAe;AACf,WAAOP,KAAK,CAACO,QAAD,CAAZ;AACA,WAAOJ,GAAG,CAACG,EAAD,CAAV;AACA,MAAER,IAAF;AACA,QAAIC,IAAI,KAAKQ,QAAb,EAAuB;;AACvB,QAAI,CAACT,IAAL,EAAW;AACTM,MAAAA,KAAK,GAAG,CAAR;AACAL,MAAAA,IAAI,GAAG,CAAP;AACA;AACD;;AACD,WAAO,CAACS,cAAc,CAACC,IAAf,CAAoBT,KAApB,EAA2B,EAAED,IAA7B,CAAR,EAA4C;AAC1C;AACD;AACF,GAfD;;AAgBAF,EAAAA,KAAK,GAAGa,IAAI,CAACC,GAAL,CAASd,KAAT,CAAR;AACA,SAAO;AACLe,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAaN,EAAb,EAAiB;AACpB,UAAIC,QAAQ,GAAGJ,GAAG,CAACG,EAAD,CAAlB;AACA,UAAIO,OAAO,GAAG,EAAET,KAAhB;AACAJ,MAAAA,KAAK,CAACa,OAAD,CAAL,GAAiBP,EAAjB;AACAH,MAAAA,GAAG,CAACG,EAAD,CAAH,GAAUO,OAAV;;AACA,UAAI,CAACN,QAAL,EAAe;AACb,UAAET,IAAF;AACA,YAAIA,IAAI,IAAID,KAAZ,EAAmB,OAAOiB,SAAP;AACnBR,QAAAA,EAAE,GAAGN,KAAK,CAACD,IAAD,CAAV;AACAM,QAAAA,GAAG,CAACC,EAAD,CAAH;AACA,eAAOA,EAAP;AACD;;AACD,aAAON,KAAK,CAACO,QAAD,CAAZ;AACA,UAAIR,IAAI,KAAKQ,QAAb,EAAuB,OAAOO,SAAP;;AACvB,aAAO,CAACN,cAAc,CAACC,IAAf,CAAoBT,KAApB,EAA2B,EAAED,IAA7B,CAAR,EAA4C;AAC1C;AACD;;AACD,aAAOe,SAAP;AACD,KAnBI;AAoBLC,IAAAA,MAAM,EAAEV,GApBH;AAqBLW,IAAAA,KAAK,EAAE,SAASA,KAAT,GAAiB;AACtBlB,MAAAA,IAAI,GAAGM,KAAK,GAAG,CAAf;AACAL,MAAAA,IAAI,GAAG,CAAP;AACAC,MAAAA,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAR;AACAC,MAAAA,GAAG,GAAGF,MAAM,CAACC,MAAP,CAAc,IAAd,CAAN;AACD;AA1BI,GAAP;AA4BD","sourcesContent":["// (c) 2018, Mariusz Nowak\r\n// SPDX-License-Identifier: ISC\r\n// Derived from https://github.com/medikoo/lru-queue\r\nexport function lruQueue(limit) {\r\n  var size = 0;\r\n  var base = 1;\r\n  var queue = Object.create(null);\r\n  var map = Object.create(null);\r\n  var index = 0;\r\n  var del = function del(id) {\r\n    var oldIndex = map[id];\r\n    if (!oldIndex) return;\r\n    delete queue[oldIndex];\r\n    delete map[id];\r\n    --size;\r\n    if (base !== oldIndex) return;\r\n    if (!size) {\r\n      index = 0;\r\n      base = 1;\r\n      return;\r\n    }\r\n    while (!hasOwnProperty.call(queue, ++base)) {\r\n      continue;\r\n    }\r\n  };\r\n  limit = Math.abs(limit);\r\n  return {\r\n    hit: function hit(id) {\r\n      var oldIndex = map[id];\r\n      var nuIndex = ++index;\r\n      queue[nuIndex] = id;\r\n      map[id] = nuIndex;\r\n      if (!oldIndex) {\r\n        ++size;\r\n        if (size <= limit) return undefined;\r\n        id = queue[base];\r\n        del(id);\r\n        return id;\r\n      }\r\n      delete queue[oldIndex];\r\n      if (base !== oldIndex) return undefined;\r\n      while (!hasOwnProperty.call(queue, ++base)) {\r\n        continue;\r\n      }\r\n      return undefined;\r\n    },\r\n    delete: del,\r\n    clear: function clear() {\r\n      size = index = 0;\r\n      base = 1;\r\n      queue = Object.create(null);\r\n      map = Object.create(null);\r\n    }\r\n  };\r\n}"]},"metadata":{},"sourceType":"module"}