{"ast":null,"code":"/* eslint-disable jsdoc/require-returns */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n\n/**\r\n * StripLine src\r\n */\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { valueToCoefficient, textElement, RectOption, appendChildElement, appendClipElement, withIn, getElement } from '../../common/utils/helper';\nimport { measureText, TextOption, PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\r\n * `StripLine` module is used to render the stripLine in chart.\r\n */\n\nvar StripLine =\n/** @class */\nfunction () {\n  function StripLine() {}\n  /**\r\n   * Finding x, y, width and height of the strip line\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {StripLineSettingsModel} stripline stripline\r\n   * @param {Rect} seriesClipRect seriesClipRect\r\n   * @param {number} startValue startValue\r\n   * @param {Axis} segmentAxis segmentAxis\r\n   * @param {Chart} chart chart instance\r\n   */\n\n\n  StripLine.prototype.measureStripLine = function (axis, stripline, seriesClipRect, startValue, segmentAxis, chart) {\n    var actualStart;\n    var actualEnd;\n    var orientation = axis.orientation;\n    var isDateTimeAxis = axis.valueType === 'DateTime';\n\n    if (stripline.isRepeat && stripline.size !== null) {\n      actualStart = startValue;\n      actualEnd = null;\n    } else {\n      if (axis.valueType === 'DateTimeCategory') {\n        var start = stripline.start;\n        var end = stripline.end;\n        actualStart = start != null && typeof start !== 'number' ? axis.labels.indexOf(this.dateToMilliSeconds(start, chart).toString()) : start;\n        actualEnd = end != null && typeof end !== 'number' ? axis.labels.indexOf(this.dateToMilliSeconds(end, chart).toString()) : end;\n      } else {\n        actualStart = stripline.start === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ? this.dateToMilliSeconds(stripline.start, chart) : +stripline.start;\n        actualEnd = stripline.end === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ? this.dateToMilliSeconds(stripline.end, chart) : +stripline.end;\n      }\n    }\n\n    var rect = this.getFromTovalue(actualStart, actualEnd, stripline.size, stripline.startFromAxis, axis, stripline);\n    var height = orientation === 'Vertical' ? (rect.to - rect.from) * axis.rect.height : seriesClipRect.height;\n    var width = orientation === 'Horizontal' ? (rect.to - rect.from) * axis.rect.width : seriesClipRect.width;\n    var x = orientation === 'Vertical' ? seriesClipRect.x : rect.from * axis.rect.width + axis.rect.x;\n    var y = orientation === 'Horizontal' ? seriesClipRect.y : axis.rect.y + axis.rect.height - (stripline.sizeType === 'Pixel' ? rect.from : rect.to) * axis.rect.height;\n\n    if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== 'Pixel') {\n      var start = isDateTimeAxis && this.isCoreDate(stripline.segmentStart) ? this.dateToMilliSeconds(stripline.segmentStart, chart) : +stripline.segmentStart;\n      var end = isDateTimeAxis && this.isCoreDate(stripline.segmentEnd) ? this.dateToMilliSeconds(stripline.segmentEnd, chart) : +stripline.segmentEnd;\n      var segRect = this.getFromTovalue(start, end, null, null, segmentAxis, stripline);\n\n      if (segmentAxis.orientation === 'Vertical') {\n        y = segmentAxis.rect.y + segmentAxis.rect.height - segRect.to * segmentAxis.rect.height;\n        height = (segRect.to - segRect.from) * segmentAxis.rect.height;\n      } else {\n        x = segRect.from * segmentAxis.rect.width + segmentAxis.rect.x;\n        width = (segRect.to - segRect.from) * segmentAxis.rect.width;\n      }\n    }\n\n    if (height !== 0 && width !== 0 || stripline.sizeType === 'Pixel' && (stripline.start !== null || stripline.startFromAxis)) {\n      return new Rect(x, y, width, height);\n    }\n\n    return new Rect(0, 0, 0, 0);\n  };\n  /**\r\n   * To get from to value from start, end, size, start from axis\r\n   *\r\n   * @param {number} start start\r\n   * @param {number} end end\r\n   * @param {number} size size\r\n   * @param {boolean} startFromAxis startFromAxis\r\n   * @param {Axis} axis axis\r\n   * @param {StripLineSettingsModel} stripline stripline\r\n   */\n\n\n  StripLine.prototype.getFromTovalue = function (start, end, size, startFromAxis, axis, stripline) {\n    var from = !stripline.isRepeat && startFromAxis ? axis.visibleRange.min : start;\n    var to = this.getToValue(Math.max(start, isNullOrUndefined(end) ? start : end), from, size, axis, end, stripline);\n    from = this.findValue(from, axis);\n    to = this.findValue(to, axis);\n    return {\n      from: valueToCoefficient(axis.isAxisInverse ? to : from, axis),\n      to: valueToCoefficient(axis.isAxisInverse ? from : to, axis)\n    };\n  };\n  /**\r\n   * Finding end value of the strip line\r\n   *\r\n   * @param {number} to to\r\n   * @param {number} from from\r\n   * @param {number} size size\r\n   * @param {Axis} axis axis\r\n   * @param {number} end end\r\n   * @param {StripLineSettingsModel} stripline stripline\r\n   */\n\n\n  StripLine.prototype.getToValue = function (to, from, size, axis, end, stripline) {\n    var sizeType = stripline.sizeType;\n    var isEnd = end === null;\n\n    if (axis.valueType === 'DateTime') {\n      var fromValue = new Date(from);\n\n      if (sizeType === 'Auto') {\n        sizeType = axis.actualIntervalType;\n        size *= axis.visibleRange.interval;\n      }\n\n      switch (sizeType) {\n        case 'Years':\n          return isEnd ? new Date(fromValue.setFullYear(fromValue.getFullYear() + size)) : to;\n\n        case 'Months':\n          return isEnd ? new Date(fromValue.setMonth(fromValue.getMonth() + size)) : to;\n\n        case 'Days':\n          return isEnd ? new Date(fromValue.setDate(fromValue.getDate() + size)) : to;\n\n        case 'Hours':\n          return isEnd ? new Date(fromValue.setHours(fromValue.getHours() + size)) : to;\n\n        case 'Minutes':\n          return isEnd ? new Date(fromValue.setMinutes(fromValue.getMinutes() + size)) : to;\n\n        case 'Seconds':\n          return isEnd ? new Date(fromValue.setSeconds(fromValue.getSeconds() + size)) : to;\n\n        default:\n          return from;\n      }\n    } else {\n      return stripline.sizeType === 'Pixel' ? from : isEnd ? from + size : to;\n    }\n  };\n  /**\r\n   * To check the strip line values within range\r\n   *\r\n   * @param {number} value value\r\n   * @param {Axis} axis axis\r\n   */\n\n\n  StripLine.prototype.findValue = function (value, axis) {\n    if (value < axis.visibleRange.min) {\n      value = axis.visibleRange.min;\n    } else if (value > axis.visibleRange.max) {\n      value = axis.visibleRange.max;\n    }\n\n    return value;\n  };\n  /**\r\n   * Date parse\r\n   *\r\n   * @param {Date} value date\r\n   * @param {Chart} chart chart instance\r\n   * @returns {Date} parsed date\r\n   */\n\n\n  StripLine.prototype.dateParse = function (value, chart) {\n    var dateParser = chart.intl.getDateParser({\n      skeleton: 'full',\n      type: 'dateTime'\n    });\n    var dateFormatter = chart.intl.getDateFormat({\n      skeleton: 'full',\n      type: 'dateTime'\n    });\n    return new Date(Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({\n      val: value\n    }).val)))));\n  };\n  /**\r\n   * To render strip lines based start and end.\r\n   *\r\n   * @param {Chart} chart chart\r\n   * @param {ZIndex} position position\r\n   * @param {Axis[]} axes axes\r\n   * @private\r\n   */\n\n\n  StripLine.prototype.renderStripLine = function (chart, position, axes) {\n    var id = chart.element.id + '_stripline_' + position + '_';\n    var seriesClipRect = chart.chartAxisLayoutPanel.seriesClipRect;\n    var end = 0;\n    var limit = 0;\n    var startValue = 0;\n    var segmentAxis = null;\n    var range;\n    var options = new RectOption(id + 'ClipRect', 'transparent', {\n      width: 1,\n      color: 'Gray'\n    }, 1, {\n      x: chart.initialClipRect.x,\n      y: chart.initialClipRect.y,\n      width: chart.initialClipRect.width,\n      height: chart.initialClipRect.height\n    });\n    var striplineGroup = chart.renderer.createGroup({\n      id: id + 'collections',\n      'clip-path': 'url(#' + id + 'ClipRect' + ')'\n    });\n\n    if (!chart.enableCanvas) {\n      striplineGroup.appendChild(appendClipElement(chart.redraw, options, chart.renderer));\n    }\n\n    for (var _i = 0, axes_1 = axes; _i < axes_1.length; _i++) {\n      var axis = axes_1[_i];\n      var count = 0;\n\n      for (var _a = 0, _b = axis.stripLines; _a < _b.length; _a++) {\n        var stripline = _b[_a];\n\n        if (stripline.visible && stripline.zIndex === position) {\n          if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== 'Pixel') {\n            segmentAxis = this.getSegmentAxis(axes, axis, stripline);\n          }\n\n          if (stripline.isRepeat && stripline.repeatEvery != null && stripline.size !== null && stripline.sizeType !== 'Pixel') {\n            limit = stripline.repeatUntil != null ? axis.valueType === 'DateTime' ? this.dateToMilliSeconds(stripline.repeatUntil, chart) : +stripline.repeatUntil : axis.actualRange.max;\n            startValue = axis.valueType === 'DateTime' && this.isCoreDate(stripline.start) ? this.dateToMilliSeconds(stripline.start, chart) : stripline.start;\n\n            if (stripline.startFromAxis && axis.valueType === 'DateTime' && stripline.sizeType === 'Auto' || stripline.start < axis.visibleRange.min) {\n              startValue = axis.visibleLabels[0].value === axis.visibleRange.min ? axis.visibleRange.min : axis.visibleLabels[0].value - (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval);\n            }\n\n            startValue = stripline.startFromAxis && axis.valueType !== 'DateTime' ? axis.visibleRange.min : startValue;\n\n            while (startValue < limit) {\n              end = startValue + (axis.valueType === 'DateTime' ? axis.dateTimeInterval * +stripline.size : stripline.size);\n              range = withIn(end, axis.visibleRange);\n\n              if (startValue >= axis.visibleRange.min && startValue < axis.visibleRange.max || range) {\n                this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count);\n              }\n\n              count++;\n              startValue = this.getStartValue(axis, stripline, startValue, chart);\n            }\n          } else {\n            this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, null, segmentAxis, count);\n            count++;\n          }\n        }\n      }\n    }\n\n    appendChildElement(chart.enableCanvas, chart.svgObject, striplineGroup, chart.redraw);\n  };\n  /**\r\n   * To convert the C# date to js date\r\n   *\r\n   * @param {string | number | Object} value date value\r\n   * @returns {boolean} returns true if datetime value type is string(for asp platform)\r\n   */\n\n\n  StripLine.prototype.isCoreDate = function (value) {\n    return typeof value === 'string' ? true : false;\n  };\n  /**\r\n   * To get the total milli seconds\r\n   *\r\n   * @param {Date | number | Object} value date value\r\n   * @param {Chart} chart chart instance\r\n   * @returns {number} returns milliseconds\r\n   */\n\n\n  StripLine.prototype.dateToMilliSeconds = function (value, chart) {\n    return this.dateParse(value, chart).getTime();\n  };\n  /**\r\n   * To draw the single line strip line\r\n   *\r\n   * @param {StripLineSettingsModel} stripline stripline\r\n   * @param {Rect} rect rect\r\n   * @param {string} id id\r\n   * @param {Element} parent parent\r\n   * @param {Chart} chart chart\r\n   * @param {Axis} axis axis\r\n   */\n\n\n  StripLine.prototype.renderPath = function (stripline, rect, id, parent, chart, axis) {\n    var element = getElement(id);\n    var direction = element ? element.getAttribute('d') : '';\n    var d = axis.orientation === 'Vertical' ? 'M ' + rect.x + ' ' + rect.y + ' ' + 'L ' + (rect.x + rect.width) + ' ' + rect.y : 'M ' + rect.x + ' ' + rect.y + ' ' + 'L ' + rect.x + ' ' + (rect.y + rect.height);\n    appendChildElement(chart.enableCanvas, parent, chart.renderer.drawPath(new PathOption(id, 'none', stripline.size, stripline.color, stripline.opacity, stripline.dashArray, d)), chart.redraw, true, 'x', 'y', null, direction, true);\n  };\n  /**\r\n   * To draw the rectangle\r\n   *\r\n   * @param {StripLineSettingsModel} stripline stripline\r\n   * @param {Rect} rect rect\r\n   * @param {string} id id\r\n   * @param {Element} parent parent\r\n   * @param {Chart} chart chart\r\n   */\n\n\n  StripLine.prototype.renderRectangle = function (stripline, rect, id, parent, chart) {\n    var element = getElement(id);\n    var previousRect = element ? new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')) : null;\n    appendChildElement(chart.enableCanvas, parent, chart.renderer.drawRectangle(new RectOption(id, stripline.color, stripline.border, stripline.opacity, rect, 0, 0, '', stripline.dashArray)), chart.redraw, true, 'x', 'y', null, null, true, true, previousRect);\n  };\n  /**\r\n   * To create the text on strip line\r\n   *\r\n   * @param {StripLineSettingsModel} stripline stripline\r\n   * @param {Rect} rect rect\r\n   * @param {string} id id\r\n   * @param {Element} parent parent\r\n   * @param {Chart} chart chart\r\n   * @param {Axis} axis axis\r\n   */\n\n\n  StripLine.prototype.renderText = function (stripline, rect, id, parent, chart, axis) {\n    var textSize = measureText(stripline.text, stripline.textStyle);\n    var isRotationNull = stripline.rotation === null;\n    var textMid = isRotationNull ? 3 * (textSize.height / 8) : 0;\n    var ty = rect.y + rect.height / 2 + textMid;\n    var rotation = isRotationNull ? axis.orientation === 'Vertical' ? 0 : -90 : stripline.rotation;\n    var tx = rect.x + rect.width / 2;\n    var anchor;\n    var padding = 5;\n\n    if (axis.orientation === 'Horizontal') {\n      tx = this.getTextStart(tx + textMid * this.factor(stripline.horizontalAlignment), rect.width, stripline.horizontalAlignment);\n      ty = this.getTextStart(ty - textMid, rect.height, stripline.verticalAlignment) + (stripline.verticalAlignment === 'Start' && !isRotationNull ? textSize.height / 4 : 0);\n      anchor = isRotationNull ? this.invertAlignment(stripline.verticalAlignment) : stripline.horizontalAlignment;\n    } else {\n      tx = this.getTextStart(tx, rect.width, stripline.horizontalAlignment);\n      ty = this.getTextStart(ty + textMid * this.factor(stripline.verticalAlignment) - padding, rect.height, stripline.verticalAlignment);\n      anchor = stripline.horizontalAlignment;\n    }\n\n    textElement(chart.renderer, new TextOption(id, tx, ty, anchor, stripline.text, 'rotate(' + rotation + ' ' + tx + ',' + ty + ')', 'middle'), stripline.textStyle, stripline.textStyle.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas);\n  };\n\n  StripLine.prototype.invertAlignment = function (anchor) {\n    switch (anchor) {\n      case 'Start':\n        anchor = 'End';\n        break;\n\n      case 'End':\n        anchor = 'Start';\n        break;\n    }\n\n    return anchor;\n  };\n  /**\r\n   * To find the next value of the recurrence strip line\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {StripLineSettingsModel} stripline stripline\r\n   * @param {number} startValue startValue\r\n   * @param {Chart} chart chart instance\r\n   * @returns {number} next start value of the recurrence strip line\r\n   */\n\n\n  StripLine.prototype.getStartValue = function (axis, stripline, startValue, chart) {\n    if (axis.valueType === 'DateTime') {\n      return this.getToValue(null, startValue, +stripline.repeatEvery, axis, null, stripline);\n    } else {\n      return startValue + +stripline.repeatEvery;\n    }\n  };\n  /**\r\n   * Finding segment axis for segmented strip line\r\n   *\r\n   * @param {Axis[]} axes axes collection\r\n   * @param {Axis} axis axis\r\n   * @param {StripLineSettingsModel} stripline stripline\r\n   */\n\n\n  StripLine.prototype.getSegmentAxis = function (axes, axis, stripline) {\n    var segment;\n\n    if (stripline.segmentAxisName == null) {\n      return axis.orientation === 'Horizontal' ? axes[1] : axes[0];\n    } else {\n      for (var i = 0; i < axes.length; i++) {\n        if (stripline.segmentAxisName === axes[i].name) {\n          segment = axes[i];\n        }\n      }\n\n      return segment;\n    }\n  };\n  /**\r\n   * To render strip line on chart\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {StripLineSettingsModel} stripline stripline\r\n   * @param {Rect} seriesClipRect seriesClipRect\r\n   * @param {string} id id\r\n   * @param {Element} striplineGroup striplineGroup\r\n   * @param {Chart} chart chart\r\n   * @param {number} startValue startValue\r\n   * @param {Axis} segmentAxis segmentAxis\r\n   * @param {number} count count\r\n   */\n\n\n  StripLine.prototype.renderStripLineElement = function (axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count) {\n    var rect = this.measureStripLine(axis, stripline, seriesClipRect, startValue, segmentAxis, chart);\n\n    if (stripline.sizeType === 'Pixel') {\n      this.renderPath(stripline, rect, id + 'path_' + axis.name + '_' + count, striplineGroup, chart, axis);\n    } else {\n      if (rect.height !== 0 && rect.width !== 0) {\n        this.renderRectangle(stripline, rect, id + 'rect_' + axis.name + '_' + count, striplineGroup, chart);\n      }\n    }\n\n    if (stripline.text !== '') {\n      this.renderText(stripline, rect, id + 'text_' + axis.name + '_' + count, striplineGroup, chart, axis);\n    }\n  };\n  /**\r\n   * To find the factor of the text\r\n   *\r\n   * @param {Anchor} anchor text anchor\r\n   */\n\n\n  StripLine.prototype.factor = function (anchor) {\n    var factor = 0;\n\n    switch (anchor) {\n      case 'Start':\n        factor = 1;\n        break;\n\n      case 'End':\n        factor = -1;\n        break;\n    }\n\n    return factor;\n  };\n  /**\r\n   * To find the start value of the text\r\n   *\r\n   * @param {number} xy xy values\r\n   * @param {number} size text size\r\n   * @param {Anchor} textAlignment text alignment\r\n   */\n\n\n  StripLine.prototype.getTextStart = function (xy, size, textAlignment) {\n    var padding = 5;\n\n    switch (textAlignment) {\n      case 'Start':\n        xy = xy - size / 2 + padding;\n        break;\n\n      case 'End':\n        xy = xy + size / 2 - padding;\n        break;\n    }\n\n    return xy;\n  };\n  /**\r\n   * To get the module name for `StripLine`.\r\n   *\r\n   * @private\r\n   */\n\n\n  StripLine.prototype.getModuleName = function () {\n    return 'StripLine';\n  };\n  /**\r\n   * To destroy the `StripLine` module.\r\n   *\r\n   * @private\r\n   */\n\n\n  StripLine.prototype.destroy = function () {// destroy peform here\n  };\n\n  return StripLine;\n}();\n\nexport { StripLine };","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/chart/axis/strip-line.js"],"names":["isNullOrUndefined","valueToCoefficient","textElement","RectOption","appendChildElement","appendClipElement","withIn","getElement","measureText","TextOption","PathOption","Rect","DataUtil","StripLine","prototype","measureStripLine","axis","stripline","seriesClipRect","startValue","segmentAxis","chart","actualStart","actualEnd","orientation","isDateTimeAxis","valueType","isRepeat","size","start","end","labels","indexOf","dateToMilliSeconds","toString","isCoreDate","rect","getFromTovalue","startFromAxis","height","to","from","width","x","y","sizeType","isSegmented","segmentStart","segmentEnd","segRect","visibleRange","min","getToValue","Math","max","findValue","isAxisInverse","isEnd","fromValue","Date","actualIntervalType","interval","setFullYear","getFullYear","setMonth","getMonth","setDate","getDate","setHours","getHours","setMinutes","getMinutes","setSeconds","getSeconds","value","dateParse","dateParser","intl","getDateParser","skeleton","type","dateFormatter","getDateFormat","parse","parseJson","val","renderStripLine","position","axes","id","element","chartAxisLayoutPanel","limit","range","options","color","initialClipRect","striplineGroup","renderer","createGroup","enableCanvas","appendChild","redraw","_i","axes_1","length","count","_a","_b","stripLines","visible","zIndex","getSegmentAxis","repeatEvery","repeatUntil","actualRange","visibleLabels","dateTimeInterval","renderStripLineElement","getStartValue","svgObject","getTime","renderPath","parent","direction","getAttribute","d","drawPath","opacity","dashArray","renderRectangle","previousRect","drawRectangle","border","renderText","textSize","text","textStyle","isRotationNull","rotation","textMid","ty","tx","anchor","padding","getTextStart","factor","horizontalAlignment","verticalAlignment","invertAlignment","segment","segmentAxisName","i","name","xy","textAlignment","getModuleName","destroy"],"mappings":"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","sourcesContent":["/* eslint-disable jsdoc/require-returns */\r\n/* eslint-disable valid-jsdoc */\r\n/* eslint-disable @typescript-eslint/no-inferrable-types */\r\n/**\r\n * StripLine src\r\n */\r\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\r\nimport { valueToCoefficient, textElement, RectOption, appendChildElement, appendClipElement, withIn, getElement } from '../../common/utils/helper';\r\nimport { measureText, TextOption, PathOption, Rect } from '@syncfusion/ej2-svg-base';\r\nimport { DataUtil } from '@syncfusion/ej2-data';\r\n/**\r\n * `StripLine` module is used to render the stripLine in chart.\r\n */\r\nvar StripLine = /** @class */ (function () {\r\n    function StripLine() {\r\n    }\r\n    /**\r\n     * Finding x, y, width and height of the strip line\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {StripLineSettingsModel} stripline stripline\r\n     * @param {Rect} seriesClipRect seriesClipRect\r\n     * @param {number} startValue startValue\r\n     * @param {Axis} segmentAxis segmentAxis\r\n     * @param {Chart} chart chart instance\r\n     */\r\n    StripLine.prototype.measureStripLine = function (axis, stripline, seriesClipRect, startValue, segmentAxis, chart) {\r\n        var actualStart;\r\n        var actualEnd;\r\n        var orientation = axis.orientation;\r\n        var isDateTimeAxis = axis.valueType === 'DateTime';\r\n        if (stripline.isRepeat && stripline.size !== null) {\r\n            actualStart = startValue;\r\n            actualEnd = null;\r\n        }\r\n        else {\r\n            if (axis.valueType === 'DateTimeCategory') {\r\n                var start = stripline.start;\r\n                var end = stripline.end;\r\n                actualStart = (start != null && typeof start !== 'number') ?\r\n                    axis.labels.indexOf(this.dateToMilliSeconds(start, chart).toString()) : start;\r\n                actualEnd = (end != null && typeof end !== 'number') ?\r\n                    axis.labels.indexOf(this.dateToMilliSeconds(end, chart).toString()) : end;\r\n            }\r\n            else {\r\n                actualStart = stripline.start === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ?\r\n                    this.dateToMilliSeconds(stripline.start, chart) : +stripline.start;\r\n                actualEnd = stripline.end === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ?\r\n                    this.dateToMilliSeconds(stripline.end, chart) : +stripline.end;\r\n            }\r\n        }\r\n        var rect = this.getFromTovalue(actualStart, actualEnd, stripline.size, stripline.startFromAxis, axis, stripline);\r\n        var height = (orientation === 'Vertical') ? (rect.to - rect.from) * axis.rect.height : seriesClipRect.height;\r\n        var width = (orientation === 'Horizontal') ? (rect.to - rect.from) * axis.rect.width : seriesClipRect.width;\r\n        var x = (orientation === 'Vertical') ? seriesClipRect.x : ((rect.from * axis.rect.width) + axis.rect.x);\r\n        var y = (orientation === 'Horizontal') ? seriesClipRect.y : (axis.rect.y + axis.rect.height -\r\n            ((stripline.sizeType === 'Pixel' ? rect.from : rect.to) * axis.rect.height));\r\n        if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== 'Pixel') {\r\n            var start = isDateTimeAxis && this.isCoreDate(stripline.segmentStart) ?\r\n                this.dateToMilliSeconds(stripline.segmentStart, chart) : +stripline.segmentStart;\r\n            var end = isDateTimeAxis && this.isCoreDate(stripline.segmentEnd) ?\r\n                this.dateToMilliSeconds(stripline.segmentEnd, chart) : +stripline.segmentEnd;\r\n            var segRect = this.getFromTovalue(start, end, null, null, segmentAxis, stripline);\r\n            if (segmentAxis.orientation === 'Vertical') {\r\n                y = (segmentAxis.rect.y + segmentAxis.rect.height -\r\n                    (segRect.to * segmentAxis.rect.height));\r\n                height = (segRect.to - segRect.from) * segmentAxis.rect.height;\r\n            }\r\n            else {\r\n                x = ((segRect.from * segmentAxis.rect.width) + segmentAxis.rect.x);\r\n                width = (segRect.to - segRect.from) * segmentAxis.rect.width;\r\n            }\r\n        }\r\n        if ((height !== 0 && width !== 0) || (stripline.sizeType === 'Pixel' && (stripline.start !== null || stripline.startFromAxis))) {\r\n            return new Rect(x, y, width, height);\r\n        }\r\n        return new Rect(0, 0, 0, 0);\r\n    };\r\n    /**\r\n     * To get from to value from start, end, size, start from axis\r\n     *\r\n     * @param {number} start start\r\n     * @param {number} end end\r\n     * @param {number} size size\r\n     * @param {boolean} startFromAxis startFromAxis\r\n     * @param {Axis} axis axis\r\n     * @param {StripLineSettingsModel} stripline stripline\r\n     */\r\n    StripLine.prototype.getFromTovalue = function (start, end, size, startFromAxis, axis, stripline) {\r\n        var from = (!stripline.isRepeat && startFromAxis) ? axis.visibleRange.min : start;\r\n        var to = this.getToValue(Math.max(start, isNullOrUndefined(end) ? start : end), from, size, axis, end, stripline);\r\n        from = this.findValue(from, axis);\r\n        to = this.findValue(to, axis);\r\n        return { from: valueToCoefficient(axis.isAxisInverse ? to : from, axis), to: valueToCoefficient(axis.isAxisInverse ? from : to, axis) };\r\n    };\r\n    /**\r\n     * Finding end value of the strip line\r\n     *\r\n     * @param {number} to to\r\n     * @param {number} from from\r\n     * @param {number} size size\r\n     * @param {Axis} axis axis\r\n     * @param {number} end end\r\n     * @param {StripLineSettingsModel} stripline stripline\r\n     */\r\n    StripLine.prototype.getToValue = function (to, from, size, axis, end, stripline) {\r\n        var sizeType = stripline.sizeType;\r\n        var isEnd = (end === null);\r\n        if (axis.valueType === 'DateTime') {\r\n            var fromValue = new Date(from);\r\n            if (sizeType === 'Auto') {\r\n                sizeType = axis.actualIntervalType;\r\n                size *= axis.visibleRange.interval;\r\n            }\r\n            switch (sizeType) {\r\n                case 'Years':\r\n                    return (isEnd ? new Date(fromValue.setFullYear(fromValue.getFullYear() + size)) : to);\r\n                case 'Months':\r\n                    return (isEnd ? new Date(fromValue.setMonth(fromValue.getMonth() + size)) : to);\r\n                case 'Days':\r\n                    return (isEnd ? new Date(fromValue.setDate(fromValue.getDate() + size)) : to);\r\n                case 'Hours':\r\n                    return (isEnd ? new Date(fromValue.setHours(fromValue.getHours() + size)) : to);\r\n                case 'Minutes':\r\n                    return (isEnd ? new Date(fromValue.setMinutes(fromValue.getMinutes() + size)) : to);\r\n                case 'Seconds':\r\n                    return (isEnd ? new Date(fromValue.setSeconds(fromValue.getSeconds() + size)) : to);\r\n                default:\r\n                    return from;\r\n            }\r\n        }\r\n        else {\r\n            return stripline.sizeType === 'Pixel' ? from : (isEnd ? (from + size) : to);\r\n        }\r\n    };\r\n    /**\r\n     * To check the strip line values within range\r\n     *\r\n     * @param {number} value value\r\n     * @param {Axis} axis axis\r\n     */\r\n    StripLine.prototype.findValue = function (value, axis) {\r\n        if (value < axis.visibleRange.min) {\r\n            value = axis.visibleRange.min;\r\n        }\r\n        else if (value > axis.visibleRange.max) {\r\n            value = axis.visibleRange.max;\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * Date parse\r\n     *\r\n     * @param {Date} value date\r\n     * @param {Chart} chart chart instance\r\n     * @returns {Date} parsed date\r\n     */\r\n    StripLine.prototype.dateParse = function (value, chart) {\r\n        var dateParser = chart.intl.getDateParser({ skeleton: 'full', type: 'dateTime' });\r\n        var dateFormatter = chart.intl.getDateFormat({ skeleton: 'full', type: 'dateTime' });\r\n        return new Date((Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: value }).val))))));\r\n    };\r\n    /**\r\n     * To render strip lines based start and end.\r\n     *\r\n     * @param {Chart} chart chart\r\n     * @param {ZIndex} position position\r\n     * @param {Axis[]} axes axes\r\n     * @private\r\n     */\r\n    StripLine.prototype.renderStripLine = function (chart, position, axes) {\r\n        var id = chart.element.id + '_stripline_' + position + '_';\r\n        var seriesClipRect = chart.chartAxisLayoutPanel.seriesClipRect;\r\n        var end = 0;\r\n        var limit = 0;\r\n        var startValue = 0;\r\n        var segmentAxis = null;\r\n        var range;\r\n        var options = new RectOption(id + 'ClipRect', 'transparent', { width: 1, color: 'Gray' }, 1, {\r\n            x: chart.initialClipRect.x, y: chart.initialClipRect.y,\r\n            width: chart.initialClipRect.width,\r\n            height: chart.initialClipRect.height\r\n        });\r\n        var striplineGroup = chart.renderer.createGroup({\r\n            id: id + 'collections',\r\n            'clip-path': 'url(#' + id + 'ClipRect' + ')'\r\n        });\r\n        if (!chart.enableCanvas) {\r\n            striplineGroup.appendChild(appendClipElement(chart.redraw, options, chart.renderer));\r\n        }\r\n        for (var _i = 0, axes_1 = axes; _i < axes_1.length; _i++) {\r\n            var axis = axes_1[_i];\r\n            var count = 0;\r\n            for (var _a = 0, _b = axis.stripLines; _a < _b.length; _a++) {\r\n                var stripline = _b[_a];\r\n                if (stripline.visible && stripline.zIndex === position) {\r\n                    if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null &&\r\n                        stripline.sizeType !== 'Pixel') {\r\n                        segmentAxis = this.getSegmentAxis(axes, axis, stripline);\r\n                    }\r\n                    if (stripline.isRepeat && stripline.repeatEvery != null && stripline.size !== null && stripline.sizeType !== 'Pixel') {\r\n                        limit = (stripline.repeatUntil != null) ? ((axis.valueType === 'DateTime') ?\r\n                            this.dateToMilliSeconds(stripline.repeatUntil, chart) : +stripline.repeatUntil) : axis.actualRange.max;\r\n                        startValue = axis.valueType === 'DateTime' && this.isCoreDate(stripline.start) ?\r\n                            this.dateToMilliSeconds(stripline.start, chart) : stripline.start;\r\n                        if ((stripline.startFromAxis && axis.valueType === 'DateTime' && stripline.sizeType === 'Auto') ||\r\n                            (stripline.start < axis.visibleRange.min)) {\r\n                            startValue = axis.visibleLabels[0].value === axis.visibleRange.min ? axis.visibleRange.min :\r\n                                axis.visibleLabels[0].value - (axis.valueType === 'DateTime' ? axis.dateTimeInterval :\r\n                                    axis.visibleRange.interval);\r\n                        }\r\n                        startValue = stripline.startFromAxis && axis.valueType !== 'DateTime' ? axis.visibleRange.min : startValue;\r\n                        while (startValue < limit) {\r\n                            end = (startValue + (axis.valueType === 'DateTime' ? axis.dateTimeInterval * +stripline.size : stripline.size));\r\n                            range = withIn(end, axis.visibleRange);\r\n                            if ((startValue >= axis.visibleRange.min && startValue < axis.visibleRange.max) || range) {\r\n                                this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count);\r\n                            }\r\n                            count++;\r\n                            startValue = this.getStartValue(axis, stripline, startValue, chart);\r\n                        }\r\n                    }\r\n                    else {\r\n                        this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, null, segmentAxis, count);\r\n                        count++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        appendChildElement(chart.enableCanvas, chart.svgObject, striplineGroup, chart.redraw);\r\n    };\r\n    /**\r\n     * To convert the C# date to js date\r\n     *\r\n     * @param {string | number | Object} value date value\r\n     * @returns {boolean} returns true if datetime value type is string(for asp platform)\r\n     */\r\n    StripLine.prototype.isCoreDate = function (value) {\r\n        return typeof value === 'string' ? true : false;\r\n    };\r\n    /**\r\n     * To get the total milli seconds\r\n     *\r\n     * @param {Date | number | Object} value date value\r\n     * @param {Chart} chart chart instance\r\n     * @returns {number} returns milliseconds\r\n     */\r\n    StripLine.prototype.dateToMilliSeconds = function (value, chart) {\r\n        return this.dateParse(value, chart).getTime();\r\n    };\r\n    /**\r\n     * To draw the single line strip line\r\n     *\r\n     * @param {StripLineSettingsModel} stripline stripline\r\n     * @param {Rect} rect rect\r\n     * @param {string} id id\r\n     * @param {Element} parent parent\r\n     * @param {Chart} chart chart\r\n     * @param {Axis} axis axis\r\n     */\r\n    StripLine.prototype.renderPath = function (stripline, rect, id, parent, chart, axis) {\r\n        var element = getElement(id);\r\n        var direction = element ? element.getAttribute('d') : '';\r\n        var d = (axis.orientation === 'Vertical') ? ('M ' + rect.x + ' ' + rect.y + ' ' + 'L ' + (rect.x + rect.width)\r\n            + ' ' + rect.y) :\r\n            ('M ' + rect.x + ' ' + rect.y + ' ' + 'L ' + rect.x + ' ' + (rect.y + rect.height));\r\n        appendChildElement(chart.enableCanvas, parent, chart.renderer.drawPath(new PathOption(id, 'none', stripline.size, stripline.color, stripline.opacity, stripline.dashArray, d)), chart.redraw, true, 'x', 'y', null, direction, true);\r\n    };\r\n    /**\r\n     * To draw the rectangle\r\n     *\r\n     * @param {StripLineSettingsModel} stripline stripline\r\n     * @param {Rect} rect rect\r\n     * @param {string} id id\r\n     * @param {Element} parent parent\r\n     * @param {Chart} chart chart\r\n     */\r\n    StripLine.prototype.renderRectangle = function (stripline, rect, id, parent, chart) {\r\n        var element = getElement(id);\r\n        var previousRect = element ? new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')) : null;\r\n        appendChildElement(chart.enableCanvas, parent, chart.renderer.drawRectangle(new RectOption(id, stripline.color, stripline.border, stripline.opacity, rect, 0, 0, '', stripline.dashArray)), chart.redraw, true, 'x', 'y', null, null, true, true, previousRect);\r\n    };\r\n    /**\r\n     * To create the text on strip line\r\n     *\r\n     * @param {StripLineSettingsModel} stripline stripline\r\n     * @param {Rect} rect rect\r\n     * @param {string} id id\r\n     * @param {Element} parent parent\r\n     * @param {Chart} chart chart\r\n     * @param {Axis} axis axis\r\n     */\r\n    StripLine.prototype.renderText = function (stripline, rect, id, parent, chart, axis) {\r\n        var textSize = measureText(stripline.text, stripline.textStyle);\r\n        var isRotationNull = (stripline.rotation === null);\r\n        var textMid = isRotationNull ? 3 * (textSize.height / 8) : 0;\r\n        var ty = rect.y + (rect.height / 2) + textMid;\r\n        var rotation = isRotationNull ? ((axis.orientation === 'Vertical') ? 0 : -90) : stripline.rotation;\r\n        var tx = rect.x + (rect.width / 2);\r\n        var anchor;\r\n        var padding = 5;\r\n        if (axis.orientation === 'Horizontal') {\r\n            tx = this.getTextStart(tx + (textMid * this.factor(stripline.horizontalAlignment)), rect.width, stripline.horizontalAlignment);\r\n            ty = this.getTextStart(ty - textMid, rect.height, stripline.verticalAlignment) +\r\n                (stripline.verticalAlignment === 'Start' && !isRotationNull ? (textSize.height / 4) : 0);\r\n            anchor = isRotationNull ? this.invertAlignment(stripline.verticalAlignment) : stripline.horizontalAlignment;\r\n        }\r\n        else {\r\n            tx = this.getTextStart(tx, rect.width, stripline.horizontalAlignment);\r\n            ty = this.getTextStart(ty + (textMid * this.factor(stripline.verticalAlignment)) - padding, rect.height, stripline.verticalAlignment);\r\n            anchor = stripline.horizontalAlignment;\r\n        }\r\n        textElement(chart.renderer, new TextOption(id, tx, ty, anchor, stripline.text, 'rotate(' + rotation + ' ' + tx + ',' + ty + ')', 'middle'), stripline.textStyle, stripline.textStyle.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas);\r\n    };\r\n    StripLine.prototype.invertAlignment = function (anchor) {\r\n        switch (anchor) {\r\n            case 'Start':\r\n                anchor = 'End';\r\n                break;\r\n            case 'End':\r\n                anchor = 'Start';\r\n                break;\r\n        }\r\n        return anchor;\r\n    };\r\n    /**\r\n     * To find the next value of the recurrence strip line\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {StripLineSettingsModel} stripline stripline\r\n     * @param {number} startValue startValue\r\n     * @param {Chart} chart chart instance\r\n     * @returns {number} next start value of the recurrence strip line\r\n     */\r\n    StripLine.prototype.getStartValue = function (axis, stripline, startValue, chart) {\r\n        if (axis.valueType === 'DateTime') {\r\n            return (this.getToValue(null, startValue, +stripline.repeatEvery, axis, null, stripline));\r\n        }\r\n        else {\r\n            return startValue + (+stripline.repeatEvery);\r\n        }\r\n    };\r\n    /**\r\n     * Finding segment axis for segmented strip line\r\n     *\r\n     * @param {Axis[]} axes axes collection\r\n     * @param {Axis} axis axis\r\n     * @param {StripLineSettingsModel} stripline stripline\r\n     */\r\n    StripLine.prototype.getSegmentAxis = function (axes, axis, stripline) {\r\n        var segment;\r\n        if (stripline.segmentAxisName == null) {\r\n            return (axis.orientation === 'Horizontal') ? axes[1] : axes[0];\r\n        }\r\n        else {\r\n            for (var i = 0; i < axes.length; i++) {\r\n                if (stripline.segmentAxisName === axes[i].name) {\r\n                    segment = axes[i];\r\n                }\r\n            }\r\n            return segment;\r\n        }\r\n    };\r\n    /**\r\n     * To render strip line on chart\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {StripLineSettingsModel} stripline stripline\r\n     * @param {Rect} seriesClipRect seriesClipRect\r\n     * @param {string} id id\r\n     * @param {Element} striplineGroup striplineGroup\r\n     * @param {Chart} chart chart\r\n     * @param {number} startValue startValue\r\n     * @param {Axis} segmentAxis segmentAxis\r\n     * @param {number} count count\r\n     */\r\n    StripLine.prototype.renderStripLineElement = function (axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count) {\r\n        var rect = this.measureStripLine(axis, stripline, seriesClipRect, startValue, segmentAxis, chart);\r\n        if (stripline.sizeType === 'Pixel') {\r\n            this.renderPath(stripline, rect, id + 'path_' + axis.name + '_' + count, striplineGroup, chart, axis);\r\n        }\r\n        else {\r\n            if (rect.height !== 0 && rect.width !== 0) {\r\n                this.renderRectangle(stripline, rect, id + 'rect_' + axis.name + '_' + count, striplineGroup, chart);\r\n            }\r\n        }\r\n        if (stripline.text !== '') {\r\n            this.renderText(stripline, rect, id + 'text_' + axis.name + '_' + count, striplineGroup, chart, axis);\r\n        }\r\n    };\r\n    /**\r\n     * To find the factor of the text\r\n     *\r\n     * @param {Anchor} anchor text anchor\r\n     */\r\n    StripLine.prototype.factor = function (anchor) {\r\n        var factor = 0;\r\n        switch (anchor) {\r\n            case 'Start':\r\n                factor = 1;\r\n                break;\r\n            case 'End':\r\n                factor = -1;\r\n                break;\r\n        }\r\n        return factor;\r\n    };\r\n    /**\r\n     * To find the start value of the text\r\n     *\r\n     * @param {number} xy xy values\r\n     * @param {number} size text size\r\n     * @param {Anchor} textAlignment text alignment\r\n     */\r\n    StripLine.prototype.getTextStart = function (xy, size, textAlignment) {\r\n        var padding = 5;\r\n        switch (textAlignment) {\r\n            case 'Start':\r\n                xy = xy - (size / 2) + padding;\r\n                break;\r\n            case 'End':\r\n                xy = xy + (size / 2) - padding;\r\n                break;\r\n        }\r\n        return xy;\r\n    };\r\n    /**\r\n     * To get the module name for `StripLine`.\r\n     *\r\n     * @private\r\n     */\r\n    StripLine.prototype.getModuleName = function () {\r\n        return 'StripLine';\r\n    };\r\n    /**\r\n     * To destroy the `StripLine` module.\r\n     *\r\n     * @private\r\n     */\r\n    StripLine.prototype.destroy = function () {\r\n        // destroy peform here\r\n    };\r\n    return StripLine;\r\n}());\r\nexport { StripLine };\r\n"]},"metadata":{},"sourceType":"module"}