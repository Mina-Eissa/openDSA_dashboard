{"ast":null,"code":"import { isChain } from '../../utils/is.js';\nimport { format } from '../../utils/string.js';\nimport { hasOwnProperty, lazy } from '../../utils/object.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'Chain';\nvar dependencies = ['?on', 'math', 'typed'];\nexport var createChainClass = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    on,\n    math,\n    typed\n  } = _ref;\n  /**\r\n   * @constructor Chain\r\n   * Wrap any value in a chain, allowing to perform chained operations on\r\n   * the value.\r\n   *\r\n   * All methods available in the math.js library can be called upon the chain,\r\n   * and then will be evaluated with the value itself as first argument.\r\n   * The chain can be closed by executing chain.done(), which will return\r\n   * the final value.\r\n   *\r\n   * The Chain has a number of special functions:\r\n   * - done()             Finalize the chained operation and return the\r\n   *                      chain's value.\r\n   * - valueOf()          The same as done()\r\n   * - toString()         Returns a string representation of the chain's value.\r\n   *\r\n   * @param {*} [value]\r\n   */\n\n  function Chain(value) {\n    if (!(this instanceof Chain)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (isChain(value)) {\n      this.value = value.value;\n    } else {\n      this.value = value;\n    }\n  }\n  /**\r\n   * Attach type information\r\n   */\n\n\n  Chain.prototype.type = 'Chain';\n  Chain.prototype.isChain = true;\n  /**\r\n   * Close the chain. Returns the final value.\r\n   * Does the same as method valueOf()\r\n   * @returns {*} value\r\n   */\n\n  Chain.prototype.done = function () {\n    return this.value;\n  };\n  /**\r\n   * Close the chain. Returns the final value.\r\n   * Does the same as method done()\r\n   * @returns {*} value\r\n   */\n\n\n  Chain.prototype.valueOf = function () {\n    return this.value;\n  };\n  /**\r\n   * Get a string representation of the value in the chain\r\n   * @returns {string}\r\n   */\n\n\n  Chain.prototype.toString = function () {\n    return format(this.value);\n  };\n  /**\r\n   * Get a JSON representation of the chain\r\n   * @returns {Object}\r\n   */\n\n\n  Chain.prototype.toJSON = function () {\n    return {\n      mathjs: 'Chain',\n      value: this.value\n    };\n  };\n  /**\r\n   * Instantiate a Chain from its JSON representation\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"Chain\", value: ...}`,\r\n   *                       where mathjs is optional\r\n   * @returns {Chain}\r\n   */\n\n\n  Chain.fromJSON = function (json) {\n    return new Chain(json.value);\n  };\n  /**\r\n   * Create a proxy method for the chain\r\n   * @param {string} name\r\n   * @param {Function} fn      The function to be proxied\r\n   *                           If fn is no function, it is silently ignored.\r\n   * @private\r\n   */\n\n\n  function createProxy(name, fn) {\n    if (typeof fn === 'function') {\n      Chain.prototype[name] = chainify(fn);\n    }\n  }\n  /**\r\n   * Create a proxy method for the chain\r\n   * @param {string} name\r\n   * @param {function} resolver   The function resolving with the\r\n   *                              function to be proxied\r\n   * @private\r\n   */\n\n\n  function createLazyProxy(name, resolver) {\n    lazy(Chain.prototype, name, function outerResolver() {\n      var fn = resolver();\n\n      if (typeof fn === 'function') {\n        return chainify(fn);\n      }\n\n      return undefined; // if not a function, ignore\n    });\n  }\n  /**\r\n   * Make a function chainable\r\n   * @param {function} fn\r\n   * @return {Function} chain function\r\n   * @private\r\n   */\n\n\n  function chainify(fn) {\n    return function () {\n      // Here, `this` will be the context of a Chain instance\n      if (arguments.length === 0) {\n        return new Chain(fn(this.value));\n      }\n\n      var args = [this.value];\n\n      for (var i = 0; i < arguments.length; i++) {\n        args[i + 1] = arguments[i];\n      }\n\n      if (typed.isTypedFunction(fn)) {\n        var sigObject = typed.resolve(fn, args); // We want to detect if a rest parameter has matched across the\n        // value in the chain and the current arguments of this call.\n        // That is the case if and only if the matching signature has\n        // exactly one parameter (which then must be a rest parameter\n        // as it is matching at least two actual arguments).\n\n        if (sigObject.params.length === 1) {\n          throw new Error('chain function ' + fn.name + ' cannot match rest parameter between chain value and additional arguments.');\n        }\n\n        return new Chain(sigObject.implementation.apply(fn, args));\n      }\n\n      return new Chain(fn.apply(fn, args));\n    };\n  }\n  /**\r\n   * Create a proxy for a single method, or an object with multiple methods.\r\n   * Example usage:\r\n   *\r\n   *   Chain.createProxy('add', function add (x, y) {...})\r\n   *   Chain.createProxy({\r\n   *     add:      function add (x, y) {...},\r\n   *     subtract: function subtract (x, y) {...}\r\n   *   }\r\n   *\r\n   * @param {string | Object} arg0   A name (string), or an object with\r\n   *                                 functions\r\n   * @param {*} [arg1]               A function, when arg0 is a name\r\n   */\n\n\n  Chain.createProxy = function (arg0, arg1) {\n    if (typeof arg0 === 'string') {\n      // createProxy(name, value)\n      createProxy(arg0, arg1);\n    } else {\n      var _loop = function _loop(_name) {\n        if (hasOwnProperty(arg0, _name) && excludedNames[_name] === undefined) {\n          createLazyProxy(_name, () => arg0[_name]);\n        }\n      }; // createProxy(values)\n\n\n      for (var _name in arg0) {\n        _loop(_name);\n      }\n    }\n  };\n\n  var excludedNames = {\n    expression: true,\n    docs: true,\n    type: true,\n    classes: true,\n    json: true,\n    error: true,\n    isChain: true // conflicts with the property isChain of a Chain instance\n\n  }; // create proxy for everything that is in math.js\n\n  Chain.createProxy(math); // register on the import event, automatically add a proxy for every imported function.\n\n  if (on) {\n    on('import', function (name, resolver, path) {\n      if (!path) {\n        // an imported function (not a data type or something special)\n        createLazyProxy(name, resolver);\n      }\n    });\n  }\n\n  return Chain;\n}, {\n  isClass: true\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/type/chain/Chain.js"],"names":["isChain","format","hasOwnProperty","lazy","factory","name","dependencies","createChainClass","_ref","on","math","typed","Chain","value","SyntaxError","prototype","type","done","valueOf","toString","toJSON","mathjs","fromJSON","json","createProxy","fn","chainify","createLazyProxy","resolver","outerResolver","undefined","arguments","length","args","i","isTypedFunction","sigObject","resolve","params","Error","implementation","apply","arg0","arg1","_loop","_name","excludedNames","expression","docs","classes","error","path","isClass"],"mappings":"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","sourcesContent":["import { isChain } from '../../utils/is.js';\r\nimport { format } from '../../utils/string.js';\r\nimport { hasOwnProperty, lazy } from '../../utils/object.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'Chain';\r\nvar dependencies = ['?on', 'math', 'typed'];\r\nexport var createChainClass = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    on,\r\n    math,\r\n    typed\r\n  } = _ref;\r\n  /**\r\n   * @constructor Chain\r\n   * Wrap any value in a chain, allowing to perform chained operations on\r\n   * the value.\r\n   *\r\n   * All methods available in the math.js library can be called upon the chain,\r\n   * and then will be evaluated with the value itself as first argument.\r\n   * The chain can be closed by executing chain.done(), which will return\r\n   * the final value.\r\n   *\r\n   * The Chain has a number of special functions:\r\n   * - done()             Finalize the chained operation and return the\r\n   *                      chain's value.\r\n   * - valueOf()          The same as done()\r\n   * - toString()         Returns a string representation of the chain's value.\r\n   *\r\n   * @param {*} [value]\r\n   */\r\n  function Chain(value) {\r\n    if (!(this instanceof Chain)) {\r\n      throw new SyntaxError('Constructor must be called with the new operator');\r\n    }\r\n    if (isChain(value)) {\r\n      this.value = value.value;\r\n    } else {\r\n      this.value = value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attach type information\r\n   */\r\n  Chain.prototype.type = 'Chain';\r\n  Chain.prototype.isChain = true;\r\n\r\n  /**\r\n   * Close the chain. Returns the final value.\r\n   * Does the same as method valueOf()\r\n   * @returns {*} value\r\n   */\r\n  Chain.prototype.done = function () {\r\n    return this.value;\r\n  };\r\n\r\n  /**\r\n   * Close the chain. Returns the final value.\r\n   * Does the same as method done()\r\n   * @returns {*} value\r\n   */\r\n  Chain.prototype.valueOf = function () {\r\n    return this.value;\r\n  };\r\n\r\n  /**\r\n   * Get a string representation of the value in the chain\r\n   * @returns {string}\r\n   */\r\n  Chain.prototype.toString = function () {\r\n    return format(this.value);\r\n  };\r\n\r\n  /**\r\n   * Get a JSON representation of the chain\r\n   * @returns {Object}\r\n   */\r\n  Chain.prototype.toJSON = function () {\r\n    return {\r\n      mathjs: 'Chain',\r\n      value: this.value\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Instantiate a Chain from its JSON representation\r\n   * @param {Object} json  An object structured like\r\n   *                       `{\"mathjs\": \"Chain\", value: ...}`,\r\n   *                       where mathjs is optional\r\n   * @returns {Chain}\r\n   */\r\n  Chain.fromJSON = function (json) {\r\n    return new Chain(json.value);\r\n  };\r\n\r\n  /**\r\n   * Create a proxy method for the chain\r\n   * @param {string} name\r\n   * @param {Function} fn      The function to be proxied\r\n   *                           If fn is no function, it is silently ignored.\r\n   * @private\r\n   */\r\n  function createProxy(name, fn) {\r\n    if (typeof fn === 'function') {\r\n      Chain.prototype[name] = chainify(fn);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a proxy method for the chain\r\n   * @param {string} name\r\n   * @param {function} resolver   The function resolving with the\r\n   *                              function to be proxied\r\n   * @private\r\n   */\r\n  function createLazyProxy(name, resolver) {\r\n    lazy(Chain.prototype, name, function outerResolver() {\r\n      var fn = resolver();\r\n      if (typeof fn === 'function') {\r\n        return chainify(fn);\r\n      }\r\n      return undefined; // if not a function, ignore\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Make a function chainable\r\n   * @param {function} fn\r\n   * @return {Function} chain function\r\n   * @private\r\n   */\r\n  function chainify(fn) {\r\n    return function () {\r\n      // Here, `this` will be the context of a Chain instance\r\n      if (arguments.length === 0) {\r\n        return new Chain(fn(this.value));\r\n      }\r\n      var args = [this.value];\r\n      for (var i = 0; i < arguments.length; i++) {\r\n        args[i + 1] = arguments[i];\r\n      }\r\n      if (typed.isTypedFunction(fn)) {\r\n        var sigObject = typed.resolve(fn, args);\r\n        // We want to detect if a rest parameter has matched across the\r\n        // value in the chain and the current arguments of this call.\r\n        // That is the case if and only if the matching signature has\r\n        // exactly one parameter (which then must be a rest parameter\r\n        // as it is matching at least two actual arguments).\r\n        if (sigObject.params.length === 1) {\r\n          throw new Error('chain function ' + fn.name + ' cannot match rest parameter between chain value and additional arguments.');\r\n        }\r\n        return new Chain(sigObject.implementation.apply(fn, args));\r\n      }\r\n      return new Chain(fn.apply(fn, args));\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create a proxy for a single method, or an object with multiple methods.\r\n   * Example usage:\r\n   *\r\n   *   Chain.createProxy('add', function add (x, y) {...})\r\n   *   Chain.createProxy({\r\n   *     add:      function add (x, y) {...},\r\n   *     subtract: function subtract (x, y) {...}\r\n   *   }\r\n   *\r\n   * @param {string | Object} arg0   A name (string), or an object with\r\n   *                                 functions\r\n   * @param {*} [arg1]               A function, when arg0 is a name\r\n   */\r\n  Chain.createProxy = function (arg0, arg1) {\r\n    if (typeof arg0 === 'string') {\r\n      // createProxy(name, value)\r\n      createProxy(arg0, arg1);\r\n    } else {\r\n      var _loop = function _loop(_name) {\r\n        if (hasOwnProperty(arg0, _name) && excludedNames[_name] === undefined) {\r\n          createLazyProxy(_name, () => arg0[_name]);\r\n        }\r\n      };\r\n      // createProxy(values)\r\n      for (var _name in arg0) {\r\n        _loop(_name);\r\n      }\r\n    }\r\n  };\r\n  var excludedNames = {\r\n    expression: true,\r\n    docs: true,\r\n    type: true,\r\n    classes: true,\r\n    json: true,\r\n    error: true,\r\n    isChain: true // conflicts with the property isChain of a Chain instance\r\n  };\r\n\r\n  // create proxy for everything that is in math.js\r\n  Chain.createProxy(math);\r\n\r\n  // register on the import event, automatically add a proxy for every imported function.\r\n  if (on) {\r\n    on('import', function (name, resolver, path) {\r\n      if (!path) {\r\n        // an imported function (not a data type or something special)\r\n        createLazyProxy(name, resolver);\r\n      }\r\n    });\r\n  }\r\n  return Chain;\r\n}, {\r\n  isClass: true\r\n});"]},"metadata":{},"sourceType":"module"}