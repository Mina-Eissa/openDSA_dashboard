{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/* eslint-disable jsdoc/require-returns */\n\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable jsdoc/require-param */\n\n\nimport { ChartLocation, getPoint, withInRange } from '../../common/utils/helper';\nimport { PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { LineBase } from './line-base';\n/**\r\n * `StackingStepAreaSeries` module used to render the Stacking Step Area series.\r\n */\n\nvar StackingStepAreaSeries =\n/** @class */\nfunction (_super) {\n  __extends(StackingStepAreaSeries, _super);\n\n  function StackingStepAreaSeries() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Render the Stacking step area series.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  StackingStepAreaSeries.prototype.render = function (stackSeries, xAxis, yAxis, isInverted) {\n    var currentPointLocation;\n    var secondPoint;\n    var start = null;\n    var direction = '';\n    var stackedvalue = stackSeries.stackedValues;\n    var visiblePoint = this.enableComplexProperty(stackSeries);\n    var origin = Math.max(stackSeries.yAxis.visibleRange.min, stackedvalue.startValues[0]);\n    var pointsLength = visiblePoint.length;\n    var options;\n    var point;\n    var point2;\n    var point3;\n    var xValue;\n    var lineLength;\n    var prevPoint = null;\n    var validIndex;\n    var startPoint = 0;\n    var pointIndex;\n\n    if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {\n      lineLength = 0.5;\n    } else {\n      lineLength = 0;\n    }\n\n    for (var i = 0; i < pointsLength; i++) {\n      point = visiblePoint[i];\n      xValue = point.xValue;\n      point.symbolLocations = [];\n      point.regions = [];\n      pointIndex = point.index;\n\n      if (point.visible && withInRange(visiblePoint[i - 1], point, visiblePoint[i + 1], stackSeries)) {\n        if (start === null) {\n          start = new ChartLocation(xValue, 0);\n          currentPointLocation = getPoint(xValue - lineLength, origin, xAxis, yAxis, isInverted);\n          direction += 'M' + ' ' + currentPointLocation.x + ' ' + currentPointLocation.y + ' ';\n          currentPointLocation = getPoint(xValue - lineLength, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\n          direction += 'L' + ' ' + currentPointLocation.x + ' ' + currentPointLocation.y + ' ';\n        }\n\n        if (prevPoint != null) {\n          currentPointLocation = getPoint(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\n          secondPoint = getPoint(prevPoint.xValue, stackedvalue.endValues[prevPoint.index], xAxis, yAxis, isInverted);\n          direction += 'L' + ' ' + currentPointLocation.x + ' ' + secondPoint.y + ' L' + ' ' + currentPointLocation.x + ' ' + currentPointLocation.y + ' ';\n        } else if (stackSeries.emptyPointSettings.mode === 'Gap') {\n          currentPointLocation = getPoint(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\n          direction += 'L' + ' ' + currentPointLocation.x + ' ' + currentPointLocation.y + ' ';\n        }\n\n        visiblePoint[i].symbolLocations.push(getPoint(visiblePoint[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted));\n        visiblePoint[i].regions.push(new Rect(visiblePoint[i].symbolLocations[0].x - stackSeries.marker.width, visiblePoint[i].symbolLocations[0].y - stackSeries.marker.height, 2 * stackSeries.marker.width, 2 * stackSeries.marker.height));\n        prevPoint = point;\n      } // If we set the empty point mode is Gap or next point of the current point is false, we will close the series path.\n\n\n      if (visiblePoint[i + 1] && !visiblePoint[i + 1].visible && stackSeries.emptyPointSettings.mode !== 'Drop') {\n        var previousPointIndex = void 0;\n\n        for (var j = i; j >= startPoint; j--) {\n          pointIndex = visiblePoint[j].index;\n          previousPointIndex = j === 0 ? 0 : visiblePoint[j - 1].index;\n\n          if (j !== 0 && (stackedvalue.startValues[pointIndex] < stackedvalue.startValues[previousPointIndex] || stackedvalue.startValues[pointIndex] > stackedvalue.startValues[previousPointIndex])) {\n            currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);\n            direction = direction.concat('L' + ' ' + currentPointLocation.x + ' ' + currentPointLocation.y + ' ');\n            currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[previousPointIndex], xAxis, yAxis, isInverted);\n          } else {\n            currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);\n          }\n\n          direction = direction.concat('L' + ' ' + currentPointLocation.x + ' ' + currentPointLocation.y + ' ');\n        }\n\n        startPoint = i + 1;\n        start = null;\n        prevPoint = null;\n      }\n    }\n\n    if (direction !== '') {\n      // For category axis\n      if (pointsLength > 1) {\n        pointIndex = visiblePoint[pointsLength - 1].index;\n        start = {\n          'x': visiblePoint[pointsLength - 1].xValue + lineLength,\n          'y': stackedvalue.endValues[pointIndex]\n        };\n        secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);\n        direction += 'L' + ' ' + secondPoint.x + ' ' + secondPoint.y + ' ';\n        start = {\n          'x': visiblePoint[pointsLength - 1].xValue + lineLength,\n          'y': stackedvalue.startValues[pointIndex]\n        };\n        secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);\n        direction += 'L' + ' ' + secondPoint.x + ' ' + secondPoint.y + ' ';\n      } // To close the stacked step area series path in reverse order\n\n\n      for (var j = pointsLength - 1; j >= startPoint; j--) {\n        var index = void 0;\n\n        if (visiblePoint[j].visible) {\n          pointIndex = visiblePoint[j].index;\n          point2 = getPoint(visiblePoint[j].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);\n          direction = direction.concat('L' + ' ' + point2.x + ' ' + point2.y + ' ');\n        }\n\n        if (j !== 0 && !visiblePoint[j - 1].visible) {\n          index = this.getNextVisiblePointIndex(visiblePoint, j);\n        }\n\n        if (j !== 0) {\n          validIndex = index ? index : j - 1;\n          pointIndex = index ? visiblePoint[index].index : visiblePoint[j - 1].index;\n          point3 = getPoint(visiblePoint[validIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);\n          direction = direction.concat('L' + ' ' + point2.x + ' ' + point3.y + ' ');\n        }\n      }\n\n      options = new PathOption(stackSeries.chart.element.id + '_Series_' + stackSeries.index, stackSeries.interior, stackSeries.border.width, stackSeries.border.color, stackSeries.opacity, stackSeries.dashArray, direction);\n      this.appendLinePath(options, stackSeries, '');\n      this.renderMarker(stackSeries);\n    }\n  };\n  /**\r\n   * Animates the series.\r\n   *\r\n   * @param  {Series} series - Defines the series to animate.\r\n   * @returns {void}\r\n   */\n\n\n  StackingStepAreaSeries.prototype.doAnimation = function (series) {\n    var option = series.animation;\n    this.doLinearAnimation(series, option);\n  };\n  /**\r\n   * To destroy the stacking step area.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  StackingStepAreaSeries.prototype.destroy = function () {\n    /**\r\n     * Destroy method calling here\r\n     */\n  };\n  /**\r\n   * Get module name.\r\n   */\n\n\n  StackingStepAreaSeries.prototype.getModuleName = function () {\n    /**\r\n     * Returns the module name of the series\r\n     */\n    return 'StackingStepAreaSeries';\n  };\n  /**\r\n   * To get the nearest visible point\r\n   *\r\n   * @param {Points[]} points points\r\n   * @param {number} j index\r\n   */\n\n\n  StackingStepAreaSeries.prototype.getNextVisiblePointIndex = function (points, j) {\n    var index;\n\n    for (index = j - 1; index >= 0; index--) {\n      if (!points[index].visible) {\n        continue;\n      } else {\n        return index;\n      }\n    }\n\n    return 0;\n  };\n\n  return StackingStepAreaSeries;\n}(LineBase);\n\nexport { StackingStepAreaSeries };","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/chart/series/stacking-step-area-series.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","ChartLocation","getPoint","withInRange","PathOption","Rect","LineBase","StackingStepAreaSeries","_super","apply","arguments","render","stackSeries","xAxis","yAxis","isInverted","currentPointLocation","secondPoint","start","direction","stackedvalue","stackedValues","visiblePoint","enableComplexProperty","origin","Math","max","visibleRange","min","startValues","pointsLength","length","options","point","point2","point3","xValue","lineLength","prevPoint","validIndex","startPoint","pointIndex","valueType","labelPlacement","i","symbolLocations","regions","index","visible","x","y","endValues","emptyPointSettings","mode","push","marker","width","height","previousPointIndex","j","concat","getNextVisiblePointIndex","chart","element","id","interior","border","color","opacity","dashArray","appendLinePath","renderMarker","doAnimation","series","option","animation","doLinearAnimation","destroy","getModuleName","points"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n/* eslint-disable jsdoc/require-returns */\r\n/* eslint-disable @typescript-eslint/no-inferrable-types */\r\n/* eslint-disable valid-jsdoc */\r\n/* eslint-disable jsdoc/require-param */\r\nimport { ChartLocation, getPoint, withInRange } from '../../common/utils/helper';\r\nimport { PathOption, Rect } from '@syncfusion/ej2-svg-base';\r\nimport { LineBase } from './line-base';\r\n/**\r\n * `StackingStepAreaSeries` module used to render the Stacking Step Area series.\r\n */\r\nvar StackingStepAreaSeries = /** @class */ (function (_super) {\r\n    __extends(StackingStepAreaSeries, _super);\r\n    function StackingStepAreaSeries() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    /**\r\n     * Render the Stacking step area series.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    StackingStepAreaSeries.prototype.render = function (stackSeries, xAxis, yAxis, isInverted) {\r\n        var currentPointLocation;\r\n        var secondPoint;\r\n        var start = null;\r\n        var direction = '';\r\n        var stackedvalue = stackSeries.stackedValues;\r\n        var visiblePoint = this.enableComplexProperty(stackSeries);\r\n        var origin = Math.max(stackSeries.yAxis.visibleRange.min, stackedvalue.startValues[0]);\r\n        var pointsLength = visiblePoint.length;\r\n        var options;\r\n        var point;\r\n        var point2;\r\n        var point3;\r\n        var xValue;\r\n        var lineLength;\r\n        var prevPoint = null;\r\n        var validIndex;\r\n        var startPoint = 0;\r\n        var pointIndex;\r\n        if (xAxis.valueType === 'Category' && xAxis.labelPlacement === 'BetweenTicks') {\r\n            lineLength = 0.5;\r\n        }\r\n        else {\r\n            lineLength = 0;\r\n        }\r\n        for (var i = 0; i < pointsLength; i++) {\r\n            point = visiblePoint[i];\r\n            xValue = point.xValue;\r\n            point.symbolLocations = [];\r\n            point.regions = [];\r\n            pointIndex = point.index;\r\n            if (point.visible && withInRange(visiblePoint[i - 1], point, visiblePoint[i + 1], stackSeries)) {\r\n                if (start === null) {\r\n                    start = new ChartLocation(xValue, 0);\r\n                    currentPointLocation = getPoint(xValue - lineLength, origin, xAxis, yAxis, isInverted);\r\n                    direction += ('M' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\r\n                    currentPointLocation = getPoint(xValue - lineLength, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\r\n                    direction += ('L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\r\n                }\r\n                if (prevPoint != null) {\r\n                    currentPointLocation = getPoint(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\r\n                    secondPoint = getPoint(prevPoint.xValue, stackedvalue.endValues[prevPoint.index], xAxis, yAxis, isInverted);\r\n                    direction += ('L' + ' ' + (currentPointLocation.x) + ' ' + (secondPoint.y) +\r\n                        ' L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\r\n                }\r\n                else if (stackSeries.emptyPointSettings.mode === 'Gap') {\r\n                    currentPointLocation = getPoint(point.xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted);\r\n                    direction += 'L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ';\r\n                }\r\n                visiblePoint[i].symbolLocations.push(getPoint(visiblePoint[i].xValue, stackedvalue.endValues[pointIndex], xAxis, yAxis, isInverted));\r\n                visiblePoint[i].regions.push(new Rect(visiblePoint[i].symbolLocations[0].x - stackSeries.marker.width, visiblePoint[i].symbolLocations[0].y - stackSeries.marker.height, 2 * stackSeries.marker.width, 2 * stackSeries.marker.height));\r\n                prevPoint = point;\r\n            }\r\n            // If we set the empty point mode is Gap or next point of the current point is false, we will close the series path.\r\n            if (visiblePoint[i + 1] && !visiblePoint[i + 1].visible && stackSeries.emptyPointSettings.mode !== 'Drop') {\r\n                var previousPointIndex = void 0;\r\n                for (var j = i; j >= startPoint; j--) {\r\n                    pointIndex = visiblePoint[j].index;\r\n                    previousPointIndex = j === 0 ? 0 : visiblePoint[j - 1].index;\r\n                    if (j !== 0 && (stackedvalue.startValues[pointIndex] < stackedvalue.startValues[previousPointIndex] ||\r\n                        stackedvalue.startValues[pointIndex] > stackedvalue.startValues[previousPointIndex])) {\r\n                        currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);\r\n                        direction = direction.concat('L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\r\n                        currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[previousPointIndex], xAxis, yAxis, isInverted);\r\n                    }\r\n                    else {\r\n                        currentPointLocation = getPoint(visiblePoint[pointIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);\r\n                    }\r\n                    direction = direction.concat('L' + ' ' + (currentPointLocation.x) + ' ' + (currentPointLocation.y) + ' ');\r\n                }\r\n                startPoint = i + 1;\r\n                start = null;\r\n                prevPoint = null;\r\n            }\r\n        }\r\n        if (direction !== '') {\r\n            // For category axis\r\n            if (pointsLength > 1) {\r\n                pointIndex = visiblePoint[pointsLength - 1].index;\r\n                start = { 'x': visiblePoint[pointsLength - 1].xValue + lineLength, 'y': stackedvalue.endValues[pointIndex] };\r\n                secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);\r\n                direction += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');\r\n                start = { 'x': visiblePoint[pointsLength - 1].xValue + lineLength, 'y': stackedvalue.startValues[pointIndex] };\r\n                secondPoint = getPoint(start.x, start.y, xAxis, yAxis, isInverted);\r\n                direction += ('L' + ' ' + (secondPoint.x) + ' ' + (secondPoint.y) + ' ');\r\n            }\r\n            // To close the stacked step area series path in reverse order\r\n            for (var j = pointsLength - 1; j >= startPoint; j--) {\r\n                var index = void 0;\r\n                if (visiblePoint[j].visible) {\r\n                    pointIndex = visiblePoint[j].index;\r\n                    point2 = getPoint(visiblePoint[j].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);\r\n                    direction = direction.concat('L' + ' ' + (point2.x) + ' ' + (point2.y) + ' ');\r\n                }\r\n                if (j !== 0 && !visiblePoint[j - 1].visible) {\r\n                    index = this.getNextVisiblePointIndex(visiblePoint, j);\r\n                }\r\n                if (j !== 0) {\r\n                    validIndex = index ? index : j - 1;\r\n                    pointIndex = index ? visiblePoint[index].index : visiblePoint[j - 1].index;\r\n                    point3 = getPoint(visiblePoint[validIndex].xValue, stackedvalue.startValues[pointIndex], xAxis, yAxis, isInverted);\r\n                    direction = direction.concat('L' + ' ' + (point2.x) + ' ' + (point3.y) + ' ');\r\n                }\r\n            }\r\n            options = new PathOption(stackSeries.chart.element.id + '_Series_' + stackSeries.index, stackSeries.interior, stackSeries.border.width, stackSeries.border.color, stackSeries.opacity, stackSeries.dashArray, direction);\r\n            this.appendLinePath(options, stackSeries, '');\r\n            this.renderMarker(stackSeries);\r\n        }\r\n    };\r\n    /**\r\n     * Animates the series.\r\n     *\r\n     * @param  {Series} series - Defines the series to animate.\r\n     * @returns {void}\r\n     */\r\n    StackingStepAreaSeries.prototype.doAnimation = function (series) {\r\n        var option = series.animation;\r\n        this.doLinearAnimation(series, option);\r\n    };\r\n    /**\r\n     * To destroy the stacking step area.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    StackingStepAreaSeries.prototype.destroy = function () {\r\n        /**\r\n         * Destroy method calling here\r\n         */\r\n    };\r\n    /**\r\n     * Get module name.\r\n     */\r\n    StackingStepAreaSeries.prototype.getModuleName = function () {\r\n        /**\r\n         * Returns the module name of the series\r\n         */\r\n        return 'StackingStepAreaSeries';\r\n    };\r\n    /**\r\n     * To get the nearest visible point\r\n     *\r\n     * @param {Points[]} points points\r\n     * @param {number} j index\r\n     */\r\n    StackingStepAreaSeries.prototype.getNextVisiblePointIndex = function (points, j) {\r\n        var index;\r\n        for (index = j - 1; index >= 0; index--) {\r\n            if (!points[index].visible) {\r\n                continue;\r\n            }\r\n            else {\r\n                return index;\r\n            }\r\n        }\r\n        return 0;\r\n    };\r\n    return StackingStepAreaSeries;\r\n}(LineBase));\r\nexport { StackingStepAreaSeries };\r\n"]},"metadata":{},"sourceType":"module"}