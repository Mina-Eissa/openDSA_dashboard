{"ast":null,"code":"import { factory } from '../../../utils/factory.js';\nimport { createSolveValidation } from './utils/solveValidation.js';\nvar name = 'lsolveAll';\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\nexport var createLsolveAll = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    divideScalar,\n    multiplyScalar,\n    subtract,\n    equalScalar,\n    DenseMatrix\n  } = _ref;\n  var solveValidation = createSolveValidation({\n    DenseMatrix\n  });\n  /**\r\n   * Finds all solutions of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix.\r\n   *\r\n   * `L * x = b`\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lsolveAll(L, b)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    const a = [[-2, 3], [2, 1]]\r\n   *    const b = [11, 9]\r\n   *    const x = lsolveAll(a, b)  // [ [[-5.5], [20]] ]\r\n   *\r\n   * See also:\r\n   *\r\n   *    lsolve, lup, slu, usolve, lusolve\r\n   *\r\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\r\n   * @param {Matrix, Array} b       A column vector with the b values\r\n   *\r\n   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system\r\n   */\n\n  return typed(name, {\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\n      return _sparseForwardSubstitution(m, b);\n    },\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\n      return _denseForwardSubstitution(m, b);\n    },\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\n      var m = matrix(a);\n\n      var R = _denseForwardSubstitution(m, b);\n\n      return R.map(r => r.valueOf());\n    }\n  });\n\n  function _denseForwardSubstitution(m, b_) {\n    // the algorithm is derived from\n    // https://www.overleaf.com/read/csvgqdxggyjv\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];\n    var M = m._data;\n    var rows = m._size[0];\n    var columns = m._size[1]; // loop columns\n\n    for (var i = 0; i < columns; i++) {\n      var L = B.length; // loop right-hand sides\n\n      for (var k = 0; k < L; k++) {\n        var b = B[k];\n\n        if (!equalScalar(M[i][i], 0)) {\n          // non-singular row\n          b[i] = divideScalar(b[i], M[i][i]);\n\n          for (var j = i + 1; j < columns; j++) {\n            // b[j] -= b[i] * M[j,i]\n            b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n          var bNew = [...b];\n          bNew[i] = 1;\n\n          for (var _j = i + 1; _j < columns; _j++) {\n            bNew[_j] = subtract(bNew[_j], M[_j][i]);\n          }\n\n          B.push(bNew);\n        }\n      }\n    }\n\n    return B.map(x => new DenseMatrix({\n      data: x.map(e => [e]),\n      size: [rows, 1]\n    }));\n  }\n\n  function _sparseForwardSubstitution(m, b_) {\n    // array of right-hand sides\n    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];\n    var rows = m._size[0];\n    var columns = m._size[1];\n    var values = m._values;\n    var index = m._index;\n    var ptr = m._ptr; // loop columns\n\n    for (var i = 0; i < columns; i++) {\n      var L = B.length; // loop right-hand sides\n\n      for (var k = 0; k < L; k++) {\n        var b = B[k]; // values & indices (column i)\n\n        var iValues = [];\n        var iIndices = []; // first & last indeces in column\n\n        var firstIndex = ptr[i];\n        var lastIndex = ptr[i + 1]; // find the value at [i, i]\n\n        var Mii = 0;\n\n        for (var j = firstIndex; j < lastIndex; j++) {\n          var J = index[j]; // check row\n\n          if (J === i) {\n            Mii = values[j];\n          } else if (J > i) {\n            // store lower triangular\n            iValues.push(values[j]);\n            iIndices.push(J);\n          }\n        }\n\n        if (!equalScalar(Mii, 0)) {\n          // non-singular row\n          b[i] = divideScalar(b[i], Mii);\n\n          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {\n            var _J = iIndices[_j2];\n            b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));\n          }\n        } else if (!equalScalar(b[i], 0)) {\n          // singular row, nonzero RHS\n          if (k === 0) {\n            // There is no valid solution\n            return [];\n          } else {\n            // This RHS is invalid but other solutions may still exist\n            B.splice(k, 1);\n            k -= 1;\n            L -= 1;\n          }\n        } else if (k === 0) {\n          // singular row, RHS is zero\n          var bNew = [...b];\n          bNew[i] = 1;\n\n          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {\n            var _J2 = iIndices[_j3];\n            bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);\n          }\n\n          B.push(bNew);\n        }\n      }\n    }\n\n    return B.map(x => new DenseMatrix({\n      data: x.map(e => [e]),\n      size: [rows, 1]\n    }));\n  }\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js"],"names":["factory","createSolveValidation","name","dependencies","createLsolveAll","_ref","typed","matrix","divideScalar","multiplyScalar","subtract","equalScalar","DenseMatrix","solveValidation","SparseMatrixArrayMatrix","m","b","_sparseForwardSubstitution","DenseMatrixArrayMatrix","_denseForwardSubstitution","ArrayArrayMatrix","a","R","map","r","valueOf","b_","B","_data","e","M","rows","_size","columns","i","L","length","k","j","splice","bNew","_j","push","x","data","size","values","_values","index","_index","ptr","_ptr","iValues","iIndices","firstIndex","lastIndex","Mii","J","_j2","_lastIndex","_J","_j3","_lastIndex2","_J2"],"mappings":"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","sourcesContent":["import { factory } from '../../../utils/factory.js';\r\nimport { createSolveValidation } from './utils/solveValidation.js';\r\nvar name = 'lsolveAll';\r\nvar dependencies = ['typed', 'matrix', 'divideScalar', 'multiplyScalar', 'subtract', 'equalScalar', 'DenseMatrix'];\r\nexport var createLsolveAll = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    divideScalar,\r\n    multiplyScalar,\r\n    subtract,\r\n    equalScalar,\r\n    DenseMatrix\r\n  } = _ref;\r\n  var solveValidation = createSolveValidation({\r\n    DenseMatrix\r\n  });\r\n\r\n  /**\r\n   * Finds all solutions of a linear equation system by forwards substitution. Matrix must be a lower triangular matrix.\r\n   *\r\n   * `L * x = b`\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.lsolveAll(L, b)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    const a = [[-2, 3], [2, 1]]\r\n   *    const b = [11, 9]\r\n   *    const x = lsolveAll(a, b)  // [ [[-5.5], [20]] ]\r\n   *\r\n   * See also:\r\n   *\r\n   *    lsolve, lup, slu, usolve, lusolve\r\n   *\r\n   * @param {Matrix, Array} L       A N x N matrix or array (L)\r\n   * @param {Matrix, Array} b       A column vector with the b values\r\n   *\r\n   * @return {DenseMatrix[] | Array[]}  An array of affine-independent column vectors (x) that solve the linear system\r\n   */\r\n  return typed(name, {\r\n    'SparseMatrix, Array | Matrix': function SparseMatrixArrayMatrix(m, b) {\r\n      return _sparseForwardSubstitution(m, b);\r\n    },\r\n    'DenseMatrix, Array | Matrix': function DenseMatrixArrayMatrix(m, b) {\r\n      return _denseForwardSubstitution(m, b);\r\n    },\r\n    'Array, Array | Matrix': function ArrayArrayMatrix(a, b) {\r\n      var m = matrix(a);\r\n      var R = _denseForwardSubstitution(m, b);\r\n      return R.map(r => r.valueOf());\r\n    }\r\n  });\r\n  function _denseForwardSubstitution(m, b_) {\r\n    // the algorithm is derived from\r\n    // https://www.overleaf.com/read/csvgqdxggyjv\r\n\r\n    // array of right-hand sides\r\n    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];\r\n    var M = m._data;\r\n    var rows = m._size[0];\r\n    var columns = m._size[1];\r\n\r\n    // loop columns\r\n    for (var i = 0; i < columns; i++) {\r\n      var L = B.length;\r\n\r\n      // loop right-hand sides\r\n      for (var k = 0; k < L; k++) {\r\n        var b = B[k];\r\n        if (!equalScalar(M[i][i], 0)) {\r\n          // non-singular row\r\n\r\n          b[i] = divideScalar(b[i], M[i][i]);\r\n          for (var j = i + 1; j < columns; j++) {\r\n            // b[j] -= b[i] * M[j,i]\r\n            b[j] = subtract(b[j], multiplyScalar(b[i], M[j][i]));\r\n          }\r\n        } else if (!equalScalar(b[i], 0)) {\r\n          // singular row, nonzero RHS\r\n\r\n          if (k === 0) {\r\n            // There is no valid solution\r\n            return [];\r\n          } else {\r\n            // This RHS is invalid but other solutions may still exist\r\n            B.splice(k, 1);\r\n            k -= 1;\r\n            L -= 1;\r\n          }\r\n        } else if (k === 0) {\r\n          // singular row, RHS is zero\r\n\r\n          var bNew = [...b];\r\n          bNew[i] = 1;\r\n          for (var _j = i + 1; _j < columns; _j++) {\r\n            bNew[_j] = subtract(bNew[_j], M[_j][i]);\r\n          }\r\n          B.push(bNew);\r\n        }\r\n      }\r\n    }\r\n    return B.map(x => new DenseMatrix({\r\n      data: x.map(e => [e]),\r\n      size: [rows, 1]\r\n    }));\r\n  }\r\n  function _sparseForwardSubstitution(m, b_) {\r\n    // array of right-hand sides\r\n    var B = [solveValidation(m, b_, true)._data.map(e => e[0])];\r\n    var rows = m._size[0];\r\n    var columns = m._size[1];\r\n    var values = m._values;\r\n    var index = m._index;\r\n    var ptr = m._ptr;\r\n\r\n    // loop columns\r\n    for (var i = 0; i < columns; i++) {\r\n      var L = B.length;\r\n\r\n      // loop right-hand sides\r\n      for (var k = 0; k < L; k++) {\r\n        var b = B[k];\r\n\r\n        // values & indices (column i)\r\n        var iValues = [];\r\n        var iIndices = [];\r\n\r\n        // first & last indeces in column\r\n        var firstIndex = ptr[i];\r\n        var lastIndex = ptr[i + 1];\r\n\r\n        // find the value at [i, i]\r\n        var Mii = 0;\r\n        for (var j = firstIndex; j < lastIndex; j++) {\r\n          var J = index[j];\r\n          // check row\r\n          if (J === i) {\r\n            Mii = values[j];\r\n          } else if (J > i) {\r\n            // store lower triangular\r\n            iValues.push(values[j]);\r\n            iIndices.push(J);\r\n          }\r\n        }\r\n        if (!equalScalar(Mii, 0)) {\r\n          // non-singular row\r\n\r\n          b[i] = divideScalar(b[i], Mii);\r\n          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {\r\n            var _J = iIndices[_j2];\r\n            b[_J] = subtract(b[_J], multiplyScalar(b[i], iValues[_j2]));\r\n          }\r\n        } else if (!equalScalar(b[i], 0)) {\r\n          // singular row, nonzero RHS\r\n\r\n          if (k === 0) {\r\n            // There is no valid solution\r\n            return [];\r\n          } else {\r\n            // This RHS is invalid but other solutions may still exist\r\n            B.splice(k, 1);\r\n            k -= 1;\r\n            L -= 1;\r\n          }\r\n        } else if (k === 0) {\r\n          // singular row, RHS is zero\r\n\r\n          var bNew = [...b];\r\n          bNew[i] = 1;\r\n          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {\r\n            var _J2 = iIndices[_j3];\r\n            bNew[_J2] = subtract(bNew[_J2], iValues[_j3]);\r\n          }\r\n          B.push(bNew);\r\n        }\r\n      }\r\n    }\r\n    return B.map(x => new DenseMatrix({\r\n      data: x.map(e => [e]),\r\n      size: [rows, 1]\r\n    }));\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}