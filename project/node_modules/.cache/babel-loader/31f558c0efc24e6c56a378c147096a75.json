{"ast":null,"code":"// type checks for all known types\n//\n// note that:\n//\n// - check by duck-typing on a property like `isUnit`, instead of checking instanceof.\n//   instanceof cannot be used because that would not allow to pass data from\n//   one instance of math.js to another since each has it's own instance of Unit.\n// - check the `isUnit` property via the constructor, so there will be no\n//   matches for \"fake\" instances like plain objects with a property `isUnit`.\n//   That is important for security reasons.\n// - It must not be possible to override the type checks used internally,\n//   for security reasons, so these functions are not exposed in the expression\n//   parser.\nexport function isNumber(x) {\n  return typeof x === 'number';\n}\nexport function isBigNumber(x) {\n  if (!x || typeof x !== 'object' || typeof x.constructor !== 'function') {\n    return false;\n  }\n\n  if (x.isBigNumber === true && typeof x.constructor.prototype === 'object' && x.constructor.prototype.isBigNumber === true) {\n    return true;\n  }\n\n  if (typeof x.constructor.isDecimal === 'function' && x.constructor.isDecimal(x) === true) {\n    return true;\n  }\n\n  return false;\n}\nexport function isComplex(x) {\n  return x && typeof x === 'object' && Object.getPrototypeOf(x).isComplex === true || false;\n}\nexport function isFraction(x) {\n  return x && typeof x === 'object' && Object.getPrototypeOf(x).isFraction === true || false;\n}\nexport function isUnit(x) {\n  return x && x.constructor.prototype.isUnit === true || false;\n}\nexport function isString(x) {\n  return typeof x === 'string';\n}\nexport var isArray = Array.isArray;\nexport function isMatrix(x) {\n  return x && x.constructor.prototype.isMatrix === true || false;\n}\n/**\r\n * Test whether a value is a collection: an Array or Matrix\r\n * @param {*} x\r\n * @returns {boolean} isCollection\r\n */\n\nexport function isCollection(x) {\n  return Array.isArray(x) || isMatrix(x);\n}\nexport function isDenseMatrix(x) {\n  return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;\n}\nexport function isSparseMatrix(x) {\n  return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;\n}\nexport function isRange(x) {\n  return x && x.constructor.prototype.isRange === true || false;\n}\nexport function isIndex(x) {\n  return x && x.constructor.prototype.isIndex === true || false;\n}\nexport function isBoolean(x) {\n  return typeof x === 'boolean';\n}\nexport function isResultSet(x) {\n  return x && x.constructor.prototype.isResultSet === true || false;\n}\nexport function isHelp(x) {\n  return x && x.constructor.prototype.isHelp === true || false;\n}\nexport function isFunction(x) {\n  return typeof x === 'function';\n}\nexport function isDate(x) {\n  return x instanceof Date;\n}\nexport function isRegExp(x) {\n  return x instanceof RegExp;\n}\nexport function isObject(x) {\n  return !!(x && typeof x === 'object' && x.constructor === Object && !isComplex(x) && !isFraction(x));\n}\nexport function isNull(x) {\n  return x === null;\n}\nexport function isUndefined(x) {\n  return x === undefined;\n}\nexport function isAccessorNode(x) {\n  return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isArrayNode(x) {\n  return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isAssignmentNode(x) {\n  return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isBlockNode(x) {\n  return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isConditionalNode(x) {\n  return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isConstantNode(x) {\n  return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;\n}\n/* Very specialized: returns true for those nodes which in the numerator of\r\n   a fraction means that the division in that fraction has precedence over implicit\r\n   multiplication, e.g. -2/3 x parses as (-2/3) x and 3/4 x parses as (3/4) x but\r\n   6!/8 x parses as 6! / (8x). It is located here because it is shared between\r\n   parse.js and OperatorNode.js (for parsing and printing, respectively).\r\n\r\n   This should *not* be exported from mathjs, unlike most of the tests here.\r\n   Its name does not start with 'is' to prevent utils/snapshot.js from thinking\r\n   it should be exported.\r\n*/\n\nexport function rule2Node(node) {\n  return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && '-+~'.includes(node.op);\n}\nexport function isFunctionAssignmentNode(x) {\n  return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isFunctionNode(x) {\n  return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isIndexNode(x) {\n  return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isNode(x) {\n  return x && x.isNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isObjectNode(x) {\n  return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isOperatorNode(x) {\n  return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isParenthesisNode(x) {\n  return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isRangeNode(x) {\n  return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isRelationalNode(x) {\n  return x && x.isRelationalNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isSymbolNode(x) {\n  return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;\n}\nexport function isChain(x) {\n  return x && x.constructor.prototype.isChain === true || false;\n}\nexport function typeOf(x) {\n  var t = typeof x;\n\n  if (t === 'object') {\n    if (x === null) return 'null';\n    if (isBigNumber(x)) return 'BigNumber'; // Special: weird mashup with Decimal\n\n    if (x.constructor && x.constructor.name) return x.constructor.name;\n    return 'Object'; // just in case\n  }\n\n  return t; // can be 'string', 'number', 'boolean', 'function', 'bigint', ...\n}","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/utils/is.js"],"names":["isNumber","x","isBigNumber","constructor","prototype","isDecimal","isComplex","Object","getPrototypeOf","isFraction","isUnit","isString","isArray","Array","isMatrix","isCollection","isDenseMatrix","isSparseMatrix","isRange","isIndex","isBoolean","isResultSet","isHelp","isFunction","isDate","Date","isRegExp","RegExp","isObject","isNull","isUndefined","undefined","isAccessorNode","isNode","isArrayNode","isAssignmentNode","isBlockNode","isConditionalNode","isConstantNode","rule2Node","node","isOperatorNode","args","length","includes","op","isFunctionAssignmentNode","isFunctionNode","isIndexNode","isObjectNode","isParenthesisNode","isRangeNode","isRelationalNode","isSymbolNode","isChain","typeOf","t","name"],"mappings":"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","sourcesContent":["// type checks for all known types\r\n//\r\n// note that:\r\n//\r\n// - check by duck-typing on a property like `isUnit`, instead of checking instanceof.\r\n//   instanceof cannot be used because that would not allow to pass data from\r\n//   one instance of math.js to another since each has it's own instance of Unit.\r\n// - check the `isUnit` property via the constructor, so there will be no\r\n//   matches for \"fake\" instances like plain objects with a property `isUnit`.\r\n//   That is important for security reasons.\r\n// - It must not be possible to override the type checks used internally,\r\n//   for security reasons, so these functions are not exposed in the expression\r\n//   parser.\r\n\r\nexport function isNumber(x) {\r\n  return typeof x === 'number';\r\n}\r\nexport function isBigNumber(x) {\r\n  if (!x || typeof x !== 'object' || typeof x.constructor !== 'function') {\r\n    return false;\r\n  }\r\n  if (x.isBigNumber === true && typeof x.constructor.prototype === 'object' && x.constructor.prototype.isBigNumber === true) {\r\n    return true;\r\n  }\r\n  if (typeof x.constructor.isDecimal === 'function' && x.constructor.isDecimal(x) === true) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nexport function isComplex(x) {\r\n  return x && typeof x === 'object' && Object.getPrototypeOf(x).isComplex === true || false;\r\n}\r\nexport function isFraction(x) {\r\n  return x && typeof x === 'object' && Object.getPrototypeOf(x).isFraction === true || false;\r\n}\r\nexport function isUnit(x) {\r\n  return x && x.constructor.prototype.isUnit === true || false;\r\n}\r\nexport function isString(x) {\r\n  return typeof x === 'string';\r\n}\r\nexport var isArray = Array.isArray;\r\nexport function isMatrix(x) {\r\n  return x && x.constructor.prototype.isMatrix === true || false;\r\n}\r\n\r\n/**\r\n * Test whether a value is a collection: an Array or Matrix\r\n * @param {*} x\r\n * @returns {boolean} isCollection\r\n */\r\nexport function isCollection(x) {\r\n  return Array.isArray(x) || isMatrix(x);\r\n}\r\nexport function isDenseMatrix(x) {\r\n  return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;\r\n}\r\nexport function isSparseMatrix(x) {\r\n  return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;\r\n}\r\nexport function isRange(x) {\r\n  return x && x.constructor.prototype.isRange === true || false;\r\n}\r\nexport function isIndex(x) {\r\n  return x && x.constructor.prototype.isIndex === true || false;\r\n}\r\nexport function isBoolean(x) {\r\n  return typeof x === 'boolean';\r\n}\r\nexport function isResultSet(x) {\r\n  return x && x.constructor.prototype.isResultSet === true || false;\r\n}\r\nexport function isHelp(x) {\r\n  return x && x.constructor.prototype.isHelp === true || false;\r\n}\r\nexport function isFunction(x) {\r\n  return typeof x === 'function';\r\n}\r\nexport function isDate(x) {\r\n  return x instanceof Date;\r\n}\r\nexport function isRegExp(x) {\r\n  return x instanceof RegExp;\r\n}\r\nexport function isObject(x) {\r\n  return !!(x && typeof x === 'object' && x.constructor === Object && !isComplex(x) && !isFraction(x));\r\n}\r\nexport function isNull(x) {\r\n  return x === null;\r\n}\r\nexport function isUndefined(x) {\r\n  return x === undefined;\r\n}\r\nexport function isAccessorNode(x) {\r\n  return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isArrayNode(x) {\r\n  return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isAssignmentNode(x) {\r\n  return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isBlockNode(x) {\r\n  return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isConditionalNode(x) {\r\n  return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isConstantNode(x) {\r\n  return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\n\r\n/* Very specialized: returns true for those nodes which in the numerator of\r\n   a fraction means that the division in that fraction has precedence over implicit\r\n   multiplication, e.g. -2/3 x parses as (-2/3) x and 3/4 x parses as (3/4) x but\r\n   6!/8 x parses as 6! / (8x). It is located here because it is shared between\r\n   parse.js and OperatorNode.js (for parsing and printing, respectively).\r\n\r\n   This should *not* be exported from mathjs, unlike most of the tests here.\r\n   Its name does not start with 'is' to prevent utils/snapshot.js from thinking\r\n   it should be exported.\r\n*/\r\nexport function rule2Node(node) {\r\n  return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && '-+~'.includes(node.op);\r\n}\r\nexport function isFunctionAssignmentNode(x) {\r\n  return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isFunctionNode(x) {\r\n  return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isIndexNode(x) {\r\n  return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isNode(x) {\r\n  return x && x.isNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isObjectNode(x) {\r\n  return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isOperatorNode(x) {\r\n  return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isParenthesisNode(x) {\r\n  return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isRangeNode(x) {\r\n  return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isRelationalNode(x) {\r\n  return x && x.isRelationalNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isSymbolNode(x) {\r\n  return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;\r\n}\r\nexport function isChain(x) {\r\n  return x && x.constructor.prototype.isChain === true || false;\r\n}\r\nexport function typeOf(x) {\r\n  var t = typeof x;\r\n  if (t === 'object') {\r\n    if (x === null) return 'null';\r\n    if (isBigNumber(x)) return 'BigNumber'; // Special: weird mashup with Decimal\r\n    if (x.constructor && x.constructor.name) return x.constructor.name;\r\n    return 'Object'; // just in case\r\n  }\r\n\r\n  return t; // can be 'string', 'number', 'boolean', 'function', 'bigint', ...\r\n}"]},"metadata":{},"sourceType":"module"}