{"ast":null,"code":"/* eslint-disable valid-jsdoc */\n\n/* eslint-disable jsdoc/require-returns */\n\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n\n/* eslint-disable @typescript-eslint/ban-types */\nimport { withInRange, getPoint, drawSymbol, getElement } from '../../common/utils/helper';\nimport { markerAnimate, TransformToVisible, appendChildElement } from '../../common/utils/helper';\nimport { PathOption, Rect, Size } from '@syncfusion/ej2-svg-base';\nimport { pointRender } from '../../common/model/constants';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\r\n * `ScatterSeries` module is used to render the scatter series.\r\n */\n\nvar ScatterSeries =\n/** @class */\nfunction () {\n  function ScatterSeries() {}\n  /**\r\n   * Render the scatter series.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  ScatterSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\n    // Scatter series DataLabel is not rendered after selecting StackingColumn\n    series.isRectSeries = false;\n    var marker = series.marker;\n    var visiblePoints = this.enableComplexProperty(series);\n    var argsData;\n    var getCoordinate = series.chart.chartAreaType === 'PolarRadar' ? TransformToVisible : getPoint;\n    var startLocation;\n    var redraw = series.chart.redraw;\n\n    for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {\n      var point = visiblePoints_1[_i];\n      startLocation = redraw && point.symbolLocations ? point.symbolLocations[0] : null;\n      point.symbolLocations = [];\n      point.regions = [];\n\n      if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {\n        argsData = {\n          cancel: false,\n          name: pointRender,\n          series: series,\n          point: point,\n          fill: series.setPointColor(point, series.interior),\n          border: series.setBorderColor(point, {\n            width: series.border.width,\n            color: series.border.color\n          }),\n          height: marker.height,\n          width: marker.width,\n          shape: marker.shape\n        };\n        series.chart.trigger(pointRender, argsData);\n\n        if (!argsData.cancel) {\n          point.symbolLocations.push(getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series));\n          point.color = argsData.fill;\n          this.refresh(series, point, argsData, startLocation);\n        } else {\n          point.marker = {\n            visible: true\n          };\n        }\n      }\n    }\n  };\n  /**\r\n   * To improve the chart performance.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  ScatterSeries.prototype.enableComplexProperty = function (series) {\n    var tempPoints2 = [];\n    var tempPoints = [];\n    var yVisibleRange = series.yAxis.visibleRange;\n    var xVisibleRange = series.xAxis.visibleRange;\n    var areaBounds = series.clipRect;\n    var seriesPoints = series.points;\n    var yTolerance = Math.abs(yVisibleRange.delta / areaBounds.height);\n    var xTolerance = Math.abs(xVisibleRange.delta / areaBounds.width);\n    var prevYValue = seriesPoints[0] && seriesPoints[0].y > yTolerance ? 0 : yTolerance;\n    var prevXValue = seriesPoints[0] && seriesPoints[0].x > xTolerance ? 0 : xTolerance;\n    var yVal = 0;\n    var xVal = 0;\n\n    for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {\n      var currentPoint = seriesPoints_1[_i];\n      currentPoint.symbolLocations = [];\n      yVal = currentPoint.yValue ? currentPoint.yValue : yVisibleRange.min;\n      xVal = currentPoint.xValue ? currentPoint.xValue : xVisibleRange.min;\n\n      if (Math.abs(prevYValue - yVal) >= yTolerance || Math.abs(prevXValue - xVal) >= xTolerance) {\n        tempPoints.push(currentPoint);\n        prevYValue = yVal;\n        prevXValue = xVal;\n      }\n    }\n\n    var currentTempPoint;\n\n    for (var i = 0; i < tempPoints.length; i++) {\n      currentTempPoint = tempPoints[i];\n\n      if (isNullOrUndefined(currentTempPoint.x) || currentTempPoint.x === '') {\n        continue;\n      } else {\n        tempPoints2.push(currentTempPoint);\n      }\n    }\n\n    return tempPoints2;\n  };\n  /**\r\n   * To append scatter element\r\n   *\r\n   * @param {Series} series series\r\n   * @param {Points} point point\r\n   * @param {IPointRenderEventArgs} argsData argsData\r\n   * @param {ChartLocation} startLocation startLocation\r\n   * @returns {void}\r\n   */\n\n\n  ScatterSeries.prototype.refresh = function (series, point, argsData, startLocation) {\n    var chart = series.chart;\n    var circlePath;\n    var previousPath;\n    var marker = series.marker;\n    var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;\n    var shapeOption = new PathOption(chart.element.id + '_Series_' + series.index + '_Point_' + point.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, null);\n\n    if (chart.redraw && getElement(shapeOption.id)) {\n      circlePath = argsData.shape === 'Circle' ? 'c' : '';\n      previousPath = getElement(shapeOption.id).getAttribute('d');\n    }\n\n    appendChildElement(false, series.seriesElement, drawSymbol(point.symbolLocations[0], argsData.shape, new Size(argsData.width, argsData.height), imageURL, shapeOption, point.x.toString() + ':' + point.yValue.toString(), series.chart.svgRenderer, series.clipRect), chart.redraw, true, circlePath + 'x', circlePath + 'y', startLocation, previousPath);\n    point.regions.push(new Rect(point.symbolLocations[0].x - marker.width, point.symbolLocations[0].y - marker.height, 2 * marker.width, 2 * marker.height));\n    point.marker = {\n      border: argsData.border,\n      fill: argsData.fill,\n      height: argsData.height,\n      visible: true,\n      width: argsData.width,\n      shape: argsData.shape,\n      imageUrl: imageURL\n    };\n  };\n  /**\r\n   * Animates the series.\r\n   *\r\n   * @param  {Series} series - Defines the series to animate.\r\n   * @returns {void}\r\n   */\n\n\n  ScatterSeries.prototype.doAnimation = function (series) {\n    var duration = series.animation.duration;\n    var delay = series.animation.delay;\n    var rectElements = series.seriesElement.childNodes;\n    var count = 1;\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      if (!point.symbolLocations.length || !rectElements[count]) {\n        continue;\n      }\n\n      markerAnimate(rectElements[count], delay, duration, series, point.index, point.symbolLocations[0], false);\n      count++;\n    }\n  };\n  /**\r\n   * Get module name.\r\n   */\n\n\n  ScatterSeries.prototype.getModuleName = function () {\n    /**\r\n     * Returns the module name of the series\r\n     */\n    return 'ScatterSeries';\n  };\n  /**\r\n   * To destroy the scatter.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ScatterSeries.prototype.destroy = function () {\n    /**\r\n     * Destroy method calling here\r\n     */\n  };\n\n  return ScatterSeries;\n}();\n\nexport { ScatterSeries };","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/chart/series/scatter-series.js"],"names":["withInRange","getPoint","drawSymbol","getElement","markerAnimate","TransformToVisible","appendChildElement","PathOption","Rect","Size","pointRender","isNullOrUndefined","ScatterSeries","prototype","render","series","xAxis","yAxis","isInverted","isRectSeries","marker","visiblePoints","enableComplexProperty","argsData","getCoordinate","chart","chartAreaType","startLocation","redraw","_i","visiblePoints_1","length","point","symbolLocations","regions","visible","index","cancel","name","fill","setPointColor","interior","border","setBorderColor","width","color","height","shape","trigger","push","xValue","yValue","refresh","tempPoints2","tempPoints","yVisibleRange","visibleRange","xVisibleRange","areaBounds","clipRect","seriesPoints","points","yTolerance","Math","abs","delta","xTolerance","prevYValue","y","prevXValue","x","yVal","xVal","seriesPoints_1","currentPoint","min","currentTempPoint","i","circlePath","previousPath","imageURL","imageUrl","shapeOption","element","id","opacity","getAttribute","seriesElement","toString","svgRenderer","doAnimation","duration","animation","delay","rectElements","childNodes","count","_a","getModuleName","destroy"],"mappings":"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","sourcesContent":["/* eslint-disable valid-jsdoc */\r\n/* eslint-disable jsdoc/require-returns */\r\n/* eslint-disable @typescript-eslint/no-inferrable-types */\r\n/* eslint-disable @typescript-eslint/ban-types */\r\nimport { withInRange, getPoint, drawSymbol, getElement } from '../../common/utils/helper';\r\nimport { markerAnimate, TransformToVisible, appendChildElement } from '../../common/utils/helper';\r\nimport { PathOption, Rect, Size } from '@syncfusion/ej2-svg-base';\r\nimport { pointRender } from '../../common/model/constants';\r\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\r\n/**\r\n * `ScatterSeries` module is used to render the scatter series.\r\n */\r\nvar ScatterSeries = /** @class */ (function () {\r\n    function ScatterSeries() {\r\n    }\r\n    /**\r\n     * Render the scatter series.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    ScatterSeries.prototype.render = function (series, xAxis, yAxis, isInverted) {\r\n        // Scatter series DataLabel is not rendered after selecting StackingColumn\r\n        series.isRectSeries = false;\r\n        var marker = series.marker;\r\n        var visiblePoints = this.enableComplexProperty(series);\r\n        var argsData;\r\n        var getCoordinate = series.chart.chartAreaType === 'PolarRadar' ? TransformToVisible : getPoint;\r\n        var startLocation;\r\n        var redraw = series.chart.redraw;\r\n        for (var _i = 0, visiblePoints_1 = visiblePoints; _i < visiblePoints_1.length; _i++) {\r\n            var point = visiblePoints_1[_i];\r\n            startLocation = (redraw && point.symbolLocations) ? point.symbolLocations[0] : null;\r\n            point.symbolLocations = [];\r\n            point.regions = [];\r\n            if (point.visible && withInRange(visiblePoints[point.index - 1], point, visiblePoints[point.index + 1], series)) {\r\n                argsData = {\r\n                    cancel: false, name: pointRender, series: series, point: point,\r\n                    fill: series.setPointColor(point, series.interior),\r\n                    border: series.setBorderColor(point, { width: series.border.width, color: series.border.color }),\r\n                    height: marker.height, width: marker.width, shape: marker.shape\r\n                };\r\n                series.chart.trigger(pointRender, argsData);\r\n                if (!argsData.cancel) {\r\n                    point.symbolLocations.push(getCoordinate(point.xValue, point.yValue, xAxis, yAxis, isInverted, series));\r\n                    point.color = argsData.fill;\r\n                    this.refresh(series, point, argsData, startLocation);\r\n                }\r\n                else {\r\n                    point.marker = { visible: true };\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * To improve the chart performance.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    ScatterSeries.prototype.enableComplexProperty = function (series) {\r\n        var tempPoints2 = [];\r\n        var tempPoints = [];\r\n        var yVisibleRange = series.yAxis.visibleRange;\r\n        var xVisibleRange = series.xAxis.visibleRange;\r\n        var areaBounds = series.clipRect;\r\n        var seriesPoints = series.points;\r\n        var yTolerance = Math.abs(yVisibleRange.delta / areaBounds.height);\r\n        var xTolerance = Math.abs(xVisibleRange.delta / areaBounds.width);\r\n        var prevYValue = (seriesPoints[0] && seriesPoints[0].y > yTolerance) ? 0 : yTolerance;\r\n        var prevXValue = (seriesPoints[0] && seriesPoints[0].x > xTolerance) ? 0 : xTolerance;\r\n        var yVal = 0;\r\n        var xVal = 0;\r\n        for (var _i = 0, seriesPoints_1 = seriesPoints; _i < seriesPoints_1.length; _i++) {\r\n            var currentPoint = seriesPoints_1[_i];\r\n            currentPoint.symbolLocations = [];\r\n            yVal = currentPoint.yValue ? currentPoint.yValue : yVisibleRange.min;\r\n            xVal = currentPoint.xValue ? currentPoint.xValue : xVisibleRange.min;\r\n            if (Math.abs(prevYValue - yVal) >= yTolerance || Math.abs(prevXValue - xVal) >= xTolerance) {\r\n                tempPoints.push(currentPoint);\r\n                prevYValue = yVal;\r\n                prevXValue = xVal;\r\n            }\r\n        }\r\n        var currentTempPoint;\r\n        for (var i = 0; i < tempPoints.length; i++) {\r\n            currentTempPoint = tempPoints[i];\r\n            if (isNullOrUndefined(currentTempPoint.x) || currentTempPoint.x === '') {\r\n                continue;\r\n            }\r\n            else {\r\n                tempPoints2.push(currentTempPoint);\r\n            }\r\n        }\r\n        return tempPoints2;\r\n    };\r\n    /**\r\n     * To append scatter element\r\n     *\r\n     * @param {Series} series series\r\n     * @param {Points} point point\r\n     * @param {IPointRenderEventArgs} argsData argsData\r\n     * @param {ChartLocation} startLocation startLocation\r\n     * @returns {void}\r\n     */\r\n    ScatterSeries.prototype.refresh = function (series, point, argsData, startLocation) {\r\n        var chart = series.chart;\r\n        var circlePath;\r\n        var previousPath;\r\n        var marker = series.marker;\r\n        var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;\r\n        var shapeOption = new PathOption(chart.element.id + '_Series_' + series.index + '_Point_' + point.index, argsData.fill, argsData.border.width, argsData.border.color, series.opacity, null);\r\n        if (chart.redraw && getElement(shapeOption.id)) {\r\n            circlePath = argsData.shape === 'Circle' ? 'c' : '';\r\n            previousPath = getElement(shapeOption.id).getAttribute('d');\r\n        }\r\n        appendChildElement(false, series.seriesElement, drawSymbol(point.symbolLocations[0], argsData.shape, new Size(argsData.width, argsData.height), imageURL, shapeOption, point.x.toString() + ':' + point.yValue.toString(), series.chart.svgRenderer, series.clipRect), chart.redraw, true, circlePath + 'x', circlePath + 'y', startLocation, previousPath);\r\n        point.regions.push(new Rect(point.symbolLocations[0].x - marker.width, point.symbolLocations[0].y - marker.height, 2 * marker.width, 2 * marker.height));\r\n        point.marker = {\r\n            border: argsData.border, fill: argsData.fill,\r\n            height: argsData.height, visible: true,\r\n            width: argsData.width, shape: argsData.shape, imageUrl: imageURL\r\n        };\r\n    };\r\n    /**\r\n     * Animates the series.\r\n     *\r\n     * @param  {Series} series - Defines the series to animate.\r\n     * @returns {void}\r\n     */\r\n    ScatterSeries.prototype.doAnimation = function (series) {\r\n        var duration = series.animation.duration;\r\n        var delay = series.animation.delay;\r\n        var rectElements = series.seriesElement.childNodes;\r\n        var count = 1;\r\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\r\n            var point = _a[_i];\r\n            if (!point.symbolLocations.length || !rectElements[count]) {\r\n                continue;\r\n            }\r\n            markerAnimate(rectElements[count], delay, duration, series, point.index, point.symbolLocations[0], false);\r\n            count++;\r\n        }\r\n    };\r\n    /**\r\n     * Get module name.\r\n     */\r\n    ScatterSeries.prototype.getModuleName = function () {\r\n        /**\r\n         * Returns the module name of the series\r\n         */\r\n        return 'ScatterSeries';\r\n    };\r\n    /**\r\n     * To destroy the scatter.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ScatterSeries.prototype.destroy = function () {\r\n        /**\r\n         * Destroy method calling here\r\n         */\r\n    };\r\n    return ScatterSeries;\r\n}());\r\nexport { ScatterSeries };\r\n"]},"metadata":{},"sourceType":"module"}