{"ast":null,"code":"/**\r\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\r\n * ```typescript\r\n * let encoding : Encoding = new Encoding();\r\n * encoding.type = 'Utf8';\r\n * encoding.getBytes('Encoding', 0, 5);\r\n * ```\r\n */\nvar Encoding =\n/** @class */\nfunction () {\n  /**\r\n   * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\r\n   * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\r\n   */\n  function Encoding(includeBom) {\n    this.emitBOM = true;\n    this.encodingType = 'Ansi';\n    this.initBOM(includeBom);\n  }\n\n  Object.defineProperty(Encoding.prototype, \"includeBom\", {\n    /**\r\n     * Gets a value indicating whether to write a Unicode byte order mark\r\n     * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\r\n     */\n    get: function () {\n      return this.emitBOM;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Encoding.prototype, \"type\", {\n    /**\r\n     * Gets the encoding type.\r\n     * @returns EncodingType\r\n     */\n    get: function () {\n      return this.encodingType;\n    },\n\n    /**\r\n     * Sets the encoding type.\r\n     * @param  {EncodingType} value\r\n     */\n    set: function (value) {\n      this.encodingType = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Initialize the includeBom to emit BOM or Not\r\n   * @param  {boolean} includeBom\r\n   */\n\n  Encoding.prototype.initBOM = function (includeBom) {\n    if (includeBom === undefined || includeBom === null) {\n      this.emitBOM = true;\n    } else {\n      this.emitBOM = includeBom;\n    }\n  };\n  /**\r\n   * Calculates the number of bytes produced by encoding the characters in the specified string\r\n   * @param  {string} chars - The string containing the set of characters to encode\r\n   * @returns {number} - The number of bytes produced by encoding the specified characters\r\n   */\n\n\n  Encoding.prototype.getByteCount = function (chars) {\n    var byteCount = 0;\n    validateNullOrUndefined(chars, 'string');\n\n    if (chars === '') {\n      var byte = this.utf8Len(chars.charCodeAt(0));\n      return byte;\n    }\n\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n\n    return this.getByteCountInternal(chars, 0, chars.length);\n  };\n  /**\r\n   * Return the Byte of character\r\n   * @param  {number} codePoint\r\n   * @returns {number}\r\n   */\n\n\n  Encoding.prototype.utf8Len = function (codePoint) {\n    var bytes = codePoint <= 0x7F ? 1 : codePoint <= 0x7FF ? 2 : codePoint <= 0xFFFF ? 3 : codePoint <= 0x1FFFFF ? 4 : 0;\n    return bytes;\n  };\n  /**\r\n   * for 4 byte character return surrogate pair true, otherwise false\r\n   * @param  {number} codeUnit\r\n   * @returns {boolean}\r\n   */\n\n\n  Encoding.prototype.isHighSurrogate = function (codeUnit) {\n    return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\n  };\n  /**\r\n   * for 4byte character generate the surrogate pair\r\n   * @param  {number} highCodeUnit\r\n   * @param  {number} lowCodeUnit\r\n   */\n\n\n  Encoding.prototype.toCodepoint = function (highCodeUnit, lowCodeUnit) {\n    highCodeUnit = (0x3FF & highCodeUnit) << 10;\n    var u = highCodeUnit | 0x3FF & lowCodeUnit;\n    return u + 0x10000;\n  };\n  /**\r\n   * private method to get the byte count for specific charindex and count\r\n   * @param  {string} chars\r\n   * @param  {number} charIndex\r\n   * @param  {number} charCount\r\n   */\n\n\n  Encoding.prototype.getByteCountInternal = function (chars, charIndex, charCount) {\n    var byteCount = 0;\n\n    if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\n      var isUtf8 = this.encodingType === 'Utf8';\n\n      for (var i = 0; i < charCount; i++) {\n        var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\n\n        if (this.isHighSurrogate(charCode)) {\n          if (isUtf8) {\n            var high = charCode;\n            var low = chars.charCodeAt(++charIndex);\n            byteCount += this.utf8Len(this.toCodepoint(high, low));\n          } else {\n            byteCount += 4;\n            ++i;\n          }\n        } else {\n          if (isUtf8) {\n            byteCount += this.utf8Len(charCode);\n          } else {\n            byteCount += 2;\n          }\n        }\n\n        if (isUtf8) {\n          charIndex++;\n        }\n      }\n\n      return byteCount;\n    } else {\n      byteCount = charCount;\n      return byteCount;\n    }\n  };\n  /**\r\n   * Encodes a set of characters from the specified string into the ArrayBuffer.\r\n   * @param  {string} s- The string containing the set of characters to encode\r\n   * @param  {number} charIndex-The index of the first character to encode.\r\n   * @param  {number} charCount- The number of characters to encode.\r\n   * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\r\n   */\n\n\n  Encoding.prototype.getBytes = function (s, charIndex, charCount) {\n    validateNullOrUndefined(s, 'string');\n    validateNullOrUndefined(charIndex, 'charIndex');\n    validateNullOrUndefined(charCount, 'charCount');\n\n    if (charIndex < 0 || charCount < 0) {\n      throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\n    }\n\n    if (s.length - charIndex < charCount) {\n      throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\n    }\n\n    var bytes;\n\n    if (s === '') {\n      bytes = new ArrayBuffer(0);\n      return bytes;\n    }\n\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n\n    var byteCount = this.getByteCountInternal(s, charIndex, charCount);\n\n    switch (this.type) {\n      case 'Utf8':\n        bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\n        return bytes;\n\n      case 'Unicode':\n        bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\n        return bytes;\n\n      default:\n        bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\n        return bytes;\n    }\n  };\n  /**\r\n   * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\r\n   * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\r\n   * @param  {number} index- The index of the first byte to decode.\r\n   * @param  {number} count- The number of bytes to decode.\r\n   * @returns {string} - The string that contains the resulting set of characters.\r\n   */\n\n\n  Encoding.prototype.getString = function (bytes, index, count) {\n    validateNullOrUndefined(bytes, 'bytes');\n    validateNullOrUndefined(index, 'index');\n    validateNullOrUndefined(count, 'count');\n\n    if (index < 0 || count < 0) {\n      throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\n    }\n\n    if (bytes.byteLength - index < count) {\n      throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\n    }\n\n    if (bytes.byteLength === 0 || count === 0) {\n      return '';\n    }\n\n    if (this.type === null || this.type === undefined) {\n      this.type = 'Ansi';\n    }\n\n    var out = '';\n    var byteCal = new Uint8Array(bytes);\n\n    switch (this.type) {\n      case 'Utf8':\n        var s = this.getStringOfUtf8Encoding(byteCal, index, count);\n        return s;\n\n      case 'Unicode':\n        var byteUnicode = new Uint16Array(bytes);\n        out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\n        return out;\n\n      default:\n        var j = index;\n\n        for (var i = 0; i < count; i++) {\n          var c = byteCal[j];\n          out += String.fromCharCode(c); // 1 byte(ASCII) character                  \n\n          j++;\n        }\n\n        return out;\n    }\n  };\n\n  Encoding.prototype.getBytesOfAnsiEncoding = function (byteCount, s, charIndex, charCount) {\n    var bytes = new ArrayBuffer(byteCount);\n    var bufview = new Uint8Array(bytes);\n    var k = 0;\n\n    for (var i = 0; i < charCount; i++) {\n      var charcode = s.charCodeAt(charIndex++);\n\n      if (charcode < 0x800) {\n        bufview[k] = charcode;\n      } else {\n        bufview[k] = 63; //replacement character '?'\n      }\n\n      k++;\n    }\n\n    return bytes;\n  };\n\n  Encoding.prototype.getBytesOfUtf8Encoding = function (byteCount, s, charIndex, charCount) {\n    var bytes = new ArrayBuffer(byteCount);\n    var uint = new Uint8Array(bytes);\n    var index = charIndex;\n    var j = 0;\n\n    for (var i = 0; i < charCount; i++) {\n      var charcode = s.charCodeAt(index);\n\n      if (charcode <= 0x7F) {\n        // 1 byte character 2^7\n        uint[j] = charcode;\n      } else if (charcode < 0x800) {\n        // 2 byte character 2^11\n        uint[j] = 0xc0 | charcode >> 6;\n        uint[++j] = 0x80 | charcode & 0x3f;\n      } else if (charcode < 0xd800 || charcode >= 0xe000) {\n        // 3 byte character 2^16        \n        uint[j] = 0xe0 | charcode >> 12;\n        uint[++j] = 0x80 | charcode >> 6 & 0x3f;\n        uint[++j] = 0x80 | charcode & 0x3f;\n      } else {\n        uint[j] = 0xef;\n        uint[++j] = 0xbf;\n        uint[++j] = 0xbd; // U+FFFE \"replacement character\"\n      }\n\n      ++j;\n      ++index;\n    }\n\n    return bytes;\n  };\n\n  Encoding.prototype.getBytesOfUnicodeEncoding = function (byteCount, s, charIndex, charCount) {\n    var bytes = new ArrayBuffer(byteCount);\n    var uint16 = new Uint16Array(bytes);\n\n    for (var i = 0; i < charCount; i++) {\n      var charcode = s.charCodeAt(i);\n      uint16[i] = charcode;\n    }\n\n    return bytes;\n  };\n\n  Encoding.prototype.getStringOfUtf8Encoding = function (byteCal, index, count) {\n    var j = 0;\n    var i = index;\n    var s = '';\n\n    for (j; j < count; j++) {\n      var c = byteCal[i++];\n\n      while (i > byteCal.length) {\n        return s;\n      }\n\n      if (c > 127) {\n        if (c > 191 && c < 224 && i < count) {\n          c = (c & 31) << 6 | byteCal[i] & 63;\n        } else if (c > 223 && c < 240 && i < byteCal.byteLength) {\n          c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\n        } else if (c > 239 && c < 248 && i < byteCal.byteLength) {\n          c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\n        }\n\n        ++i;\n      }\n\n      s += String.fromCharCode(c); // 1 byte(ASCII) character                          \n    }\n\n    return s;\n  };\n\n  Encoding.prototype.getStringofUnicodeEncoding = function (byteUni, index, count) {\n    if (count > byteUni.length) {\n      throw new RangeError('ArgumentOutOfRange_Count');\n    }\n\n    var byte16 = new Uint16Array(count);\n    var out = '';\n\n    for (var i = 0; i < count && i < byteUni.length; i++) {\n      byte16[i] = byteUni[index++];\n    }\n\n    out = String.fromCharCode.apply(null, byte16);\n    return out;\n  };\n  /**\r\n   * To clear the encoding instance\r\n   * @return {void}\r\n   */\n\n\n  Encoding.prototype.destroy = function () {\n    this.emitBOM = undefined;\n    this.encodingType = undefined;\n  };\n\n  return Encoding;\n}();\n\nexport { Encoding };\n/**\r\n * To check the object is null or undefined and throw error if it is null or undefined\r\n * @param {Object} value - object to check is null or undefined\r\n * @return {boolean}\r\n * @throws {ArgumentException} - if the value is null or undefined\r\n * @private\r\n */\n\nexport function validateNullOrUndefined(value, message) {\n  if (value === null || value === undefined) {\n    throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\n  }\n}","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/@syncfusion/ej2-file-utils/src/encoding.js"],"names":["Encoding","includeBom","emitBOM","encodingType","initBOM","Object","defineProperty","prototype","get","enumerable","configurable","set","value","undefined","getByteCount","chars","byteCount","validateNullOrUndefined","byte","utf8Len","charCodeAt","type","getByteCountInternal","length","codePoint","bytes","isHighSurrogate","codeUnit","toCodepoint","highCodeUnit","lowCodeUnit","u","charIndex","charCount","isUtf8","i","charCode","high","low","getBytes","s","RangeError","ArrayBuffer","getBytesOfUtf8Encoding","getBytesOfUnicodeEncoding","getBytesOfAnsiEncoding","getString","index","count","byteLength","out","byteCal","Uint8Array","getStringOfUtf8Encoding","byteUnicode","Uint16Array","getStringofUnicodeEncoding","j","c","String","fromCharCode","bufview","k","charcode","uint","uint16","byteUni","byte16","apply","destroy","message","Error"],"mappings":"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","sourcesContent":["/**\r\n * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).\r\n * ```typescript\r\n * let encoding : Encoding = new Encoding();\r\n * encoding.type = 'Utf8';\r\n * encoding.getBytes('Encoding', 0, 5);\r\n * ```\r\n */\r\nvar Encoding = /** @class */ (function () {\r\n    /**\r\n     * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark\r\n     * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.\r\n     */\r\n    function Encoding(includeBom) {\r\n        this.emitBOM = true;\r\n        this.encodingType = 'Ansi';\r\n        this.initBOM(includeBom);\r\n    }\r\n    Object.defineProperty(Encoding.prototype, \"includeBom\", {\r\n        /**\r\n         * Gets a value indicating whether to write a Unicode byte order mark\r\n         * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false\r\n         */\r\n        get: function () {\r\n            return this.emitBOM;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Encoding.prototype, \"type\", {\r\n        /**\r\n         * Gets the encoding type.\r\n         * @returns EncodingType\r\n         */\r\n        get: function () {\r\n            return this.encodingType;\r\n        },\r\n        /**\r\n         * Sets the encoding type.\r\n         * @param  {EncodingType} value\r\n         */\r\n        set: function (value) {\r\n            this.encodingType = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Initialize the includeBom to emit BOM or Not\r\n     * @param  {boolean} includeBom\r\n     */\r\n    Encoding.prototype.initBOM = function (includeBom) {\r\n        if (includeBom === undefined || includeBom === null) {\r\n            this.emitBOM = true;\r\n        }\r\n        else {\r\n            this.emitBOM = includeBom;\r\n        }\r\n    };\r\n    /**\r\n     * Calculates the number of bytes produced by encoding the characters in the specified string\r\n     * @param  {string} chars - The string containing the set of characters to encode\r\n     * @returns {number} - The number of bytes produced by encoding the specified characters\r\n     */\r\n    Encoding.prototype.getByteCount = function (chars) {\r\n        var byteCount = 0;\r\n        validateNullOrUndefined(chars, 'string');\r\n        if (chars === '') {\r\n            var byte = this.utf8Len(chars.charCodeAt(0));\r\n            return byte;\r\n        }\r\n        if (this.type === null || this.type === undefined) {\r\n            this.type = 'Ansi';\r\n        }\r\n        return this.getByteCountInternal(chars, 0, chars.length);\r\n    };\r\n    /**\r\n     * Return the Byte of character\r\n     * @param  {number} codePoint\r\n     * @returns {number}\r\n     */\r\n    Encoding.prototype.utf8Len = function (codePoint) {\r\n        var bytes = codePoint <= 0x7F ? 1 :\r\n            codePoint <= 0x7FF ? 2 :\r\n                codePoint <= 0xFFFF ? 3 :\r\n                    codePoint <= 0x1FFFFF ? 4 : 0;\r\n        return bytes;\r\n    };\r\n    /**\r\n     * for 4 byte character return surrogate pair true, otherwise false\r\n     * @param  {number} codeUnit\r\n     * @returns {boolean}\r\n     */\r\n    Encoding.prototype.isHighSurrogate = function (codeUnit) {\r\n        return codeUnit >= 0xD800 && codeUnit <= 0xDBFF;\r\n    };\r\n    /**\r\n     * for 4byte character generate the surrogate pair\r\n     * @param  {number} highCodeUnit\r\n     * @param  {number} lowCodeUnit\r\n     */\r\n    Encoding.prototype.toCodepoint = function (highCodeUnit, lowCodeUnit) {\r\n        highCodeUnit = (0x3FF & highCodeUnit) << 10;\r\n        var u = highCodeUnit | (0x3FF & lowCodeUnit);\r\n        return u + 0x10000;\r\n    };\r\n    /**\r\n     * private method to get the byte count for specific charindex and count\r\n     * @param  {string} chars\r\n     * @param  {number} charIndex\r\n     * @param  {number} charCount\r\n     */\r\n    Encoding.prototype.getByteCountInternal = function (chars, charIndex, charCount) {\r\n        var byteCount = 0;\r\n        if (this.encodingType === 'Utf8' || this.encodingType === 'Unicode') {\r\n            var isUtf8 = this.encodingType === 'Utf8';\r\n            for (var i = 0; i < charCount; i++) {\r\n                var charCode = chars.charCodeAt(isUtf8 ? charIndex : charIndex++);\r\n                if (this.isHighSurrogate(charCode)) {\r\n                    if (isUtf8) {\r\n                        var high = charCode;\r\n                        var low = chars.charCodeAt(++charIndex);\r\n                        byteCount += this.utf8Len(this.toCodepoint(high, low));\r\n                    }\r\n                    else {\r\n                        byteCount += 4;\r\n                        ++i;\r\n                    }\r\n                }\r\n                else {\r\n                    if (isUtf8) {\r\n                        byteCount += this.utf8Len(charCode);\r\n                    }\r\n                    else {\r\n                        byteCount += 2;\r\n                    }\r\n                }\r\n                if (isUtf8) {\r\n                    charIndex++;\r\n                }\r\n            }\r\n            return byteCount;\r\n        }\r\n        else {\r\n            byteCount = charCount;\r\n            return byteCount;\r\n        }\r\n    };\r\n    /**\r\n     * Encodes a set of characters from the specified string into the ArrayBuffer.\r\n     * @param  {string} s- The string containing the set of characters to encode\r\n     * @param  {number} charIndex-The index of the first character to encode.\r\n     * @param  {number} charCount- The number of characters to encode.\r\n     * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.\r\n     */\r\n    Encoding.prototype.getBytes = function (s, charIndex, charCount) {\r\n        validateNullOrUndefined(s, 'string');\r\n        validateNullOrUndefined(charIndex, 'charIndex');\r\n        validateNullOrUndefined(charCount, 'charCount');\r\n        if (charIndex < 0 || charCount < 0) {\r\n            throw new RangeError('Argument Out Of Range Exception: charIndex or charCount is less than zero');\r\n        }\r\n        if (s.length - charIndex < charCount) {\r\n            throw new RangeError('Argument Out Of Range Exception: charIndex and charCount do not denote a valid range in string');\r\n        }\r\n        var bytes;\r\n        if (s === '') {\r\n            bytes = new ArrayBuffer(0);\r\n            return bytes;\r\n        }\r\n        if (this.type === null || this.type === undefined) {\r\n            this.type = 'Ansi';\r\n        }\r\n        var byteCount = this.getByteCountInternal(s, charIndex, charCount);\r\n        switch (this.type) {\r\n            case 'Utf8':\r\n                bytes = this.getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);\r\n                return bytes;\r\n            case 'Unicode':\r\n                bytes = this.getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);\r\n                return bytes;\r\n            default:\r\n                bytes = this.getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);\r\n                return bytes;\r\n        }\r\n    };\r\n    /**\r\n     * Decodes a sequence of bytes from the specified ArrayBuffer into the string.\r\n     * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.\r\n     * @param  {number} index- The index of the first byte to decode.\r\n     * @param  {number} count- The number of bytes to decode.\r\n     * @returns {string} - The string that contains the resulting set of characters.\r\n     */\r\n    Encoding.prototype.getString = function (bytes, index, count) {\r\n        validateNullOrUndefined(bytes, 'bytes');\r\n        validateNullOrUndefined(index, 'index');\r\n        validateNullOrUndefined(count, 'count');\r\n        if (index < 0 || count < 0) {\r\n            throw new RangeError('Argument Out Of Range Exception: index or count is less than zero');\r\n        }\r\n        if (bytes.byteLength - index < count) {\r\n            throw new RangeError('Argument Out Of Range Exception: index and count do not denote a valid range in bytes');\r\n        }\r\n        if (bytes.byteLength === 0 || count === 0) {\r\n            return '';\r\n        }\r\n        if (this.type === null || this.type === undefined) {\r\n            this.type = 'Ansi';\r\n        }\r\n        var out = '';\r\n        var byteCal = new Uint8Array(bytes);\r\n        switch (this.type) {\r\n            case 'Utf8':\r\n                var s = this.getStringOfUtf8Encoding(byteCal, index, count);\r\n                return s;\r\n            case 'Unicode':\r\n                var byteUnicode = new Uint16Array(bytes);\r\n                out = this.getStringofUnicodeEncoding(byteUnicode, index, count);\r\n                return out;\r\n            default:\r\n                var j = index;\r\n                for (var i = 0; i < count; i++) {\r\n                    var c = byteCal[j];\r\n                    out += String.fromCharCode(c); // 1 byte(ASCII) character                  \r\n                    j++;\r\n                }\r\n                return out;\r\n        }\r\n    };\r\n    Encoding.prototype.getBytesOfAnsiEncoding = function (byteCount, s, charIndex, charCount) {\r\n        var bytes = new ArrayBuffer(byteCount);\r\n        var bufview = new Uint8Array(bytes);\r\n        var k = 0;\r\n        for (var i = 0; i < charCount; i++) {\r\n            var charcode = s.charCodeAt(charIndex++);\r\n            if (charcode < 0x800) {\r\n                bufview[k] = charcode;\r\n            }\r\n            else {\r\n                bufview[k] = 63; //replacement character '?'\r\n            }\r\n            k++;\r\n        }\r\n        return bytes;\r\n    };\r\n    Encoding.prototype.getBytesOfUtf8Encoding = function (byteCount, s, charIndex, charCount) {\r\n        var bytes = new ArrayBuffer(byteCount);\r\n        var uint = new Uint8Array(bytes);\r\n        var index = charIndex;\r\n        var j = 0;\r\n        for (var i = 0; i < charCount; i++) {\r\n            var charcode = s.charCodeAt(index);\r\n            if (charcode <= 0x7F) { // 1 byte character 2^7\r\n                uint[j] = charcode;\r\n            }\r\n            else if (charcode < 0x800) { // 2 byte character 2^11\r\n                uint[j] = 0xc0 | (charcode >> 6);\r\n                uint[++j] = 0x80 | (charcode & 0x3f);\r\n            }\r\n            else if ((charcode < 0xd800 || charcode >= 0xe000)) { // 3 byte character 2^16        \r\n                uint[j] = 0xe0 | (charcode >> 12);\r\n                uint[++j] = 0x80 | ((charcode >> 6) & 0x3f);\r\n                uint[++j] = 0x80 | (charcode & 0x3f);\r\n            }\r\n            else {\r\n                uint[j] = 0xef;\r\n                uint[++j] = 0xbf;\r\n                uint[++j] = 0xbd; // U+FFFE \"replacement character\"\r\n            }\r\n            ++j;\r\n            ++index;\r\n        }\r\n        return bytes;\r\n    };\r\n    Encoding.prototype.getBytesOfUnicodeEncoding = function (byteCount, s, charIndex, charCount) {\r\n        var bytes = new ArrayBuffer(byteCount);\r\n        var uint16 = new Uint16Array(bytes);\r\n        for (var i = 0; i < charCount; i++) {\r\n            var charcode = s.charCodeAt(i);\r\n            uint16[i] = charcode;\r\n        }\r\n        return bytes;\r\n    };\r\n    Encoding.prototype.getStringOfUtf8Encoding = function (byteCal, index, count) {\r\n        var j = 0;\r\n        var i = index;\r\n        var s = '';\r\n        for (j; j < count; j++) {\r\n            var c = byteCal[i++];\r\n            while (i > byteCal.length) {\r\n                return s;\r\n            }\r\n            if (c > 127) {\r\n                if (c > 191 && c < 224 && i < count) {\r\n                    c = (c & 31) << 6 | byteCal[i] & 63;\r\n                }\r\n                else if (c > 223 && c < 240 && i < byteCal.byteLength) {\r\n                    c = (c & 15) << 12 | (byteCal[i] & 63) << 6 | byteCal[++i] & 63;\r\n                }\r\n                else if (c > 239 && c < 248 && i < byteCal.byteLength) {\r\n                    c = (c & 7) << 18 | (byteCal[i] & 63) << 12 | (byteCal[++i] & 63) << 6 | byteCal[++i] & 63;\r\n                }\r\n                ++i;\r\n            }\r\n            s += String.fromCharCode(c); // 1 byte(ASCII) character                          \r\n        }\r\n        return s;\r\n    };\r\n    Encoding.prototype.getStringofUnicodeEncoding = function (byteUni, index, count) {\r\n        if (count > byteUni.length) {\r\n            throw new RangeError('ArgumentOutOfRange_Count');\r\n        }\r\n        var byte16 = new Uint16Array(count);\r\n        var out = '';\r\n        for (var i = 0; i < count && i < byteUni.length; i++) {\r\n            byte16[i] = byteUni[index++];\r\n        }\r\n        out = String.fromCharCode.apply(null, byte16);\r\n        return out;\r\n    };\r\n    /**\r\n     * To clear the encoding instance\r\n     * @return {void}\r\n     */\r\n    Encoding.prototype.destroy = function () {\r\n        this.emitBOM = undefined;\r\n        this.encodingType = undefined;\r\n    };\r\n    return Encoding;\r\n}());\r\nexport { Encoding };\r\n/**\r\n * To check the object is null or undefined and throw error if it is null or undefined\r\n * @param {Object} value - object to check is null or undefined\r\n * @return {boolean}\r\n * @throws {ArgumentException} - if the value is null or undefined\r\n * @private\r\n */\r\nexport function validateNullOrUndefined(value, message) {\r\n    if (value === null || value === undefined) {\r\n        throw new Error('ArgumentException: ' + message + ' cannot be null or undefined');\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}