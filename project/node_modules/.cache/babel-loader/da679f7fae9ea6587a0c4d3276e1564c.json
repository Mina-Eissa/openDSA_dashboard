{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport { isFunctionNode, isOperatorNode, isParenthesisNode } from '../../../utils/is.js';\nimport { factory } from '../../../utils/factory.js';\nimport { hasOwnProperty } from '../../../utils/object.js';\nvar name = 'simplifyUtil';\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\nexport var createUtil = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  } = _ref; // TODO commutative/associative properties rely on the arguments\n  // e.g. multiply is not commutative for matrices\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\n\n  /* So that properties of an operator fit on one line: */\n\n  var T = true;\n  var F = false;\n  var defaultName = 'defaultF';\n  var defaultContext = {\n    /*      */\n    add: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: T\n    },\n\n    /**/\n    unaryPlus: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: T\n    },\n\n    /* */\n    subtract: {\n      trivial: F,\n      total: T,\n      commutative: F,\n      associative: F\n    },\n\n    /* */\n    multiply: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: T\n    },\n\n    /*   */\n    divide: {\n      trivial: F,\n      total: T,\n      commutative: F,\n      associative: F\n    },\n\n    /*    */\n    paren: {\n      trivial: T,\n      total: T,\n      commutative: T,\n      associative: F\n    },\n\n    /* */\n    defaultF: {\n      trivial: F,\n      total: T,\n      commutative: F,\n      associative: F\n    }\n  };\n  var realContext = {\n    divide: {\n      total: F\n    },\n    log: {\n      total: F\n    }\n  };\n  var positiveContext = {\n    subtract: {\n      total: F\n    },\n    abs: {\n      trivial: T\n    },\n    log: {\n      total: T\n    }\n  };\n\n  function hasProperty(nodeOrName, property) {\n    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultContext;\n    var name = defaultName;\n\n    if (typeof nodeOrName === 'string') {\n      name = nodeOrName;\n    } else if (isOperatorNode(nodeOrName)) {\n      name = nodeOrName.fn.toString();\n    } else if (isFunctionNode(nodeOrName)) {\n      name = nodeOrName.name;\n    } else if (isParenthesisNode(nodeOrName)) {\n      name = 'paren';\n    }\n\n    if (hasOwnProperty(context, name)) {\n      var properties = context[name];\n\n      if (hasOwnProperty(properties, property)) {\n        return properties[property];\n      }\n\n      if (hasOwnProperty(defaultContext, name)) {\n        return defaultContext[name][property];\n      }\n    }\n\n    if (hasOwnProperty(context, defaultName)) {\n      var _properties = context[defaultName];\n\n      if (hasOwnProperty(_properties, property)) {\n        return _properties[property];\n      }\n\n      return defaultContext[defaultName][property];\n    }\n    /* name not found in context and context has no global default */\n\n    /* So use default context. */\n\n\n    if (hasOwnProperty(defaultContext, name)) {\n      var _properties2 = defaultContext[name];\n\n      if (hasOwnProperty(_properties2, property)) {\n        return _properties2[property];\n      }\n    }\n\n    return defaultContext[defaultName][property];\n  }\n\n  function isCommutative(node) {\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;\n    return hasProperty(node, 'commutative', context);\n  }\n\n  function isAssociative(node) {\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;\n    return hasProperty(node, 'associative', context);\n  }\n  /**\r\n   * Merge the given contexts, with primary overriding secondary\r\n   * wherever they might conflict\r\n   */\n\n\n  function mergeContext(primary, secondary) {\n    var merged = _objectSpread({}, primary);\n\n    for (var prop in secondary) {\n      if (hasOwnProperty(primary, prop)) {\n        merged[prop] = _objectSpread(_objectSpread({}, secondary[prop]), primary[prop]);\n      } else {\n        merged[prop] = secondary[prop];\n      }\n    }\n\n    return merged;\n  }\n  /**\r\n   * Flatten all associative operators in an expression tree.\r\n   * Assumes parentheses have already been removed.\r\n   */\n\n\n  function flatten(node, context) {\n    if (!node.args || node.args.length === 0) {\n      return node;\n    }\n\n    node.args = allChildren(node, context);\n\n    for (var i = 0; i < node.args.length; i++) {\n      flatten(node.args[i], context);\n    }\n  }\n  /**\r\n   * Get the children of a node as if it has been flattened.\r\n   * TODO implement for FunctionNodes\r\n   */\n\n\n  function allChildren(node, context) {\n    var op;\n    var children = [];\n\n    var findChildren = function findChildren(node) {\n      for (var i = 0; i < node.args.length; i++) {\n        var child = node.args[i];\n\n        if (isOperatorNode(child) && op === child.op) {\n          findChildren(child);\n        } else {\n          children.push(child);\n        }\n      }\n    };\n\n    if (isAssociative(node, context)) {\n      op = node.op;\n      findChildren(node);\n      return children;\n    } else {\n      return node.args;\n    }\n  }\n  /**\r\n   *  Unflatten all flattened operators to a right-heavy binary tree.\r\n   */\n\n\n  function unflattenr(node, context) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenr(node.args[i], context);\n    }\n\n    if (l > 2 && isAssociative(node, context)) {\n      var curnode = node.args.pop();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([node.args.pop(), curnode]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n  /**\r\n   *  Unflatten all flattened operators to a left-heavy binary tree.\r\n   */\n\n\n  function unflattenl(node, context) {\n    if (!node.args || node.args.length === 0) {\n      return;\n    }\n\n    var makeNode = createMakeNodeFunction(node);\n    var l = node.args.length;\n\n    for (var i = 0; i < l; i++) {\n      unflattenl(node.args[i], context);\n    }\n\n    if (l > 2 && isAssociative(node, context)) {\n      var curnode = node.args.shift();\n\n      while (node.args.length > 0) {\n        curnode = makeNode([curnode, node.args.shift()]);\n      }\n\n      node.args = curnode.args;\n    }\n  }\n\n  function createMakeNodeFunction(node) {\n    if (isOperatorNode(node)) {\n      return function (args) {\n        try {\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\n        } catch (err) {\n          console.error(err);\n          return [];\n        }\n      };\n    } else {\n      return function (args) {\n        return new FunctionNode(new SymbolNode(node.name), args);\n      };\n    }\n  }\n\n  return {\n    createMakeNodeFunction,\n    hasProperty,\n    isCommutative,\n    isAssociative,\n    mergeContext,\n    flatten,\n    allChildren,\n    unflattenr,\n    unflattenl,\n    defaultContext,\n    realContext,\n    positiveContext\n  };\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/simplify/util.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","isFunctionNode","isOperatorNode","isParenthesisNode","factory","hasOwnProperty","name","dependencies","createUtil","_ref","FunctionNode","OperatorNode","SymbolNode","T","F","defaultName","defaultContext","add","trivial","total","commutative","associative","unaryPlus","subtract","multiply","divide","paren","defaultF","realContext","log","positiveContext","abs","hasProperty","nodeOrName","property","context","undefined","fn","toString","properties","_properties","_properties2","isCommutative","node","isAssociative","mergeContext","primary","secondary","merged","prop","flatten","args","allChildren","op","children","findChildren","child","unflattenr","makeNode","createMakeNodeFunction","l","curnode","pop","unflattenl","shift","implicit","err","console","error"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\r\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\r\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\r\nimport { isFunctionNode, isOperatorNode, isParenthesisNode } from '../../../utils/is.js';\r\nimport { factory } from '../../../utils/factory.js';\r\nimport { hasOwnProperty } from '../../../utils/object.js';\r\nvar name = 'simplifyUtil';\r\nvar dependencies = ['FunctionNode', 'OperatorNode', 'SymbolNode'];\r\nexport var createUtil = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    FunctionNode,\r\n    OperatorNode,\r\n    SymbolNode\r\n  } = _ref;\r\n  // TODO commutative/associative properties rely on the arguments\r\n  // e.g. multiply is not commutative for matrices\r\n  // The properties should be calculated from an argument to simplify, or possibly something in math.config\r\n  // the other option is for typed() to specify a return type so that we can evaluate the type of arguments\r\n\r\n  /* So that properties of an operator fit on one line: */\r\n  var T = true;\r\n  var F = false;\r\n  var defaultName = 'defaultF';\r\n  var defaultContext = {\r\n    /*      */add: {\r\n      trivial: T,\r\n      total: T,\r\n      commutative: T,\r\n      associative: T\r\n    },\r\n    /**/unaryPlus: {\r\n      trivial: T,\r\n      total: T,\r\n      commutative: T,\r\n      associative: T\r\n    },\r\n    /* */subtract: {\r\n      trivial: F,\r\n      total: T,\r\n      commutative: F,\r\n      associative: F\r\n    },\r\n    /* */multiply: {\r\n      trivial: T,\r\n      total: T,\r\n      commutative: T,\r\n      associative: T\r\n    },\r\n    /*   */divide: {\r\n      trivial: F,\r\n      total: T,\r\n      commutative: F,\r\n      associative: F\r\n    },\r\n    /*    */paren: {\r\n      trivial: T,\r\n      total: T,\r\n      commutative: T,\r\n      associative: F\r\n    },\r\n    /* */defaultF: {\r\n      trivial: F,\r\n      total: T,\r\n      commutative: F,\r\n      associative: F\r\n    }\r\n  };\r\n  var realContext = {\r\n    divide: {\r\n      total: F\r\n    },\r\n    log: {\r\n      total: F\r\n    }\r\n  };\r\n  var positiveContext = {\r\n    subtract: {\r\n      total: F\r\n    },\r\n    abs: {\r\n      trivial: T\r\n    },\r\n    log: {\r\n      total: T\r\n    }\r\n  };\r\n  function hasProperty(nodeOrName, property) {\r\n    var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultContext;\r\n    var name = defaultName;\r\n    if (typeof nodeOrName === 'string') {\r\n      name = nodeOrName;\r\n    } else if (isOperatorNode(nodeOrName)) {\r\n      name = nodeOrName.fn.toString();\r\n    } else if (isFunctionNode(nodeOrName)) {\r\n      name = nodeOrName.name;\r\n    } else if (isParenthesisNode(nodeOrName)) {\r\n      name = 'paren';\r\n    }\r\n    if (hasOwnProperty(context, name)) {\r\n      var properties = context[name];\r\n      if (hasOwnProperty(properties, property)) {\r\n        return properties[property];\r\n      }\r\n      if (hasOwnProperty(defaultContext, name)) {\r\n        return defaultContext[name][property];\r\n      }\r\n    }\r\n    if (hasOwnProperty(context, defaultName)) {\r\n      var _properties = context[defaultName];\r\n      if (hasOwnProperty(_properties, property)) {\r\n        return _properties[property];\r\n      }\r\n      return defaultContext[defaultName][property];\r\n    }\r\n    /* name not found in context and context has no global default */\r\n    /* So use default context. */\r\n    if (hasOwnProperty(defaultContext, name)) {\r\n      var _properties2 = defaultContext[name];\r\n      if (hasOwnProperty(_properties2, property)) {\r\n        return _properties2[property];\r\n      }\r\n    }\r\n    return defaultContext[defaultName][property];\r\n  }\r\n  function isCommutative(node) {\r\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;\r\n    return hasProperty(node, 'commutative', context);\r\n  }\r\n  function isAssociative(node) {\r\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultContext;\r\n    return hasProperty(node, 'associative', context);\r\n  }\r\n\r\n  /**\r\n   * Merge the given contexts, with primary overriding secondary\r\n   * wherever they might conflict\r\n   */\r\n  function mergeContext(primary, secondary) {\r\n    var merged = _objectSpread({}, primary);\r\n    for (var prop in secondary) {\r\n      if (hasOwnProperty(primary, prop)) {\r\n        merged[prop] = _objectSpread(_objectSpread({}, secondary[prop]), primary[prop]);\r\n      } else {\r\n        merged[prop] = secondary[prop];\r\n      }\r\n    }\r\n    return merged;\r\n  }\r\n\r\n  /**\r\n   * Flatten all associative operators in an expression tree.\r\n   * Assumes parentheses have already been removed.\r\n   */\r\n  function flatten(node, context) {\r\n    if (!node.args || node.args.length === 0) {\r\n      return node;\r\n    }\r\n    node.args = allChildren(node, context);\r\n    for (var i = 0; i < node.args.length; i++) {\r\n      flatten(node.args[i], context);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the children of a node as if it has been flattened.\r\n   * TODO implement for FunctionNodes\r\n   */\r\n  function allChildren(node, context) {\r\n    var op;\r\n    var children = [];\r\n    var findChildren = function findChildren(node) {\r\n      for (var i = 0; i < node.args.length; i++) {\r\n        var child = node.args[i];\r\n        if (isOperatorNode(child) && op === child.op) {\r\n          findChildren(child);\r\n        } else {\r\n          children.push(child);\r\n        }\r\n      }\r\n    };\r\n    if (isAssociative(node, context)) {\r\n      op = node.op;\r\n      findChildren(node);\r\n      return children;\r\n    } else {\r\n      return node.args;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  Unflatten all flattened operators to a right-heavy binary tree.\r\n   */\r\n  function unflattenr(node, context) {\r\n    if (!node.args || node.args.length === 0) {\r\n      return;\r\n    }\r\n    var makeNode = createMakeNodeFunction(node);\r\n    var l = node.args.length;\r\n    for (var i = 0; i < l; i++) {\r\n      unflattenr(node.args[i], context);\r\n    }\r\n    if (l > 2 && isAssociative(node, context)) {\r\n      var curnode = node.args.pop();\r\n      while (node.args.length > 0) {\r\n        curnode = makeNode([node.args.pop(), curnode]);\r\n      }\r\n      node.args = curnode.args;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  Unflatten all flattened operators to a left-heavy binary tree.\r\n   */\r\n  function unflattenl(node, context) {\r\n    if (!node.args || node.args.length === 0) {\r\n      return;\r\n    }\r\n    var makeNode = createMakeNodeFunction(node);\r\n    var l = node.args.length;\r\n    for (var i = 0; i < l; i++) {\r\n      unflattenl(node.args[i], context);\r\n    }\r\n    if (l > 2 && isAssociative(node, context)) {\r\n      var curnode = node.args.shift();\r\n      while (node.args.length > 0) {\r\n        curnode = makeNode([curnode, node.args.shift()]);\r\n      }\r\n      node.args = curnode.args;\r\n    }\r\n  }\r\n  function createMakeNodeFunction(node) {\r\n    if (isOperatorNode(node)) {\r\n      return function (args) {\r\n        try {\r\n          return new OperatorNode(node.op, node.fn, args, node.implicit);\r\n        } catch (err) {\r\n          console.error(err);\r\n          return [];\r\n        }\r\n      };\r\n    } else {\r\n      return function (args) {\r\n        return new FunctionNode(new SymbolNode(node.name), args);\r\n      };\r\n    }\r\n  }\r\n  return {\r\n    createMakeNodeFunction,\r\n    hasProperty,\r\n    isCommutative,\r\n    isAssociative,\r\n    mergeContext,\r\n    flatten,\r\n    allChildren,\r\n    unflattenr,\r\n    unflattenl,\r\n    defaultContext,\r\n    realContext,\r\n    positiveContext\r\n  };\r\n});"]},"metadata":{},"sourceType":"module"}