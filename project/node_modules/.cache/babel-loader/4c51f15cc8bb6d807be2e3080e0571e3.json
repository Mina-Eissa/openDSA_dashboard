{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { isNode, isSymbolNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { getPrecedence } from '../operators.js';\nvar name = 'RangeNode';\nvar dependencies = ['Node'];\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\r\n   * Calculate the necessary parentheses\r\n   * @param {Node} node\r\n   * @param {string} parenthesis\r\n   * @param {string} implicit\r\n   * @return {Object} parentheses\r\n   * @private\r\n   */\n\n  function calculateNecessaryParentheses(node, parenthesis, implicit) {\n    var precedence = getPrecedence(node, parenthesis, implicit);\n    var parens = {};\n    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\n\n    if (node.step) {\n      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\n    }\n\n    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\n    return parens;\n  }\n\n  class RangeNode extends Node {\n    /**\r\n     * @constructor RangeNode\r\n     * @extends {Node}\r\n     * create a range\r\n     * @param {Node} start  included lower-bound\r\n     * @param {Node} end    included upper-bound\r\n     * @param {Node} [step] optional step\r\n     */\n    constructor(start, end, step) {\n      super(); // validate inputs\n\n      if (!isNode(start)) throw new TypeError('Node expected');\n      if (!isNode(end)) throw new TypeError('Node expected');\n      if (step && !isNode(step)) throw new TypeError('Node expected');\n      if (arguments.length > 3) throw new Error('Too many arguments');\n      this.start = start; // included lower-bound\n\n      this.end = end; // included upper-bound\n\n      this.step = step || null; // optional step\n    }\n\n    get type() {\n      return name;\n    }\n\n    get isRangeNode() {\n      return true;\n    }\n    /**\r\n     * Check whether the RangeNode needs the `end` symbol to be defined.\r\n     * This end is the size of the Matrix in current dimension.\r\n     * @return {boolean}\r\n     */\n\n\n    needsEnd() {\n      // find all `end` symbols in this RangeNode\n      var endSymbols = this.filter(function (node) {\n        return isSymbolNode(node) && node.name === 'end';\n      });\n      return endSymbols.length > 0;\n    }\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\n\n\n    _compile(math, argNames) {\n      var range = math.range;\n\n      var evalStart = this.start._compile(math, argNames);\n\n      var evalEnd = this.end._compile(math, argNames);\n\n      if (this.step) {\n        var evalStep = this.step._compile(math, argNames);\n\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\n        };\n      } else {\n        return function evalRangeNode(scope, args, context) {\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context));\n        };\n      }\n    }\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\n\n\n    forEach(callback) {\n      callback(this.start, 'start', this);\n      callback(this.end, 'end', this);\n\n      if (this.step) {\n        callback(this.step, 'step', this);\n      }\n    }\n    /**\r\n     * Create a new RangeNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {RangeNode} Returns a transformed copy of the node\r\n     */\n\n\n    map(callback) {\n      return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\n    }\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {RangeNode}\r\n     */\n\n\n    clone() {\n      return new RangeNode(this.start, this.end, this.step && this.step);\n    }\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    _toString(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit); // format string as start:step:stop\n\n      var str;\n      var start = this.start.toString(options);\n\n      if (parens.start) {\n        start = '(' + start + ')';\n      }\n\n      str = start;\n\n      if (this.step) {\n        var step = this.step.toString(options);\n\n        if (parens.step) {\n          step = '(' + step + ')';\n        }\n\n        str += ':' + step;\n      }\n\n      var end = this.end.toString(options);\n\n      if (parens.end) {\n        end = '(' + end + ')';\n      }\n\n      str += ':' + end;\n      return str;\n    }\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\n\n\n    toJSON() {\n      return {\n        mathjs: name,\n        start: this.start,\n        end: this.end,\n        step: this.step\n      };\n    }\n    /**\r\n     * Instantiate an RangeNode from its JSON representation\r\n     * @param {Object} json\r\n     *     An object structured like\r\n     *     `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\r\n     *     where mathjs is optional\r\n     * @returns {RangeNode}\r\n     */\n\n\n    static fromJSON(json) {\n      return new RangeNode(json.start, json.end, json.step);\n    }\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    toHTML(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit); // format string as start:step:stop\n\n      var str;\n      var start = this.start.toHTML(options);\n\n      if (parens.start) {\n        start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str = start;\n\n      if (this.step) {\n        var step = this.step.toHTML(options);\n\n        if (parens.step) {\n          step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n        }\n\n        str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\n      }\n\n      var end = this.end.toHTML(options);\n\n      if (parens.end) {\n        end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\n      }\n\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\n      return str;\n    }\n    /**\r\n     * Get LaTeX representation\r\n     * @params {Object} options\r\n     * @return {string} str\r\n     */\n\n\n    _toTex(options) {\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\n      var str = this.start.toTex(options);\n\n      if (parens.start) {\n        str = \"\\\\left(\".concat(str, \"\\\\right)\");\n      }\n\n      if (this.step) {\n        var step = this.step.toTex(options);\n\n        if (parens.step) {\n          step = \"\\\\left(\".concat(step, \"\\\\right)\");\n        }\n\n        str += ':' + step;\n      }\n\n      var end = this.end.toTex(options);\n\n      if (parens.end) {\n        end = \"\\\\left(\".concat(end, \"\\\\right)\");\n      }\n\n      str += ':' + end;\n      return str;\n    }\n\n  }\n\n  _defineProperty(RangeNode, \"name\", name);\n\n  return RangeNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/expression/node/RangeNode.js"],"names":["_defineProperty","isNode","isSymbolNode","factory","getPrecedence","name","dependencies","createRangeNode","_ref","Node","calculateNecessaryParentheses","node","parenthesis","implicit","precedence","parens","startPrecedence","start","step","stepPrecedence","endPrecedence","end","RangeNode","constructor","TypeError","arguments","length","Error","type","isRangeNode","needsEnd","endSymbols","filter","_compile","math","argNames","range","evalStart","evalEnd","evalStep","evalRangeNode","scope","args","context","forEach","callback","map","_ifNode","clone","_toString","options","str","toString","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","concat","isClass"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\r\nimport { isNode, isSymbolNode } from '../../utils/is.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { getPrecedence } from '../operators.js';\r\nvar name = 'RangeNode';\r\nvar dependencies = ['Node'];\r\nexport var createRangeNode = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    Node\r\n  } = _ref;\r\n  /**\r\n   * Calculate the necessary parentheses\r\n   * @param {Node} node\r\n   * @param {string} parenthesis\r\n   * @param {string} implicit\r\n   * @return {Object} parentheses\r\n   * @private\r\n   */\r\n  function calculateNecessaryParentheses(node, parenthesis, implicit) {\r\n    var precedence = getPrecedence(node, parenthesis, implicit);\r\n    var parens = {};\r\n    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);\r\n    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === 'all';\r\n    if (node.step) {\r\n      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);\r\n      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === 'all';\r\n    }\r\n    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);\r\n    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === 'all';\r\n    return parens;\r\n  }\r\n  class RangeNode extends Node {\r\n    /**\r\n     * @constructor RangeNode\r\n     * @extends {Node}\r\n     * create a range\r\n     * @param {Node} start  included lower-bound\r\n     * @param {Node} end    included upper-bound\r\n     * @param {Node} [step] optional step\r\n     */\r\n    constructor(start, end, step) {\r\n      super();\r\n      // validate inputs\r\n      if (!isNode(start)) throw new TypeError('Node expected');\r\n      if (!isNode(end)) throw new TypeError('Node expected');\r\n      if (step && !isNode(step)) throw new TypeError('Node expected');\r\n      if (arguments.length > 3) throw new Error('Too many arguments');\r\n      this.start = start; // included lower-bound\r\n      this.end = end; // included upper-bound\r\n      this.step = step || null; // optional step\r\n    }\r\n\r\n    get type() {\r\n      return name;\r\n    }\r\n    get isRangeNode() {\r\n      return true;\r\n    }\r\n\r\n    /**\r\n     * Check whether the RangeNode needs the `end` symbol to be defined.\r\n     * This end is the size of the Matrix in current dimension.\r\n     * @return {boolean}\r\n     */\r\n    needsEnd() {\r\n      // find all `end` symbols in this RangeNode\r\n      var endSymbols = this.filter(function (node) {\r\n        return isSymbolNode(node) && node.name === 'end';\r\n      });\r\n      return endSymbols.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Compile a node into a JavaScript function.\r\n     * This basically pre-calculates as much as possible and only leaves open\r\n     * calculations which depend on a dynamic scope with variables.\r\n     * @param {Object} math     Math.js namespace with functions and constants.\r\n     * @param {Object} argNames An object with argument names as key and `true`\r\n     *                          as value. Used in the SymbolNode to optimize\r\n     *                          for arguments from user assigned functions\r\n     *                          (see FunctionAssignmentNode) or special symbols\r\n     *                          like `end` (see IndexNode).\r\n     * @return {function} Returns a function which can be called like:\r\n     *                        evalNode(scope: Object, args: Object, context: *)\r\n     */\r\n    _compile(math, argNames) {\r\n      var range = math.range;\r\n      var evalStart = this.start._compile(math, argNames);\r\n      var evalEnd = this.end._compile(math, argNames);\r\n      if (this.step) {\r\n        var evalStep = this.step._compile(math, argNames);\r\n        return function evalRangeNode(scope, args, context) {\r\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));\r\n        };\r\n      } else {\r\n        return function evalRangeNode(scope, args, context) {\r\n          return range(evalStart(scope, args, context), evalEnd(scope, args, context));\r\n        };\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Execute a callback for each of the child nodes of this node\r\n     * @param {function(child: Node, path: string, parent: Node)} callback\r\n     */\r\n    forEach(callback) {\r\n      callback(this.start, 'start', this);\r\n      callback(this.end, 'end', this);\r\n      if (this.step) {\r\n        callback(this.step, 'step', this);\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Create a new RangeNode whose children are the results of calling\r\n     * the provided callback function for each child of the original node.\r\n     * @param {function(child: Node, path: string, parent: Node): Node} callback\r\n     * @returns {RangeNode} Returns a transformed copy of the node\r\n     */\r\n    map(callback) {\r\n      return new RangeNode(this._ifNode(callback(this.start, 'start', this)), this._ifNode(callback(this.end, 'end', this)), this.step && this._ifNode(callback(this.step, 'step', this)));\r\n    }\r\n\r\n    /**\r\n     * Create a clone of this node, a shallow copy\r\n     * @return {RangeNode}\r\n     */\r\n    clone() {\r\n      return new RangeNode(this.start, this.end, this.step && this.step);\r\n    }\r\n\r\n    /**\r\n     * Get string representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    _toString(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\r\n\r\n      // format string as start:step:stop\r\n      var str;\r\n      var start = this.start.toString(options);\r\n      if (parens.start) {\r\n        start = '(' + start + ')';\r\n      }\r\n      str = start;\r\n      if (this.step) {\r\n        var step = this.step.toString(options);\r\n        if (parens.step) {\r\n          step = '(' + step + ')';\r\n        }\r\n        str += ':' + step;\r\n      }\r\n      var end = this.end.toString(options);\r\n      if (parens.end) {\r\n        end = '(' + end + ')';\r\n      }\r\n      str += ':' + end;\r\n      return str;\r\n    }\r\n\r\n    /**\r\n     * Get a JSON representation of the node\r\n     * @returns {Object}\r\n     */\r\n    toJSON() {\r\n      return {\r\n        mathjs: name,\r\n        start: this.start,\r\n        end: this.end,\r\n        step: this.step\r\n      };\r\n    }\r\n\r\n    /**\r\n     * Instantiate an RangeNode from its JSON representation\r\n     * @param {Object} json\r\n     *     An object structured like\r\n     *     `{\"mathjs\": \"RangeNode\", \"start\": ..., \"end\": ..., \"step\": ...}`,\r\n     *     where mathjs is optional\r\n     * @returns {RangeNode}\r\n     */\r\n    static fromJSON(json) {\r\n      return new RangeNode(json.start, json.end, json.step);\r\n    }\r\n\r\n    /**\r\n     * Get HTML representation\r\n     * @param {Object} options\r\n     * @return {string} str\r\n     */\r\n    toHTML(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\r\n\r\n      // format string as start:step:stop\r\n      var str;\r\n      var start = this.start.toHTML(options);\r\n      if (parens.start) {\r\n        start = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + start + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n      }\r\n      str = start;\r\n      if (this.step) {\r\n        var step = this.step.toHTML(options);\r\n        if (parens.step) {\r\n          step = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + step + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n        }\r\n        str += '<span class=\"math-operator math-range-operator\">:</span>' + step;\r\n      }\r\n      var end = this.end.toHTML(options);\r\n      if (parens.end) {\r\n        end = '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + end + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>';\r\n      }\r\n      str += '<span class=\"math-operator math-range-operator\">:</span>' + end;\r\n      return str;\r\n    }\r\n\r\n    /**\r\n     * Get LaTeX representation\r\n     * @params {Object} options\r\n     * @return {string} str\r\n     */\r\n    _toTex(options) {\r\n      var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\r\n      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);\r\n      var str = this.start.toTex(options);\r\n      if (parens.start) {\r\n        str = \"\\\\left(\".concat(str, \"\\\\right)\");\r\n      }\r\n      if (this.step) {\r\n        var step = this.step.toTex(options);\r\n        if (parens.step) {\r\n          step = \"\\\\left(\".concat(step, \"\\\\right)\");\r\n        }\r\n        str += ':' + step;\r\n      }\r\n      var end = this.end.toTex(options);\r\n      if (parens.end) {\r\n        end = \"\\\\left(\".concat(end, \"\\\\right)\");\r\n      }\r\n      str += ':' + end;\r\n      return str;\r\n    }\r\n  }\r\n  _defineProperty(RangeNode, \"name\", name);\r\n  return RangeNode;\r\n}, {\r\n  isClass: true,\r\n  isNode: true\r\n});"]},"metadata":{},"sourceType":"module"}