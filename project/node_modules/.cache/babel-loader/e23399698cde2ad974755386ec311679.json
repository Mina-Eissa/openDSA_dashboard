{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n/* eslint-disable @typescript-eslint/no-inferrable-types */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable jsdoc/require-param */\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n\nimport { RectOption, appendChildElement, getElement, appendClipElement } from '../../common/utils/helper';\nimport { findlElement, drawSymbol, markerAnimate, CircleOption } from '../../common/utils/helper';\nimport { PathOption, Size } from '@syncfusion/ej2-svg-base';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { pointRender } from '../../common/model/constants';\nimport { MarkerExplode } from './marker-explode';\nimport { getSaturationColor } from '../../common/utils/helper';\n/**\r\n * Marker module used to render the marker for line type series.\r\n */\n\nvar Marker =\n/** @class */\nfunction (_super) {\n  __extends(Marker, _super);\n  /**\r\n   * Constructor for the marker module.\r\n   *\r\n   * @private\r\n   */\n\n\n  function Marker(chart) {\n    var _this = _super.call(this, chart) || this;\n\n    _this.addEventListener();\n\n    return _this;\n  }\n  /**\r\n   * Render the marker for series.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  Marker.prototype.render = function (series) {\n    var _this = this;\n\n    var redraw = series.chart.redraw;\n    this.createElement(series, redraw);\n\n    var _loop_1 = function (point) {\n      if (point.visible && point.symbolLocations && point.symbolLocations.length) {\n        point.symbolLocations.map(function (location, index) {\n          if (series.marker.shape !== 'None') {\n            _this.renderMarker(series, point, location, index, redraw);\n          }\n        });\n      }\n    };\n\n    for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\n      var point = _a[_i];\n\n      _loop_1(point);\n    }\n  };\n\n  Marker.prototype.renderMarker = function (series, point, location, index, redraw) {\n    var seriesIndex = series.index === undefined ? series.category : series.index;\n    var marker = series.marker;\n    var border = {\n      color: marker.border.color,\n      width: marker.border.width\n    };\n    var borderColor = marker.border.color;\n    var previousLocation;\n    var previousPath;\n    var circlePath;\n    var shapeOption;\n    location.x = location.x + marker.offset.x;\n    location.y = location.y - marker.offset.y;\n    var isBoxPlot = series.type === 'BoxAndWhisker';\n    var fill = marker.fill || (isBoxPlot ? point.interior || series.interior : '#ffffff');\n    var markerElement;\n    var parentElement = isBoxPlot ? findlElement(series.seriesElement.childNodes, 'Series_' + series.index + '_Point_' + point.index) : series.symbolElement;\n    border.color = borderColor || series.setPointColor(point, series.interior);\n    var symbolId = this.elementId + '_Series_' + seriesIndex + '_Point_' + point.index + '_Symbol' + (index ? index : '');\n    var argsData = {\n      cancel: false,\n      name: pointRender,\n      series: series,\n      point: point,\n      fill: point.isEmpty ? series.emptyPointSettings.fill || fill : fill,\n      border: {\n        color: series.type === 'BoxAndWhisker' ? !isNullOrUndefined(borderColor) && borderColor !== 'transparent' ? borderColor : getSaturationColor(fill, -0.6) : border.color,\n        width: border.width\n      },\n      height: marker.height,\n      width: marker.width,\n      shape: marker.shape\n    };\n    argsData.border = series.setBorderColor(point, {\n      width: argsData.border.width,\n      color: argsData.border.color\n    });\n\n    if (!series.isRectSeries || series.type === 'BoxAndWhisker') {\n      this.chart.trigger(pointRender, argsData);\n      point.color = argsData.fill;\n    }\n\n    point.color = argsData.fill;\n\n    if (!argsData.cancel) {\n      var y = void 0;\n\n      if (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.drawType === 'RangeColumn' || series.type === 'SplineRangeArea') {\n        y = index ? point.low : point.high;\n      } else if (isBoxPlot) {\n        y = point.outliers[index];\n      } else {\n        y = point.y;\n      }\n\n      var markerFill = argsData.point.marker.fill || argsData.fill;\n      var markerBorder = void 0;\n\n      if (!isNullOrUndefined(argsData.point.marker.border)) {\n        markerBorder = {\n          color: argsData.point.marker.border.color || argsData.border.color,\n          width: argsData.point.marker.border.width || argsData.border.width\n        };\n      } else {\n        markerBorder = {\n          color: argsData.border.color,\n          width: argsData.border.width\n        };\n      }\n\n      var markerWidth = argsData.point.marker.width || argsData.width;\n      var markerHeight = argsData.point.marker.height || argsData.height;\n      var markerOpacity = argsData.point.marker.opacity || marker.opacity;\n      var markerShape = argsData.point.marker.shape || argsData.shape;\n      var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;\n      shapeOption = new PathOption(symbolId, markerFill, markerBorder.width, markerBorder.color, markerOpacity, null);\n\n      if (parentElement !== undefined && parentElement !== null || this.chart.enableCanvas) {\n        if (redraw && getElement(shapeOption.id)) {\n          markerElement = getElement(shapeOption.id);\n          circlePath = markerShape === 'Circle' ? 'c' : '';\n          previousLocation = {\n            x: +markerElement.getAttribute(circlePath + 'x'),\n            y: +markerElement.getAttribute(circlePath + 'y')\n          };\n          previousPath = markerElement.getAttribute('d');\n        }\n\n        markerElement = drawSymbol(location, markerShape, new Size(markerWidth, markerHeight), imageURL, shapeOption, point.x.toString() + ':' + y.toString(), this.chart.renderer, series.clipRect);\n        appendChildElement(this.chart.enableCanvas, parentElement, markerElement, redraw, true, circlePath + 'x', circlePath + 'y', previousLocation, previousPath, false, false, null, series.chart.duration);\n      }\n\n      point.marker = {\n        border: markerBorder,\n        fill: markerFill,\n        height: markerHeight,\n        visible: true,\n        shape: markerShape,\n        width: markerWidth,\n        imageUrl: imageURL\n      };\n    } else {\n      location = null;\n      point.marker = {\n        visible: false\n      };\n    }\n  };\n\n  Marker.prototype.createElement = function (series, redraw) {\n    var markerClipRect;\n    var marker = series.marker; // 8 for extend border value 5 for extend size value\n\n    var explodeValue = marker.border.width + 8 + 5;\n    var render = series.chart.svgRenderer;\n    var index = series.index === undefined ? series.category : series.index;\n    var options;\n    var transform = series.chart.chartAreaType === 'Cartesian' ? 'translate(' + series.clipRect.x + ',' + series.clipRect.y + ')' : '';\n\n    if (marker.visible) {\n      var markerHeight = (marker.height + explodeValue) / 2;\n      var markerWidth = (marker.width + explodeValue) / 2;\n\n      if (series.chart.chartAreaType === 'Cartesian') {\n        options = new RectOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', {\n          width: 1,\n          color: 'Gray'\n        }, 1, {\n          x: -markerWidth,\n          y: -markerHeight,\n          width: series.clipRect.width + markerWidth * 2,\n          height: series.clipRect.height + markerHeight * 2\n        });\n        markerClipRect = appendClipElement(redraw, options, render);\n      } else {\n        options = new CircleOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', {\n          width: 1,\n          color: 'Gray'\n        }, 1, series.clipRect.width / 2 + series.clipRect.x, series.clipRect.height / 2 + series.clipRect.y, series.chart.radius + Math.max(markerHeight, markerWidth));\n        markerClipRect = appendClipElement(redraw, options, render, 'drawCircularClipPath');\n      }\n\n      options = {\n        'id': this.elementId + 'SymbolGroup' + index,\n        'transform': transform,\n        'clip-path': 'url(#' + this.elementId + '_ChartMarkerClipRect_' + index + ')'\n      };\n      series.symbolElement = render.createGroup(options);\n      series.symbolElement.appendChild(markerClipRect);\n\n      if (this.chart.enableCanvas) {\n        var element = document.getElementById(this.chart.element.id + '_tooltip_svg');\n        element.appendChild(series.symbolElement);\n      }\n    }\n  };\n\n  Marker.prototype.getRangeLowPoint = function (region, series) {\n    var x = region.x;\n    var y = region.y;\n\n    if (series.chart.requireInvertedAxis) {\n      y += region.height / 2;\n      x += series.yAxis.isAxisInverse ? region.width : 0;\n    } else {\n      y += series.yAxis.isAxisInverse ? 0 : region.height;\n      x += region.width / 2;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n  /**\r\n   * Animates the marker.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  Marker.prototype.doMarkerAnimation = function (series) {\n    if (!(series.type === 'Scatter' || series.type === 'Bubble' || series.type === 'Candle' || series.type === 'Hilo' || series.type === 'HiloOpenClose' || series.chart.chartAreaType === 'PolarRadar' && series.drawType === 'Scatter')) {\n      var markerElements = series.symbolElement.childNodes;\n      var delay = series.animation.delay + series.animation.duration;\n      var duration = series.chart.animated ? series.chart.duration : 200;\n      var j = 1;\n      var incFactor = series.type === 'RangeArea' || series.type === 'RangeColumn' || series.type === 'SplineRangeArea' ? 2 : 1;\n\n      for (var i = 0; i < series.points.length; i++) {\n        if (series.points[i].symbolLocations) {\n          if (!series.points[i].symbolLocations.length || !markerElements[j]) {\n            continue;\n          }\n\n          markerAnimate(markerElements[j], delay, duration, series, i, series.points[i].symbolLocations[0], false);\n\n          if (incFactor === 2) {\n            var lowPoint = this.getRangeLowPoint(series.points[i].regions[0], series);\n            markerAnimate(markerElements[j + 1], delay, duration, series, i, lowPoint, false);\n          }\n\n          j += incFactor;\n        }\n      }\n    }\n  };\n\n  return Marker;\n}(MarkerExplode);\n\nexport { Marker };","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/chart/series/marker.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","RectOption","appendChildElement","getElement","appendClipElement","findlElement","drawSymbol","markerAnimate","CircleOption","PathOption","Size","isNullOrUndefined","pointRender","MarkerExplode","getSaturationColor","Marker","_super","chart","_this","call","addEventListener","render","series","redraw","createElement","_loop_1","point","visible","symbolLocations","length","map","location","index","marker","shape","renderMarker","_i","_a","points","seriesIndex","undefined","category","border","color","width","borderColor","previousLocation","previousPath","circlePath","shapeOption","x","offset","y","isBoxPlot","type","fill","interior","markerElement","parentElement","seriesElement","childNodes","symbolElement","setPointColor","symbolId","elementId","argsData","cancel","name","isEmpty","emptyPointSettings","height","setBorderColor","isRectSeries","trigger","drawType","low","high","outliers","markerFill","markerBorder","markerWidth","markerHeight","markerOpacity","opacity","markerShape","imageURL","imageUrl","enableCanvas","id","getAttribute","toString","renderer","clipRect","duration","markerClipRect","explodeValue","svgRenderer","options","transform","chartAreaType","radius","Math","max","createGroup","appendChild","element","document","getElementById","getRangeLowPoint","region","requireInvertedAxis","yAxis","isAxisInverse","doMarkerAnimation","markerElements","delay","animation","animated","j","incFactor","i","lowPoint","regions"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n/* eslint-disable @typescript-eslint/no-inferrable-types */\r\n/* eslint-disable valid-jsdoc */\r\n/* eslint-disable jsdoc/require-param */\r\n/* eslint-disable @typescript-eslint/ban-types */\r\nimport { RectOption, appendChildElement, getElement, appendClipElement } from '../../common/utils/helper';\r\nimport { findlElement, drawSymbol, markerAnimate, CircleOption } from '../../common/utils/helper';\r\nimport { PathOption, Size } from '@syncfusion/ej2-svg-base';\r\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\r\nimport { pointRender } from '../../common/model/constants';\r\nimport { MarkerExplode } from './marker-explode';\r\nimport { getSaturationColor } from '../../common/utils/helper';\r\n/**\r\n * Marker module used to render the marker for line type series.\r\n */\r\nvar Marker = /** @class */ (function (_super) {\r\n    __extends(Marker, _super);\r\n    /**\r\n     * Constructor for the marker module.\r\n     *\r\n     * @private\r\n     */\r\n    function Marker(chart) {\r\n        var _this = _super.call(this, chart) || this;\r\n        _this.addEventListener();\r\n        return _this;\r\n    }\r\n    /**\r\n     * Render the marker for series.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    Marker.prototype.render = function (series) {\r\n        var _this = this;\r\n        var redraw = series.chart.redraw;\r\n        this.createElement(series, redraw);\r\n        var _loop_1 = function (point) {\r\n            if (point.visible && point.symbolLocations && point.symbolLocations.length) {\r\n                point.symbolLocations.map(function (location, index) {\r\n                    if (series.marker.shape !== 'None') {\r\n                        _this.renderMarker(series, point, location, index, redraw);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        for (var _i = 0, _a = series.points; _i < _a.length; _i++) {\r\n            var point = _a[_i];\r\n            _loop_1(point);\r\n        }\r\n    };\r\n    Marker.prototype.renderMarker = function (series, point, location, index, redraw) {\r\n        var seriesIndex = series.index === undefined ? series.category : series.index;\r\n        var marker = series.marker;\r\n        var border = {\r\n            color: marker.border.color,\r\n            width: marker.border.width\r\n        };\r\n        var borderColor = marker.border.color;\r\n        var previousLocation;\r\n        var previousPath;\r\n        var circlePath;\r\n        var shapeOption;\r\n        location.x = location.x + marker.offset.x;\r\n        location.y = location.y - marker.offset.y;\r\n        var isBoxPlot = series.type === 'BoxAndWhisker';\r\n        var fill = marker.fill || (isBoxPlot ? point.interior || series.interior : '#ffffff');\r\n        var markerElement;\r\n        var parentElement = isBoxPlot ?\r\n            findlElement(series.seriesElement.childNodes, 'Series_' + series.index + '_Point_' + point.index)\r\n            : series.symbolElement;\r\n        border.color = borderColor || series.setPointColor(point, series.interior);\r\n        var symbolId = this.elementId + '_Series_' + seriesIndex + '_Point_' + point.index + '_Symbol' +\r\n            (index ? index : '');\r\n        var argsData = {\r\n            cancel: false, name: pointRender, series: series, point: point,\r\n            fill: point.isEmpty ? (series.emptyPointSettings.fill || fill) : fill,\r\n            border: {\r\n                color: series.type === 'BoxAndWhisker' ?\r\n                    (!isNullOrUndefined(borderColor) && borderColor !== 'transparent') ? borderColor :\r\n                        getSaturationColor(fill, -0.6)\r\n                    : border.color,\r\n                width: border.width\r\n            },\r\n            height: marker.height, width: marker.width, shape: marker.shape\r\n        };\r\n        argsData.border = series.setBorderColor(point, { width: argsData.border.width, color: argsData.border.color });\r\n        if (!series.isRectSeries || series.type === 'BoxAndWhisker') {\r\n            this.chart.trigger(pointRender, argsData);\r\n            point.color = argsData.fill;\r\n        }\r\n        point.color = argsData.fill;\r\n        if (!argsData.cancel) {\r\n            var y = void 0;\r\n            if (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.drawType === 'RangeColumn'\r\n                || series.type === 'SplineRangeArea') {\r\n                y = index ? point.low : point.high;\r\n            }\r\n            else if (isBoxPlot) {\r\n                y = point.outliers[index];\r\n            }\r\n            else {\r\n                y = point.y;\r\n            }\r\n            var markerFill = argsData.point.marker.fill || argsData.fill;\r\n            var markerBorder = void 0;\r\n            if (!isNullOrUndefined(argsData.point.marker.border)) {\r\n                markerBorder = {\r\n                    color: argsData.point.marker.border.color || argsData.border.color,\r\n                    width: argsData.point.marker.border.width || argsData.border.width\r\n                };\r\n            }\r\n            else {\r\n                markerBorder = { color: argsData.border.color, width: argsData.border.width };\r\n            }\r\n            var markerWidth = argsData.point.marker.width || argsData.width;\r\n            var markerHeight = argsData.point.marker.height || argsData.height;\r\n            var markerOpacity = argsData.point.marker.opacity || marker.opacity;\r\n            var markerShape = argsData.point.marker.shape || argsData.shape;\r\n            var imageURL = argsData.point.marker.imageUrl || marker.imageUrl;\r\n            shapeOption = new PathOption(symbolId, markerFill, markerBorder.width, markerBorder.color, markerOpacity, null);\r\n            if ((parentElement !== undefined && parentElement !== null) || this.chart.enableCanvas) {\r\n                if (redraw && getElement(shapeOption.id)) {\r\n                    markerElement = getElement(shapeOption.id);\r\n                    circlePath = markerShape === 'Circle' ? 'c' : '';\r\n                    previousLocation = {\r\n                        x: +markerElement.getAttribute(circlePath + 'x'), y: +markerElement.getAttribute(circlePath + 'y')\r\n                    };\r\n                    previousPath = markerElement.getAttribute('d');\r\n                }\r\n                markerElement = drawSymbol(location, markerShape, new Size(markerWidth, markerHeight), imageURL, shapeOption, point.x.toString() + ':' + y.toString(), this.chart.renderer, series.clipRect);\r\n                appendChildElement(this.chart.enableCanvas, parentElement, markerElement, redraw, true, circlePath + 'x', circlePath + 'y', previousLocation, previousPath, false, false, null, series.chart.duration);\r\n            }\r\n            point.marker = {\r\n                border: markerBorder, fill: markerFill, height: markerHeight,\r\n                visible: true, shape: markerShape, width: markerWidth, imageUrl: imageURL\r\n            };\r\n        }\r\n        else {\r\n            location = null;\r\n            point.marker = {\r\n                visible: false\r\n            };\r\n        }\r\n    };\r\n    Marker.prototype.createElement = function (series, redraw) {\r\n        var markerClipRect;\r\n        var marker = series.marker;\r\n        // 8 for extend border value 5 for extend size value\r\n        var explodeValue = marker.border.width + 8 + 5;\r\n        var render = series.chart.svgRenderer;\r\n        var index = series.index === undefined ? series.category : series.index;\r\n        var options;\r\n        var transform = series.chart.chartAreaType === 'Cartesian' ? 'translate(' + series.clipRect.x + ',' + (series.clipRect.y) + ')' : '';\r\n        if (marker.visible) {\r\n            var markerHeight = (marker.height + explodeValue) / 2;\r\n            var markerWidth = (marker.width + explodeValue) / 2;\r\n            if (series.chart.chartAreaType === 'Cartesian') {\r\n                options = new RectOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, {\r\n                    x: -markerWidth, y: -markerHeight,\r\n                    width: series.clipRect.width + markerWidth * 2,\r\n                    height: series.clipRect.height + markerHeight * 2\r\n                });\r\n                markerClipRect = appendClipElement(redraw, options, render);\r\n            }\r\n            else {\r\n                options = new CircleOption(this.elementId + '_ChartMarkerClipRect_' + index, 'transparent', { width: 1, color: 'Gray' }, 1, series.clipRect.width / 2 + series.clipRect.x, series.clipRect.height / 2 + series.clipRect.y, series.chart.radius + Math.max(markerHeight, markerWidth));\r\n                markerClipRect = appendClipElement(redraw, options, render, 'drawCircularClipPath');\r\n            }\r\n            options = {\r\n                'id': this.elementId + 'SymbolGroup' + index,\r\n                'transform': transform,\r\n                'clip-path': 'url(#' + this.elementId + '_ChartMarkerClipRect_' + index + ')'\r\n            };\r\n            series.symbolElement = render.createGroup(options);\r\n            series.symbolElement.appendChild(markerClipRect);\r\n            if (this.chart.enableCanvas) {\r\n                var element = document.getElementById(this.chart.element.id + '_tooltip_svg');\r\n                element.appendChild(series.symbolElement);\r\n            }\r\n        }\r\n    };\r\n    Marker.prototype.getRangeLowPoint = function (region, series) {\r\n        var x = region.x;\r\n        var y = region.y;\r\n        if (series.chart.requireInvertedAxis) {\r\n            y += region.height / 2;\r\n            x += series.yAxis.isAxisInverse ? region.width : 0;\r\n        }\r\n        else {\r\n            y += series.yAxis.isAxisInverse ? 0 : region.height;\r\n            x += region.width / 2;\r\n        }\r\n        return { x: x, y: y };\r\n    };\r\n    /**\r\n     * Animates the marker.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    Marker.prototype.doMarkerAnimation = function (series) {\r\n        if (!(series.type === 'Scatter' || series.type === 'Bubble' || series.type === 'Candle' || series.type === 'Hilo' ||\r\n            series.type === 'HiloOpenClose' || (series.chart.chartAreaType === 'PolarRadar' && (series.drawType === 'Scatter')))) {\r\n            var markerElements = series.symbolElement.childNodes;\r\n            var delay = series.animation.delay + series.animation.duration;\r\n            var duration = series.chart.animated ? series.chart.duration : 200;\r\n            var j = 1;\r\n            var incFactor = (series.type === 'RangeArea' || series.type === 'RangeColumn' || series.type === 'SplineRangeArea') ? 2 : 1;\r\n            for (var i = 0; i < series.points.length; i++) {\r\n                if (series.points[i].symbolLocations) {\r\n                    if (!series.points[i].symbolLocations.length || !markerElements[j]) {\r\n                        continue;\r\n                    }\r\n                    markerAnimate(markerElements[j], delay, duration, series, i, series.points[i].symbolLocations[0], false);\r\n                    if (incFactor === 2) {\r\n                        var lowPoint = this.getRangeLowPoint(series.points[i].regions[0], series);\r\n                        markerAnimate(markerElements[j + 1], delay, duration, series, i, lowPoint, false);\r\n                    }\r\n                    j += incFactor;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    return Marker;\r\n}(MarkerExplode));\r\nexport { Marker };\r\n"]},"metadata":{},"sourceType":"module"}