{"ast":null,"code":"/**\r\n * Computes the elimination tree of Matrix A (using triu(A)) or the\r\n * elimination tree of A'A without forming A'A.\r\n *\r\n * @param {Matrix}  a               The A Matrix\r\n * @param {boolean} ata             A value of true the function computes the etree of A'A\r\n *\r\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n */\nexport function csEtree(a, ata) {\n  // check inputs\n  if (!a) {\n    return null;\n  } // a arrays\n\n\n  var aindex = a._index;\n  var aptr = a._ptr;\n  var asize = a._size; // rows & columns\n\n  var m = asize[0];\n  var n = asize[1]; // allocate result\n\n  var parent = []; // (n)\n  // allocate workspace\n\n  var w = []; // (n + (ata ? m : 0))\n\n  var ancestor = 0; // first n entries in w\n\n  var prev = n; // last m entries (ata = true)\n\n  var i, inext; // check we are calculating A'A\n\n  if (ata) {\n    // initialize workspace\n    for (i = 0; i < m; i++) {\n      w[prev + i] = -1;\n    }\n  } // loop columns\n\n\n  for (var k = 0; k < n; k++) {\n    // node k has no parent yet\n    parent[k] = -1; // nor does k have an ancestor\n\n    w[ancestor + k] = -1; // values in column k\n\n    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n      // row\n      var r = aindex[p]; // node\n\n      i = ata ? w[prev + r] : r; // traverse from i to k\n\n      for (; i !== -1 && i < k; i = inext) {\n        // inext = ancestor of i\n        inext = w[ancestor + i]; // path compression\n\n        w[ancestor + i] = k; // check no anc., parent is k\n\n        if (inext === -1) {\n          parent[i] = k;\n        }\n      }\n\n      if (ata) {\n        w[prev + r] = k;\n      }\n    }\n  }\n\n  return parent;\n}","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js"],"names":["csEtree","a","ata","aindex","_index","aptr","_ptr","asize","_size","m","n","parent","w","ancestor","prev","i","inext","k","p0","p1","p","r"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,OAAT,CAAiBC,CAAjB,EAAoBC,GAApB,EAAyB;AAC9B;AACA,MAAI,CAACD,CAAL,EAAQ;AACN,WAAO,IAAP;AACD,GAJ6B,CAK9B;;;AACA,MAAIE,MAAM,GAAGF,CAAC,CAACG,MAAf;AACA,MAAIC,IAAI,GAAGJ,CAAC,CAACK,IAAb;AACA,MAAIC,KAAK,GAAGN,CAAC,CAACO,KAAd,CAR8B,CAS9B;;AACA,MAAIC,CAAC,GAAGF,KAAK,CAAC,CAAD,CAAb;AACA,MAAIG,CAAC,GAAGH,KAAK,CAAC,CAAD,CAAb,CAX8B,CAa9B;;AACA,MAAII,MAAM,GAAG,EAAb,CAd8B,CAcb;AAEjB;;AACA,MAAIC,CAAC,GAAG,EAAR,CAjB8B,CAiBlB;;AACZ,MAAIC,QAAQ,GAAG,CAAf,CAlB8B,CAkBZ;;AAClB,MAAIC,IAAI,GAAGJ,CAAX,CAnB8B,CAmBhB;;AAEd,MAAIK,CAAJ,EAAOC,KAAP,CArB8B,CAuB9B;;AACA,MAAId,GAAJ,EAAS;AACP;AACA,SAAKa,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGN,CAAhB,EAAmBM,CAAC,EAApB,EAAwB;AACtBH,MAAAA,CAAC,CAACE,IAAI,GAAGC,CAAR,CAAD,GAAc,CAAC,CAAf;AACD;AACF,GA7B6B,CA8B9B;;;AACA,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,CAApB,EAAuBO,CAAC,EAAxB,EAA4B;AAC1B;AACAN,IAAAA,MAAM,CAACM,CAAD,CAAN,GAAY,CAAC,CAAb,CAF0B,CAG1B;;AACAL,IAAAA,CAAC,CAACC,QAAQ,GAAGI,CAAZ,CAAD,GAAkB,CAAC,CAAnB,CAJ0B,CAK1B;;AACA,SAAK,IAAIC,EAAE,GAAGb,IAAI,CAACY,CAAD,CAAb,EAAkBE,EAAE,GAAGd,IAAI,CAACY,CAAC,GAAG,CAAL,CAA3B,EAAoCG,CAAC,GAAGF,EAA7C,EAAiDE,CAAC,GAAGD,EAArD,EAAyDC,CAAC,EAA1D,EAA8D;AAC5D;AACA,UAAIC,CAAC,GAAGlB,MAAM,CAACiB,CAAD,CAAd,CAF4D,CAG5D;;AACAL,MAAAA,CAAC,GAAGb,GAAG,GAAGU,CAAC,CAACE,IAAI,GAAGO,CAAR,CAAJ,GAAiBA,CAAxB,CAJ4D,CAK5D;;AACA,aAAON,CAAC,KAAK,CAAC,CAAP,IAAYA,CAAC,GAAGE,CAAvB,EAA0BF,CAAC,GAAGC,KAA9B,EAAqC;AACnC;AACAA,QAAAA,KAAK,GAAGJ,CAAC,CAACC,QAAQ,GAAGE,CAAZ,CAAT,CAFmC,CAGnC;;AACAH,QAAAA,CAAC,CAACC,QAAQ,GAAGE,CAAZ,CAAD,GAAkBE,CAAlB,CAJmC,CAKnC;;AACA,YAAID,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChBL,UAAAA,MAAM,CAACI,CAAD,CAAN,GAAYE,CAAZ;AACD;AACF;;AACD,UAAIf,GAAJ,EAAS;AACPU,QAAAA,CAAC,CAACE,IAAI,GAAGO,CAAR,CAAD,GAAcJ,CAAd;AACD;AACF;AACF;;AACD,SAAON,MAAP;AACD","sourcesContent":["/**\r\n * Computes the elimination tree of Matrix A (using triu(A)) or the\r\n * elimination tree of A'A without forming A'A.\r\n *\r\n * @param {Matrix}  a               The A Matrix\r\n * @param {boolean} ata             A value of true the function computes the etree of A'A\r\n *\r\n * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n */\r\nexport function csEtree(a, ata) {\r\n  // check inputs\r\n  if (!a) {\r\n    return null;\r\n  }\r\n  // a arrays\r\n  var aindex = a._index;\r\n  var aptr = a._ptr;\r\n  var asize = a._size;\r\n  // rows & columns\r\n  var m = asize[0];\r\n  var n = asize[1];\r\n\r\n  // allocate result\r\n  var parent = []; // (n)\r\n\r\n  // allocate workspace\r\n  var w = []; // (n + (ata ? m : 0))\r\n  var ancestor = 0; // first n entries in w\r\n  var prev = n; // last m entries (ata = true)\r\n\r\n  var i, inext;\r\n\r\n  // check we are calculating A'A\r\n  if (ata) {\r\n    // initialize workspace\r\n    for (i = 0; i < m; i++) {\r\n      w[prev + i] = -1;\r\n    }\r\n  }\r\n  // loop columns\r\n  for (var k = 0; k < n; k++) {\r\n    // node k has no parent yet\r\n    parent[k] = -1;\r\n    // nor does k have an ancestor\r\n    w[ancestor + k] = -1;\r\n    // values in column k\r\n    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\r\n      // row\r\n      var r = aindex[p];\r\n      // node\r\n      i = ata ? w[prev + r] : r;\r\n      // traverse from i to k\r\n      for (; i !== -1 && i < k; i = inext) {\r\n        // inext = ancestor of i\r\n        inext = w[ancestor + i];\r\n        // path compression\r\n        w[ancestor + i] = k;\r\n        // check no anc., parent is k\r\n        if (inext === -1) {\r\n          parent[i] = k;\r\n        }\r\n      }\r\n      if (ata) {\r\n        w[prev + r] = k;\r\n      }\r\n    }\r\n  }\r\n  return parent;\r\n}"]},"metadata":{},"sourceType":"module"}