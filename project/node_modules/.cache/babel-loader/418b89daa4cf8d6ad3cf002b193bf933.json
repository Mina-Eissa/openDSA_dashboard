{"ast":null,"code":"import { isMatrix } from '../../utils/is.js';\nimport { arraySize } from '../../utils/array.js';\nimport { isInteger } from '../../utils/number.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'diag';\nvar dependencies = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];\nexport var createDiag = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    DenseMatrix,\n    SparseMatrix\n  } = _ref;\n  /**\r\n   * Create a diagonal matrix or retrieve the diagonal of a matrix\r\n   *\r\n   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.\r\n   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.\r\n   * When k is positive, the values are placed on the super diagonal.\r\n   * When k is negative, the values are placed on the sub diagonal.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.diag(X)\r\n   *     math.diag(X, format)\r\n   *     math.diag(X, k)\r\n   *     math.diag(X, k, format)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     // create a diagonal matrix\r\n   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\r\n   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\r\n   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]\r\n   *\r\n   *    // retrieve the diagonal from a matrix\r\n   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\r\n   *    math.diag(a)   // returns [1, 5, 9]\r\n   *\r\n   * See also:\r\n   *\r\n   *     ones, zeros, identity\r\n   *\r\n   * @param {Matrix | Array} x          A two dimensional matrix or a vector\r\n   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled\r\n   *                                    in or retrieved.\r\n   * @param {string} [format='dense']   The matrix storage format.\r\n   *\r\n   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.\r\n   */\n\n  return typed(name, {\n    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments\n    Array: function Array(x) {\n      return _diag(x, 0, arraySize(x), null);\n    },\n    'Array, number': function ArrayNumber(x, k) {\n      return _diag(x, k, arraySize(x), null);\n    },\n    'Array, BigNumber': function ArrayBigNumber(x, k) {\n      return _diag(x, k.toNumber(), arraySize(x), null);\n    },\n    'Array, string': function ArrayString(x, format) {\n      return _diag(x, 0, arraySize(x), format);\n    },\n    'Array, number, string': function ArrayNumberString(x, k, format) {\n      return _diag(x, k, arraySize(x), format);\n    },\n    'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), arraySize(x), format);\n    },\n    Matrix: function Matrix(x) {\n      return _diag(x, 0, x.size(), x.storage());\n    },\n    'Matrix, number': function MatrixNumber(x, k) {\n      return _diag(x, k, x.size(), x.storage());\n    },\n    'Matrix, BigNumber': function MatrixBigNumber(x, k) {\n      return _diag(x, k.toNumber(), x.size(), x.storage());\n    },\n    'Matrix, string': function MatrixString(x, format) {\n      return _diag(x, 0, x.size(), format);\n    },\n    'Matrix, number, string': function MatrixNumberString(x, k, format) {\n      return _diag(x, k, x.size(), format);\n    },\n    'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {\n      return _diag(x, k.toNumber(), x.size(), format);\n    }\n  });\n  /**\r\n   * Creeate diagonal matrix from a vector or vice versa\r\n   * @param {Array | Matrix} x\r\n   * @param {number} k\r\n   * @param {string} format Storage format for matrix. If null,\r\n   *                          an Array is returned\r\n   * @returns {Array | Matrix}\r\n   * @private\r\n   */\n\n  function _diag(x, k, size, format) {\n    if (!isInteger(k)) {\n      throw new TypeError('Second parameter in function diag must be an integer');\n    }\n\n    var kSuper = k > 0 ? k : 0;\n    var kSub = k < 0 ? -k : 0; // check dimensions\n\n    switch (size.length) {\n      case 1:\n        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);\n\n      case 2:\n        return _getDiagonal(x, k, format, size, kSub, kSuper);\n    }\n\n    throw new RangeError('Matrix for function diag must be 2 dimensional');\n  }\n\n  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {\n    // matrix size\n    var ms = [l + kSub, l + kSuper];\n\n    if (format && format !== 'sparse' && format !== 'dense') {\n      throw new TypeError(\"Unknown matrix type \".concat(format, \"\\\"\"));\n    } // create diagonal matrix\n\n\n    var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k); // check we need to return a matrix\n\n    return format !== null ? m : m.valueOf();\n  }\n\n  function _getDiagonal(x, k, format, s, kSub, kSuper) {\n    // check x is a Matrix\n    if (isMatrix(x)) {\n      // get diagonal matrix\n      var dm = x.diagonal(k); // check we need to return a matrix\n\n      if (format !== null) {\n        // check we need to change matrix format\n        if (format !== dm.storage()) {\n          return matrix(dm, format);\n        }\n\n        return dm;\n      }\n\n      return dm.valueOf();\n    } // vector size\n\n\n    var n = Math.min(s[0] - kSub, s[1] - kSuper); // diagonal values\n\n    var vector = []; // loop diagonal\n\n    for (var i = 0; i < n; i++) {\n      vector[i] = x[i + kSub][i + kSuper];\n    } // check we need to return a matrix\n\n\n    return format !== null ? matrix(vector) : vector;\n  }\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/matrix/diag.js"],"names":["isMatrix","arraySize","isInteger","factory","name","dependencies","createDiag","_ref","typed","matrix","DenseMatrix","SparseMatrix","Array","x","_diag","ArrayNumber","k","ArrayBigNumber","toNumber","ArrayString","format","ArrayNumberString","ArrayBigNumberString","Matrix","size","storage","MatrixNumber","MatrixBigNumber","MatrixString","MatrixNumberString","MatrixBigNumberString","TypeError","kSuper","kSub","length","_createDiagonalMatrix","_getDiagonal","RangeError","l","ms","concat","m","diagonal","valueOf","s","dm","n","Math","min","vector","i"],"mappings":"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","sourcesContent":["import { isMatrix } from '../../utils/is.js';\r\nimport { arraySize } from '../../utils/array.js';\r\nimport { isInteger } from '../../utils/number.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'diag';\r\nvar dependencies = ['typed', 'matrix', 'DenseMatrix', 'SparseMatrix'];\r\nexport var createDiag = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    DenseMatrix,\r\n    SparseMatrix\r\n  } = _ref;\r\n  /**\r\n   * Create a diagonal matrix or retrieve the diagonal of a matrix\r\n   *\r\n   * When `x` is a vector, a matrix with vector `x` on the diagonal will be returned.\r\n   * When `x` is a two dimensional matrix, the matrixes `k`th diagonal will be returned as vector.\r\n   * When k is positive, the values are placed on the super diagonal.\r\n   * When k is negative, the values are placed on the sub diagonal.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.diag(X)\r\n   *     math.diag(X, format)\r\n   *     math.diag(X, k)\r\n   *     math.diag(X, k, format)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     // create a diagonal matrix\r\n   *     math.diag([1, 2, 3])      // returns [[1, 0, 0], [0, 2, 0], [0, 0, 3]]\r\n   *     math.diag([1, 2, 3], 1)   // returns [[0, 1, 0, 0], [0, 0, 2, 0], [0, 0, 0, 3]]\r\n   *     math.diag([1, 2, 3], -1)  // returns [[0, 0, 0], [1, 0, 0], [0, 2, 0], [0, 0, 3]]\r\n   *\r\n   *    // retrieve the diagonal from a matrix\r\n   *    const a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\r\n   *    math.diag(a)   // returns [1, 5, 9]\r\n   *\r\n   * See also:\r\n   *\r\n   *     ones, zeros, identity\r\n   *\r\n   * @param {Matrix | Array} x          A two dimensional matrix or a vector\r\n   * @param {number | BigNumber} [k=0]  The diagonal where the vector will be filled\r\n   *                                    in or retrieved.\r\n   * @param {string} [format='dense']   The matrix storage format.\r\n   *\r\n   * @returns {Matrix | Array} Diagonal matrix from input vector, or diagonal from input matrix.\r\n   */\r\n  return typed(name, {\r\n    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments\r\n\r\n    Array: function Array(x) {\r\n      return _diag(x, 0, arraySize(x), null);\r\n    },\r\n    'Array, number': function ArrayNumber(x, k) {\r\n      return _diag(x, k, arraySize(x), null);\r\n    },\r\n    'Array, BigNumber': function ArrayBigNumber(x, k) {\r\n      return _diag(x, k.toNumber(), arraySize(x), null);\r\n    },\r\n    'Array, string': function ArrayString(x, format) {\r\n      return _diag(x, 0, arraySize(x), format);\r\n    },\r\n    'Array, number, string': function ArrayNumberString(x, k, format) {\r\n      return _diag(x, k, arraySize(x), format);\r\n    },\r\n    'Array, BigNumber, string': function ArrayBigNumberString(x, k, format) {\r\n      return _diag(x, k.toNumber(), arraySize(x), format);\r\n    },\r\n    Matrix: function Matrix(x) {\r\n      return _diag(x, 0, x.size(), x.storage());\r\n    },\r\n    'Matrix, number': function MatrixNumber(x, k) {\r\n      return _diag(x, k, x.size(), x.storage());\r\n    },\r\n    'Matrix, BigNumber': function MatrixBigNumber(x, k) {\r\n      return _diag(x, k.toNumber(), x.size(), x.storage());\r\n    },\r\n    'Matrix, string': function MatrixString(x, format) {\r\n      return _diag(x, 0, x.size(), format);\r\n    },\r\n    'Matrix, number, string': function MatrixNumberString(x, k, format) {\r\n      return _diag(x, k, x.size(), format);\r\n    },\r\n    'Matrix, BigNumber, string': function MatrixBigNumberString(x, k, format) {\r\n      return _diag(x, k.toNumber(), x.size(), format);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Creeate diagonal matrix from a vector or vice versa\r\n   * @param {Array | Matrix} x\r\n   * @param {number} k\r\n   * @param {string} format Storage format for matrix. If null,\r\n   *                          an Array is returned\r\n   * @returns {Array | Matrix}\r\n   * @private\r\n   */\r\n  function _diag(x, k, size, format) {\r\n    if (!isInteger(k)) {\r\n      throw new TypeError('Second parameter in function diag must be an integer');\r\n    }\r\n    var kSuper = k > 0 ? k : 0;\r\n    var kSub = k < 0 ? -k : 0;\r\n\r\n    // check dimensions\r\n    switch (size.length) {\r\n      case 1:\r\n        return _createDiagonalMatrix(x, k, format, size[0], kSub, kSuper);\r\n      case 2:\r\n        return _getDiagonal(x, k, format, size, kSub, kSuper);\r\n    }\r\n    throw new RangeError('Matrix for function diag must be 2 dimensional');\r\n  }\r\n  function _createDiagonalMatrix(x, k, format, l, kSub, kSuper) {\r\n    // matrix size\r\n    var ms = [l + kSub, l + kSuper];\r\n    if (format && format !== 'sparse' && format !== 'dense') {\r\n      throw new TypeError(\"Unknown matrix type \".concat(format, \"\\\"\"));\r\n    }\r\n\r\n    // create diagonal matrix\r\n    var m = format === 'sparse' ? SparseMatrix.diagonal(ms, x, k) : DenseMatrix.diagonal(ms, x, k);\r\n    // check we need to return a matrix\r\n    return format !== null ? m : m.valueOf();\r\n  }\r\n  function _getDiagonal(x, k, format, s, kSub, kSuper) {\r\n    // check x is a Matrix\r\n    if (isMatrix(x)) {\r\n      // get diagonal matrix\r\n      var dm = x.diagonal(k);\r\n      // check we need to return a matrix\r\n      if (format !== null) {\r\n        // check we need to change matrix format\r\n        if (format !== dm.storage()) {\r\n          return matrix(dm, format);\r\n        }\r\n        return dm;\r\n      }\r\n      return dm.valueOf();\r\n    }\r\n    // vector size\r\n    var n = Math.min(s[0] - kSub, s[1] - kSuper);\r\n    // diagonal values\r\n    var vector = [];\r\n    // loop diagonal\r\n    for (var i = 0; i < n; i++) {\r\n      vector[i] = x[i + kSub][i + kSuper];\r\n    }\r\n    // check we need to return a matrix\r\n    return format !== null ? matrix(vector) : vector;\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}