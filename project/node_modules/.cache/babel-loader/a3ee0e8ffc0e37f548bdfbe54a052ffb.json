{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport { factory } from '../utils/factory.js';\nimport { isAccessorNode, isConstantNode, isFunctionNode, isOperatorNode, isSymbolNode, rule2Node } from '../utils/is.js';\nimport { deepMap } from '../utils/collection.js';\nimport { hasOwnProperty } from '../utils/object.js';\nvar name = 'parse';\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\nexport var createParse = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    numeric,\n    config,\n    AccessorNode,\n    ArrayNode,\n    AssignmentNode,\n    BlockNode,\n    ConditionalNode,\n    ConstantNode,\n    FunctionAssignmentNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    RangeNode,\n    RelationalNode,\n    SymbolNode\n  } = _ref;\n  /**\r\n   * Parse an expression. Returns a node tree, which can be evaluated by\r\n   * invoking node.evaluate().\r\n   *\r\n   * Note the evaluating arbitrary expressions may involve security risks,\r\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.parse(expr)\r\n   *     math.parse(expr, options)\r\n   *     math.parse([expr1, expr2, expr3, ...])\r\n   *     math.parse([expr1, expr2, expr3, ...], options)\r\n   *\r\n   * Example:\r\n   *\r\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\r\n   *     node1.compile().evaluate() // 5\r\n   *\r\n   *     let scope = {a:3, b:4}\r\n   *     const node2 = math.parse('a * b') // 12\r\n   *     const code2 = node2.compile()\r\n   *     code2.evaluate(scope) // 12\r\n   *     scope.a = 5\r\n   *     code2.evaluate(scope) // 20\r\n   *\r\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\r\n   *     nodes[2].compile().evaluate() // 12\r\n   *\r\n   * See also:\r\n   *\r\n   *     evaluate, compile\r\n   *\r\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\r\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\r\n   *                                                   - `nodes` a set of custom nodes\r\n   * @return {Node | Node[]} node\r\n   * @throws {Error}\r\n   */\n\n  var parse = typed(name, {\n    string: function string(expression) {\n      return parseStart(expression, {});\n    },\n    'Array | Matrix': function ArrayMatrix(expressions) {\n      return parseMultiple(expressions, {});\n    },\n    'string, Object': function stringObject(expression, options) {\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\n      return parseStart(expression, extraNodes);\n    },\n    'Array | Matrix, Object': parseMultiple\n  });\n\n  function parseMultiple(expressions) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var extraNodes = options.nodes !== undefined ? options.nodes : {}; // parse an array or matrix with expressions\n\n    return deepMap(expressions, function (elem) {\n      if (typeof elem !== 'string') throw new TypeError('String expected');\n      return parseStart(elem, extraNodes);\n    });\n  } // token types enumeration\n\n\n  var TOKENTYPE = {\n    NULL: 0,\n    DELIMITER: 1,\n    NUMBER: 2,\n    SYMBOL: 3,\n    UNKNOWN: 4\n  }; // map with all delimiters\n\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\"': true,\n    '\\'': true,\n    ';': true,\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '=': true,\n    ':': true,\n    '?': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  }; // map with all named delimiters\n\n  var NAMED_DELIMITERS = {\n    mod: true,\n    to: true,\n    in: true,\n    and: true,\n    xor: true,\n    or: true,\n    not: true\n  };\n  var CONSTANTS = {\n    true: true,\n    false: false,\n    null: null,\n    undefined\n  };\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\n\n  function initialState() {\n    return {\n      extraNodes: {},\n      // current extra nodes, must be careful not to mutate\n      expression: '',\n      // current expression\n      comment: '',\n      // last parsed comment\n      index: 0,\n      // current index in expr\n      token: '',\n      // current token\n      tokenType: TOKENTYPE.NULL,\n      // type of the token\n      nestingLevel: 0,\n      // level of nesting inside parameters, used to ignore newline characters\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\n\n    };\n  }\n  /**\r\n   * View upto `length` characters of the expression starting at the current character.\r\n   *\r\n   * @param {Object} state\r\n   * @param {number} [length=1] Number of characters to view\r\n   * @returns {string}\r\n   * @private\r\n   */\n\n\n  function currentString(state, length) {\n    return state.expression.substr(state.index, length);\n  }\n  /**\r\n   * View the current character. Returns '' if end of expression is reached.\r\n   *\r\n   * @param {Object} state\r\n   * @returns {string}\r\n   * @private\r\n   */\n\n\n  function currentCharacter(state) {\n    return currentString(state, 1);\n  }\n  /**\r\n   * Get the next character from the expression.\r\n   * The character is stored into the char c. If the end of the expression is\r\n   * reached, the function puts an empty string in c.\r\n   * @private\r\n   */\n\n\n  function next(state) {\n    state.index++;\n  }\n  /**\r\n   * Preview the previous character from the expression.\r\n   * @return {string} cNext\r\n   * @private\r\n   */\n\n\n  function prevCharacter(state) {\n    return state.expression.charAt(state.index - 1);\n  }\n  /**\r\n   * Preview the next character from the expression.\r\n   * @return {string} cNext\r\n   * @private\r\n   */\n\n\n  function nextCharacter(state) {\n    return state.expression.charAt(state.index + 1);\n  }\n  /**\r\n   * Get next token in the current string expr.\r\n   * The token and token type are available as token and tokenType\r\n   * @private\r\n   */\n\n\n  function getToken(state) {\n    state.tokenType = TOKENTYPE.NULL;\n    state.token = '';\n    state.comment = ''; // skip over ignored characters:\n\n    while (true) {\n      // comments:\n      if (currentCharacter(state) === '#') {\n        while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\n          state.comment += currentCharacter(state);\n          next(state);\n        }\n      } // whitespace: space, tab, and newline when inside parameters\n\n\n      if (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\n        next(state);\n      } else {\n        break;\n      }\n    } // check for end of expression\n\n\n    if (currentCharacter(state) === '') {\n      // token is still empty\n      state.tokenType = TOKENTYPE.DELIMITER;\n      return;\n    } // check for new line character\n\n\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = currentCharacter(state);\n      next(state);\n      return;\n    }\n\n    var c1 = currentCharacter(state);\n    var c2 = currentString(state, 2);\n    var c3 = currentString(state, 3);\n\n    if (c3.length === 3 && DELIMITERS[c3]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c3;\n      next(state);\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 2 characters\n\n\n    if (c2.length === 2 && DELIMITERS[c2]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c2;\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 1 character\n\n\n    if (DELIMITERS[c1]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c1;\n      next(state);\n      return;\n    } // check for a number\n\n\n    if (parse.isDigitDot(c1)) {\n      state.tokenType = TOKENTYPE.NUMBER; // check for binary, octal, or hex\n\n      var _c = currentString(state, 2);\n\n      if (_c === '0b' || _c === '0o' || _c === '0x') {\n        state.token += currentCharacter(state);\n        next(state);\n        state.token += currentCharacter(state);\n        next(state);\n\n        while (parse.isHexDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (currentCharacter(state) === '.') {\n          // this number has a radix point\n          state.token += '.';\n          next(state); // get the digits after the radix\n\n          while (parse.isHexDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        } else if (currentCharacter(state) === 'i') {\n          // this number has a word size suffix\n          state.token += 'i';\n          next(state); // get the word size\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        }\n\n        return;\n      } // get number, can have a single dot\n\n\n      if (currentCharacter(state) === '.') {\n        state.token += currentCharacter(state);\n        next(state);\n\n        if (!parse.isDigit(currentCharacter(state))) {\n          // this is no number, it is just a dot (can be dot notation)\n          state.tokenType = TOKENTYPE.DELIMITER;\n          return;\n        }\n      } else {\n        while (parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n      }\n\n      while (parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      } // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n\n\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\n          state.token += currentCharacter(state);\n          next(state);\n\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\n            state.token += currentCharacter(state);\n            next(state);\n          } // Scientific notation MUST be followed by an exponent\n\n\n          if (!parse.isDigit(currentCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n        } else if (nextCharacter(state) === '.') {\n          next(state);\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n        }\n      }\n\n      return;\n    } // check for variables, functions, named operators\n\n\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n\n      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {\n        state.tokenType = TOKENTYPE.DELIMITER;\n      } else {\n        state.tokenType = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    } // something unknown is found, wrong characters -> a syntax error\n\n\n    state.tokenType = TOKENTYPE.UNKNOWN;\n\n    while (currentCharacter(state) !== '') {\n      state.token += currentCharacter(state);\n      next(state);\n    }\n\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\n  }\n  /**\r\n   * Get next token and skip newline tokens\r\n   */\n\n\n  function getTokenSkipNewline(state) {\n    do {\n      getToken(state);\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\n\n  }\n  /**\r\n   * Open parameters.\r\n   * New line characters will be ignored until closeParams(state) is called\r\n   */\n\n\n  function openParams(state) {\n    state.nestingLevel++;\n  }\n  /**\r\n   * Close parameters.\r\n   * New line characters will no longer be ignored\r\n   */\n\n\n  function closeParams(state) {\n    state.nestingLevel--;\n  }\n  /**\r\n   * Checks whether the current character `c` is a valid alpha character:\r\n   *\r\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\r\n   * - An underscore                        Ascii: _\r\n   * - A dollar sign                        Ascii: $\r\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\r\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\r\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\r\n   *\r\n   * The previous and next characters are needed to determine whether\r\n   * this character is part of a unicode surrogate pair.\r\n   *\r\n   * @param {string} c      Current character in the expression\r\n   * @param {string} cPrev  Previous character\r\n   * @param {string} cNext  Next character\r\n   * @return {boolean}\r\n   */\n\n\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\n  };\n  /**\r\n   * Test whether a character is a valid latin, greek, or letter-like character\r\n   * @param {string} c\r\n   * @return {boolean}\r\n   */\n\n\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n  /**\r\n   * Test whether two given 16 bit characters form a surrogate pair of a\r\n   * unicode math symbol.\r\n   *\r\n   * https://unicode-table.com/en/\r\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\r\n   *\r\n   * Note: In ES6 will be unicode aware:\r\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\r\n   * https://mathiasbynens.be/notes/es6-unicode-regex\r\n   *\r\n   * @param {string} high\r\n   * @param {string} low\r\n   * @return {boolean}\r\n   */\n\n\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n  /**\r\n   * Check whether given character c is a white space character: space, tab, or enter\r\n   * @param {string} c\r\n   * @param {number} nestingLevel\r\n   * @return {boolean}\r\n   */\n\n\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c === ' ' || c === '\\t' || c === '\\n' && nestingLevel > 0;\n  };\n  /**\r\n   * Test whether the character c is a decimal mark (dot).\r\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\r\n   * @param {string} c\r\n   * @param {string} cNext\r\n   * @return {boolean}\r\n   */\n\n\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n  /**\r\n   * checks if the given char c is a digit or dot\r\n   * @param {string} c   a string with one character\r\n   * @return {boolean}\r\n   */\n\n\n  parse.isDigitDot = function isDigitDot(c) {\n    return c >= '0' && c <= '9' || c === '.';\n  };\n  /**\r\n   * checks if the given char c is a digit\r\n   * @param {string} c   a string with one character\r\n   * @return {boolean}\r\n   */\n\n\n  parse.isDigit = function isDigit(c) {\n    return c >= '0' && c <= '9';\n  };\n  /**\r\n   * checks if the given char c is a hex digit\r\n   * @param {string} c   a string with one character\r\n   * @return {boolean}\r\n   */\n\n\n  parse.isHexDigit = function isHexDigit(c) {\n    return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n  };\n  /**\r\n   * Start of the parse levels below, in order of precedence\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseStart(expression, extraNodes) {\n    var state = initialState();\n\n    _extends(state, {\n      expression,\n      extraNodes\n    });\n\n    getToken(state);\n    var node = parseBlock(state); // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and tokenType DELIMITER\n\n    if (state.token !== '') {\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\n        throw createError(state, 'Unexpected operator ' + state.token);\n      } else {\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\n      }\n    }\n\n    return node;\n  }\n  /**\r\n   * Parse a block with expressions. Expressions can be separated by a newline\r\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\r\n   * of the preceding line is returned.\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseBlock(state) {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\n      node = parseAssignment(state);\n\n      if (state.comment) {\n        node.comment = state.comment;\n      }\n    } // TODO: simplify this loop\n\n\n    while (state.token === '\\n' || state.token === ';') {\n      // eslint-disable-line no-unmodified-loop-condition\n      if (blocks.length === 0 && node) {\n        visible = state.token !== ';';\n        blocks.push({\n          node,\n          visible\n        });\n      }\n\n      getToken(state);\n\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\n        node = parseAssignment(state);\n\n        if (state.comment) {\n          node.comment = state.comment;\n        }\n\n        visible = state.token !== ';';\n        blocks.push({\n          node,\n          visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    } else {\n      if (!node) {\n        node = new ConstantNode(undefined);\n\n        if (state.comment) {\n          node.comment = state.comment;\n        }\n      }\n\n      return node;\n    }\n  }\n  /**\r\n   * Assignment of a function or variable,\r\n   * - can be a variable like 'a=2.3'\r\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\r\n   * - defining a function like 'f(x) = x^2'\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseAssignment(state) {\n    var name, args, value, valid;\n    var node = parseConditional(state);\n\n    if (state.token === '=') {\n      if (isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(new SymbolNode(name), value);\n      } else if (isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(node.object, node.index, value);\n      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (isSymbolNode(arg)) {\n            args[index] = arg.name;\n          } else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline(state);\n          value = parseAssignment(state);\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n  /**\r\n   * conditional operation\r\n   *\r\n   *     condition ? truePart : falsePart\r\n   *\r\n   * Note: conditional operator is right-associative\r\n   *\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseConditional(state) {\n    var node = parseLogicalOr(state);\n\n    while (state.token === '?') {\n      // eslint-disable-line no-unmodified-loop-condition\n      // set a conditional level, the range operator will be ignored as long\n      // as conditionalLevel === state.nestingLevel.\n      var prev = state.conditionalLevel;\n      state.conditionalLevel = state.nestingLevel;\n      getTokenSkipNewline(state);\n      var condition = node;\n      var trueExpr = parseAssignment(state);\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\n      state.conditionalLevel = null;\n      getTokenSkipNewline(state);\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr); // restore the previous conditional level\n\n      state.conditionalLevel = prev;\n    }\n\n    return node;\n  }\n  /**\r\n   * logical or, 'x or y'\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseLogicalOr(state) {\n    var node = parseLogicalXor(state);\n\n    while (state.token === 'or') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\n    }\n\n    return node;\n  }\n  /**\r\n   * logical exclusive or, 'x xor y'\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseLogicalXor(state) {\n    var node = parseLogicalAnd(state);\n\n    while (state.token === 'xor') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\r\n   * logical and, 'x and y'\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseLogicalAnd(state) {\n    var node = parseBitwiseOr(state);\n\n    while (state.token === 'and') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\n    }\n\n    return node;\n  }\n  /**\r\n   * bitwise or, 'x | y'\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseBitwiseOr(state) {\n    var node = parseBitwiseXor(state);\n\n    while (state.token === '|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\n    }\n\n    return node;\n  }\n  /**\r\n   * bitwise exclusive or (xor), 'x ^| y'\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseBitwiseXor(state) {\n    var node = parseBitwiseAnd(state);\n\n    while (state.token === '^|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\r\n   * bitwise and, 'x & y'\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseBitwiseAnd(state) {\n    var node = parseRelational(state);\n\n    while (state.token === '&') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\n    }\n\n    return node;\n  }\n  /**\r\n   * Parse a chained conditional, like 'a > b >= c'\r\n   * @return {Node} node\r\n   */\n\n\n  function parseRelational(state) {\n    var params = [parseShift(state)];\n    var conditionals = [];\n    var operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      var cond = {\n        name: state.token,\n        fn: operators[state.token]\n      };\n      conditionals.push(cond);\n      getTokenSkipNewline(state);\n      params.push(parseShift(state));\n    }\n\n    if (params.length === 1) {\n      return params[0];\n    } else if (params.length === 2) {\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\n    } else {\n      return new RelationalNode(conditionals.map(c => c.fn), params);\n    }\n  }\n  /**\r\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseShift(state) {\n    var node, name, fn, params;\n    node = parseConversion(state);\n    var operators = {\n      '<<': 'leftShift',\n      '>>': 'rightArithShift',\n      '>>>': 'rightLogShift'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseConversion(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\r\n   * conversion operators 'to' and 'in'\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseConversion(state) {\n    var node, name, fn, params;\n    node = parseRange(state);\n    var operators = {\n      to: 'to',\n      in: 'to' // alias of 'to'\n\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === 'in' && state.token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      } else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\r\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseRange(state) {\n    var node;\n    var params = [];\n\n    if (state.token === ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode(1);\n    } else {\n      // explicit start\n      node = parseAddSubtract(state);\n    }\n\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node); // parse step and end\n\n      while (state.token === ':' && params.length < 3) {\n        // eslint-disable-line no-unmodified-loop-condition\n        getTokenSkipNewline(state);\n\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        } else {\n          // explicit end\n          params.push(parseAddSubtract(state));\n        }\n      }\n\n      if (params.length === 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      } else {\n        // length === 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n  /**\r\n   * add or subtract\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseAddSubtract(state) {\n    var node, name, fn, params;\n    node = parseMultiplyDivide(state);\n    var operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      var rightNode = parseMultiplyDivide(state);\n\n      if (rightNode.isPercentage) {\n        params = [node, new OperatorNode('*', 'multiply', [node, rightNode])];\n      } else {\n        params = [node, rightNode];\n      }\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\r\n   * multiply, divide, modulus\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseMultiplyDivide(state) {\n    var node, last, name, fn;\n    node = parseImplicitMultiplication(state);\n    last = node;\n    var operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide'\n    };\n\n    while (true) {\n      if (hasOwnProperty(operators, state.token)) {\n        // explicit operators\n        name = state.token;\n        fn = operators[name];\n        getTokenSkipNewline(state);\n        last = parseImplicitMultiplication(state);\n        node = new OperatorNode(name, fn, [node, last]);\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\r\n   * implicit multiplication\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseImplicitMultiplication(state) {\n    var node, last;\n    node = parseRule2(state);\n    last = node;\n\n    while (true) {\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === '!') || state.token === '(') {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseRule2(state);\n        node = new OperatorNode('*', 'multiply', [node, last], true\n        /* implicit */\n        );\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\r\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\r\n   * And as amended in https://github.com/josdejong/mathjs/issues/2370#issuecomment-1054052164\r\n   * Explicit division gets higher precedence than implicit multiplication\r\n   * when the division matches this pattern:\r\n   *   [unaryPrefixOp]?[number] / [number] [symbol]\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseRule2(state) {\n    var node = parsePercentage(state);\n    var last = node;\n    var tokenStates = [];\n\n    while (true) {\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\n      if (state.token === '/' && rule2Node(last)) {\n        // Look ahead to see if the next token is a number\n        tokenStates.push(_extends({}, state));\n        getTokenSkipNewline(state); // Match the \"number / number\" part of the pattern\n\n        if (state.tokenType === TOKENTYPE.NUMBER) {\n          // Look ahead again\n          tokenStates.push(_extends({}, state));\n          getTokenSkipNewline(state); // Match the \"symbol\" part of the pattern, or a left parenthesis\n\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {\n            // We've matched the pattern \"number / number symbol\".\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\n            _extends(state, tokenStates.pop());\n\n            tokenStates.pop();\n            last = parsePercentage(state);\n            node = new OperatorNode('/', 'divide', [node, last]);\n          } else {\n            // Not a match, so rewind\n            tokenStates.pop();\n\n            _extends(state, tokenStates.pop());\n\n            break;\n          }\n        } else {\n          // Not a match, so rewind\n          _extends(state, tokenStates.pop());\n\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\r\n   * percentage or mod\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parsePercentage(state) {\n    var node, name, fn, params;\n    node = parseUnary(state);\n    var operators = {\n      '%': 'mod',\n      mod: 'mod'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === '%' && state.tokenType === TOKENTYPE.DELIMITER && state.token !== '(') {\n        // If the expression contains only %, then treat that as /100\n        node = new OperatorNode('/', 'divide', [node, new ConstantNode(100)], false, true);\n      } else {\n        params = [node, parseUnary(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\r\n   * Unary plus and minus, and logical and bitwise not\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseUnary(state) {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      not: 'not'\n    };\n\n    if (hasOwnProperty(operators, state.token)) {\n      fn = operators[state.token];\n      name = state.token;\n      getTokenSkipNewline(state);\n      params = [parseUnary(state)];\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow(state);\n  }\n  /**\r\n   * power\r\n   * Note: power operator is right associative\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parsePow(state) {\n    var node, name, fn, params;\n    node = parseLeftHandOperators(state);\n\n    if (state.token === '^' || state.token === '.^') {\n      name = state.token;\n      fn = name === '^' ? 'pow' : 'dotPow';\n      getTokenSkipNewline(state);\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\r\n   * Left hand operators: factorial x!, ctranspose x'\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseLeftHandOperators(state) {\n    var node, name, fn, params;\n    node = parseCustomNodes(state);\n    var operators = {\n      '!': 'factorial',\n      '\\'': 'ctranspose'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getToken(state);\n      params = [node];\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(state, node);\n    }\n\n    return node;\n  }\n  /**\r\n   * Parse a custom node handler. A node handler can be used to process\r\n   * nodes in a custom way, for example for handling a plot.\r\n   *\r\n   * A handler must be passed as second argument of the parse function.\r\n   * - must extend math.Node\r\n   * - must contain a function _compile(defs: Object) : string\r\n   * - must contain a function find(filter: Object) : Node[]\r\n   * - must contain a function toString() : string\r\n   * - the constructor is called with a single argument containing all parameters\r\n   *\r\n   * For example:\r\n   *\r\n   *     nodes = {\r\n   *       'plot': PlotHandler\r\n   *     }\r\n   *\r\n   * The constructor of the handler is called as:\r\n   *\r\n   *     node = new PlotHandler(params)\r\n   *\r\n   * The handler will be invoked when evaluating an expression like:\r\n   *\r\n   *     node = math.parse('plot(sin(x), x)', nodes)\r\n   *\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseCustomNodes(state) {\n    var params = [];\n\n    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {\n      var CustomNode = state.extraNodes[state.token];\n      getToken(state); // parse parameters\n\n      if (state.token === '(') {\n        params = [];\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ')') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ')') {\n          throw createSyntaxError(state, 'Parenthesis ) expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n      } // create a new custom node\n      // noinspection JSValidateTypes\n\n\n      return new CustomNode(params);\n    }\n\n    return parseSymbol(state);\n  }\n  /**\r\n   * parse symbols: functions, variables, constants, units\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseSymbol(state) {\n    var node, name;\n\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n      name = state.token;\n      getToken(state);\n\n      if (hasOwnProperty(CONSTANTS, name)) {\n        // true, false, null, ...\n        node = new ConstantNode(CONSTANTS[name]);\n      } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {\n        // NaN, Infinity\n        node = new ConstantNode(numeric(name, 'number'));\n      } else {\n        node = new SymbolNode(name);\n      } // parse function parameters and matrix index\n\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseDoubleQuotesString(state);\n  }\n  /**\r\n   * parse accessors:\r\n   * - function invocation in round brackets (...), for example sqrt(2)\r\n   * - index enclosed in square brackets [...], for example A[2,3]\r\n   * - dot notation for properties, like foo.bar\r\n   * @param {Object} state\r\n   * @param {Node} node    Node on which to apply the parameters. If there\r\n   *                       are no parameters in the expression, the node\r\n   *                       itself is returned\r\n   * @param {string[]} [types]  Filter the types of notations\r\n   *                            can be ['(', '[', '.']\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseAccessors(state, node, types) {\n    var params;\n\n    while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      params = [];\n\n      if (state.token === '(') {\n        if (isSymbolNode(node) || isAccessorNode(node)) {\n          // function invocation like fn(2, 3) or obj.fn(2, 3)\n          openParams(state);\n          getToken(state);\n\n          if (state.token !== ')') {\n            params.push(parseAssignment(state)); // parse a list with parameters\n\n            while (state.token === ',') {\n              // eslint-disable-line no-unmodified-loop-condition\n              getToken(state);\n              params.push(parseAssignment(state));\n            }\n          }\n\n          if (state.token !== ')') {\n            throw createSyntaxError(state, 'Parenthesis ) expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          node = new FunctionNode(node, params);\n        } else {\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\n          // don't parse it here but let it be handled by parseImplicitMultiplication\n          // with correct precedence\n          return node;\n        }\n      } else if (state.token === '[') {\n        // index notation like variable[2, 3]\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ']') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ']') {\n          throw createSyntaxError(state, 'Parenthesis ] expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n        node = new AccessorNode(node, new IndexNode(params));\n      } else {\n        // dot notation like variable.prop\n        getToken(state);\n\n        if (state.tokenType !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError(state, 'Property name expected after dot');\n        }\n\n        params.push(new ConstantNode(state.token));\n        getToken(state);\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n  /**\r\n   * Parse a double quotes string.\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseDoubleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\"') {\n      str = parseDoubleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseSingleQuotesString(state);\n  }\n  /**\r\n   * Parse a string surrounded by double quotes \"...\"\r\n   * @return {string}\r\n   */\n\n\n  function parseDoubleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\"') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\\"'\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\"') {\n      throw createSyntaxError(state, 'End of string \" expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\r\n   * Parse a single quotes string.\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseSingleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\\'') {\n      str = parseSingleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseMatrix(state);\n  }\n  /**\r\n   * Parse a string surrounded by single quotes '...'\r\n   * @return {string}\r\n   */\n\n\n  function parseSingleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\'') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\''\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\\'') {\n      throw createSyntaxError(state, 'End of string \\' expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\r\n   * parse the matrix\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseMatrix(state) {\n    var array, params, rows, cols;\n\n    if (state.token === '[') {\n      // matrix [...]\n      openParams(state);\n      getToken(state);\n\n      if (state.token !== ']') {\n        // this is a non-empty matrix\n        var row = parseRow(state);\n\n        if (state.token === ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row]; // the rows of the matrix are separated by dot-comma's\n\n          while (state.token === ';') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params[rows] = parseRow(state);\n            rows++;\n          }\n\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state); // check if the number of columns matches in all rows\n\n          cols = params[0].items.length;\n\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length !== cols) {\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        } else {\n          // 1 dimensional vector\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          array = row;\n        }\n      } else {\n        // this is an empty matrix \"[ ]\"\n        closeParams(state);\n        getToken(state);\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(state, array);\n    }\n\n    return parseObject(state);\n  }\n  /**\r\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\r\n   * @return {ArrayNode} node\r\n   */\n\n\n  function parseRow(state) {\n    var params = [parseAssignment(state)];\n    var len = 1;\n\n    while (state.token === ',') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getToken(state); // parse expression\n\n      params[len] = parseAssignment(state);\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n  /**\r\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseObject(state) {\n    if (state.token === '{') {\n      openParams(state);\n      var key;\n      var properties = {};\n\n      do {\n        getToken(state);\n\n        if (state.token !== '}') {\n          // parse key\n          if (state.token === '\"') {\n            key = parseDoubleQuotesStringToken(state);\n          } else if (state.token === '\\'') {\n            key = parseSingleQuotesStringToken(state);\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n            key = state.token;\n            getToken(state);\n          } else {\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\n          } // parse key/value separator\n\n\n          if (state.token !== ':') {\n            throw createSyntaxError(state, 'Colon : expected after object key');\n          }\n\n          getToken(state); // parse key\n\n          properties[key] = parseAssignment(state);\n        }\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\n\n\n      if (state.token !== '}') {\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\n      }\n\n      closeParams(state);\n      getToken(state);\n      var node = new ObjectNode(properties); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseNumber(state);\n  }\n  /**\r\n   * parse a number\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseNumber(state) {\n    var numberStr;\n\n    if (state.tokenType === TOKENTYPE.NUMBER) {\n      // this is a number\n      numberStr = state.token;\n      getToken(state);\n      return new ConstantNode(numeric(numberStr, config.number));\n    }\n\n    return parseParentheses(state);\n  }\n  /**\r\n   * parentheses\r\n   * @return {Node} node\r\n   * @private\r\n   */\n\n\n  function parseParentheses(state) {\n    var node; // check if it is a parenthesized expression\n\n    if (state.token === '(') {\n      // parentheses (...)\n      openParams(state);\n      getToken(state);\n      node = parseAssignment(state); // start again\n\n      if (state.token !== ')') {\n        throw createSyntaxError(state, 'Parenthesis ) expected');\n      }\n\n      closeParams(state);\n      getToken(state);\n      node = new ParenthesisNode(node);\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseEnd(state);\n  }\n  /**\r\n   * Evaluated when the expression is not yet ended but expected to end\r\n   * @return {Node} res\r\n   * @private\r\n   */\n\n\n  function parseEnd(state) {\n    if (state.token === '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError(state, 'Unexpected end of expression');\n    } else {\n      throw createSyntaxError(state, 'Value expected');\n    }\n  }\n  /**\r\n   * Shortcut for getting the current row value (one based)\r\n   * Returns the line of the currently handled expression\r\n   * @private\r\n   */\n\n  /* TODO: implement keeping track on the row number\r\n  function row () {\r\n    return null\r\n  }\r\n  */\n\n  /**\r\n   * Shortcut for getting the current col value (one based)\r\n   * Returns the column (position) where the last state.token starts\r\n   * @private\r\n   */\n\n\n  function col(state) {\n    return state.index - state.token.length + 1;\n  }\n  /**\r\n   * Create an error\r\n   * @param {Object} state\r\n   * @param {string} message\r\n   * @return {SyntaxError} instantiated error\r\n   * @private\r\n   */\n\n\n  function createSyntaxError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n  /**\r\n   * Create an error\r\n   * @param {Object} state\r\n   * @param {string} message\r\n   * @return {Error} instantiated error\r\n   * @private\r\n   */\n\n\n  function createError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  } // Now that we can parse, automatically convert strings to Nodes by parsing\n\n\n  typed.addConversion({\n    from: 'string',\n    to: 'Node',\n    convert: parse\n  });\n  return parse;\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/expression/parse.js"],"names":["_extends","factory","isAccessorNode","isConstantNode","isFunctionNode","isOperatorNode","isSymbolNode","rule2Node","deepMap","hasOwnProperty","name","dependencies","createParse","_ref","typed","numeric","config","AccessorNode","ArrayNode","AssignmentNode","BlockNode","ConditionalNode","ConstantNode","FunctionAssignmentNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","RangeNode","RelationalNode","SymbolNode","parse","string","expression","parseStart","ArrayMatrix","expressions","parseMultiple","stringObject","options","extraNodes","nodes","undefined","arguments","length","elem","TypeError","TOKENTYPE","NULL","DELIMITER","NUMBER","SYMBOL","UNKNOWN","DELIMITERS","NAMED_DELIMITERS","mod","to","in","and","xor","or","not","CONSTANTS","true","false","null","NUMERIC_CONSTANTS","initialState","comment","index","token","tokenType","nestingLevel","conditionalLevel","currentString","state","substr","currentCharacter","next","prevCharacter","charAt","nextCharacter","getToken","isWhitespace","c1","c2","c3","isDigitDot","_c","isHexDigit","isDigit","isDecimalMark","createSyntaxError","isAlpha","getTokenSkipNewline","openParams","closeParams","c","cPrev","cNext","isValidLatinOrGreek","isValidMathSymbol","test","high","low","node","parseBlock","createError","blocks","visible","parseAssignment","push","args","value","valid","parseConditional","object","fn","forEach","arg","parseLogicalOr","prev","condition","trueExpr","falseExpr","parseLogicalXor","parseLogicalAnd","parseBitwiseOr","parseBitwiseXor","parseBitwiseAnd","parseRelational","params","parseShift","conditionals","operators","cond","map","parseConversion","parseRange","parseAddSubtract","parseMultiplyDivide","rightNode","isPercentage","last","parseImplicitMultiplication","parseRule2","op","parsePercentage","tokenStates","pop","parseUnary","parsePow","parseLeftHandOperators","parseCustomNodes","parseAccessors","CustomNode","parseSymbol","indexOf","parseDoubleQuotesString","types","dotNotation","str","parseDoubleQuotesStringToken","parseSingleQuotesString","JSON","parseSingleQuotesStringToken","parseMatrix","array","rows","cols","row","parseRow","items","r","parseObject","len","key","properties","parseNumber","numberStr","number","parseParentheses","parseEnd","col","message","error","SyntaxError","char","addConversion","from","convert"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/extends\";\r\nimport { factory } from '../utils/factory.js';\r\nimport { isAccessorNode, isConstantNode, isFunctionNode, isOperatorNode, isSymbolNode, rule2Node } from '../utils/is.js';\r\nimport { deepMap } from '../utils/collection.js';\r\nimport { hasOwnProperty } from '../utils/object.js';\r\nvar name = 'parse';\r\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\r\nexport var createParse = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    numeric,\r\n    config,\r\n    AccessorNode,\r\n    ArrayNode,\r\n    AssignmentNode,\r\n    BlockNode,\r\n    ConditionalNode,\r\n    ConstantNode,\r\n    FunctionAssignmentNode,\r\n    FunctionNode,\r\n    IndexNode,\r\n    ObjectNode,\r\n    OperatorNode,\r\n    ParenthesisNode,\r\n    RangeNode,\r\n    RelationalNode,\r\n    SymbolNode\r\n  } = _ref;\r\n  /**\r\n   * Parse an expression. Returns a node tree, which can be evaluated by\r\n   * invoking node.evaluate().\r\n   *\r\n   * Note the evaluating arbitrary expressions may involve security risks,\r\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.parse(expr)\r\n   *     math.parse(expr, options)\r\n   *     math.parse([expr1, expr2, expr3, ...])\r\n   *     math.parse([expr1, expr2, expr3, ...], options)\r\n   *\r\n   * Example:\r\n   *\r\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\r\n   *     node1.compile().evaluate() // 5\r\n   *\r\n   *     let scope = {a:3, b:4}\r\n   *     const node2 = math.parse('a * b') // 12\r\n   *     const code2 = node2.compile()\r\n   *     code2.evaluate(scope) // 12\r\n   *     scope.a = 5\r\n   *     code2.evaluate(scope) // 20\r\n   *\r\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\r\n   *     nodes[2].compile().evaluate() // 12\r\n   *\r\n   * See also:\r\n   *\r\n   *     evaluate, compile\r\n   *\r\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\r\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\r\n   *                                                   - `nodes` a set of custom nodes\r\n   * @return {Node | Node[]} node\r\n   * @throws {Error}\r\n   */\r\n  var parse = typed(name, {\r\n    string: function string(expression) {\r\n      return parseStart(expression, {});\r\n    },\r\n    'Array | Matrix': function ArrayMatrix(expressions) {\r\n      return parseMultiple(expressions, {});\r\n    },\r\n    'string, Object': function stringObject(expression, options) {\r\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\r\n      return parseStart(expression, extraNodes);\r\n    },\r\n    'Array | Matrix, Object': parseMultiple\r\n  });\r\n  function parseMultiple(expressions) {\r\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n    var extraNodes = options.nodes !== undefined ? options.nodes : {};\r\n\r\n    // parse an array or matrix with expressions\r\n    return deepMap(expressions, function (elem) {\r\n      if (typeof elem !== 'string') throw new TypeError('String expected');\r\n      return parseStart(elem, extraNodes);\r\n    });\r\n  }\r\n\r\n  // token types enumeration\r\n  var TOKENTYPE = {\r\n    NULL: 0,\r\n    DELIMITER: 1,\r\n    NUMBER: 2,\r\n    SYMBOL: 3,\r\n    UNKNOWN: 4\r\n  };\r\n\r\n  // map with all delimiters\r\n  var DELIMITERS = {\r\n    ',': true,\r\n    '(': true,\r\n    ')': true,\r\n    '[': true,\r\n    ']': true,\r\n    '{': true,\r\n    '}': true,\r\n    '\"': true,\r\n    '\\'': true,\r\n    ';': true,\r\n    '+': true,\r\n    '-': true,\r\n    '*': true,\r\n    '.*': true,\r\n    '/': true,\r\n    './': true,\r\n    '%': true,\r\n    '^': true,\r\n    '.^': true,\r\n    '~': true,\r\n    '!': true,\r\n    '&': true,\r\n    '|': true,\r\n    '^|': true,\r\n    '=': true,\r\n    ':': true,\r\n    '?': true,\r\n    '==': true,\r\n    '!=': true,\r\n    '<': true,\r\n    '>': true,\r\n    '<=': true,\r\n    '>=': true,\r\n    '<<': true,\r\n    '>>': true,\r\n    '>>>': true\r\n  };\r\n\r\n  // map with all named delimiters\r\n  var NAMED_DELIMITERS = {\r\n    mod: true,\r\n    to: true,\r\n    in: true,\r\n    and: true,\r\n    xor: true,\r\n    or: true,\r\n    not: true\r\n  };\r\n  var CONSTANTS = {\r\n    true: true,\r\n    false: false,\r\n    null: null,\r\n    undefined\r\n  };\r\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\r\n  function initialState() {\r\n    return {\r\n      extraNodes: {},\r\n      // current extra nodes, must be careful not to mutate\r\n      expression: '',\r\n      // current expression\r\n      comment: '',\r\n      // last parsed comment\r\n      index: 0,\r\n      // current index in expr\r\n      token: '',\r\n      // current token\r\n      tokenType: TOKENTYPE.NULL,\r\n      // type of the token\r\n      nestingLevel: 0,\r\n      // level of nesting inside parameters, used to ignore newline characters\r\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\r\n    };\r\n  }\r\n\r\n  /**\r\n   * View upto `length` characters of the expression starting at the current character.\r\n   *\r\n   * @param {Object} state\r\n   * @param {number} [length=1] Number of characters to view\r\n   * @returns {string}\r\n   * @private\r\n   */\r\n  function currentString(state, length) {\r\n    return state.expression.substr(state.index, length);\r\n  }\r\n\r\n  /**\r\n   * View the current character. Returns '' if end of expression is reached.\r\n   *\r\n   * @param {Object} state\r\n   * @returns {string}\r\n   * @private\r\n   */\r\n  function currentCharacter(state) {\r\n    return currentString(state, 1);\r\n  }\r\n\r\n  /**\r\n   * Get the next character from the expression.\r\n   * The character is stored into the char c. If the end of the expression is\r\n   * reached, the function puts an empty string in c.\r\n   * @private\r\n   */\r\n  function next(state) {\r\n    state.index++;\r\n  }\r\n\r\n  /**\r\n   * Preview the previous character from the expression.\r\n   * @return {string} cNext\r\n   * @private\r\n   */\r\n  function prevCharacter(state) {\r\n    return state.expression.charAt(state.index - 1);\r\n  }\r\n\r\n  /**\r\n   * Preview the next character from the expression.\r\n   * @return {string} cNext\r\n   * @private\r\n   */\r\n  function nextCharacter(state) {\r\n    return state.expression.charAt(state.index + 1);\r\n  }\r\n\r\n  /**\r\n   * Get next token in the current string expr.\r\n   * The token and token type are available as token and tokenType\r\n   * @private\r\n   */\r\n  function getToken(state) {\r\n    state.tokenType = TOKENTYPE.NULL;\r\n    state.token = '';\r\n    state.comment = '';\r\n\r\n    // skip over ignored characters:\r\n    while (true) {\r\n      // comments:\r\n      if (currentCharacter(state) === '#') {\r\n        while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\r\n          state.comment += currentCharacter(state);\r\n          next(state);\r\n        }\r\n      }\r\n      // whitespace: space, tab, and newline when inside parameters\r\n      if (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\r\n        next(state);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // check for end of expression\r\n    if (currentCharacter(state) === '') {\r\n      // token is still empty\r\n      state.tokenType = TOKENTYPE.DELIMITER;\r\n      return;\r\n    }\r\n\r\n    // check for new line character\r\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\r\n      state.tokenType = TOKENTYPE.DELIMITER;\r\n      state.token = currentCharacter(state);\r\n      next(state);\r\n      return;\r\n    }\r\n    var c1 = currentCharacter(state);\r\n    var c2 = currentString(state, 2);\r\n    var c3 = currentString(state, 3);\r\n    if (c3.length === 3 && DELIMITERS[c3]) {\r\n      state.tokenType = TOKENTYPE.DELIMITER;\r\n      state.token = c3;\r\n      next(state);\r\n      next(state);\r\n      next(state);\r\n      return;\r\n    }\r\n\r\n    // check for delimiters consisting of 2 characters\r\n    if (c2.length === 2 && DELIMITERS[c2]) {\r\n      state.tokenType = TOKENTYPE.DELIMITER;\r\n      state.token = c2;\r\n      next(state);\r\n      next(state);\r\n      return;\r\n    }\r\n\r\n    // check for delimiters consisting of 1 character\r\n    if (DELIMITERS[c1]) {\r\n      state.tokenType = TOKENTYPE.DELIMITER;\r\n      state.token = c1;\r\n      next(state);\r\n      return;\r\n    }\r\n\r\n    // check for a number\r\n    if (parse.isDigitDot(c1)) {\r\n      state.tokenType = TOKENTYPE.NUMBER;\r\n\r\n      // check for binary, octal, or hex\r\n      var _c = currentString(state, 2);\r\n      if (_c === '0b' || _c === '0o' || _c === '0x') {\r\n        state.token += currentCharacter(state);\r\n        next(state);\r\n        state.token += currentCharacter(state);\r\n        next(state);\r\n        while (parse.isHexDigit(currentCharacter(state))) {\r\n          state.token += currentCharacter(state);\r\n          next(state);\r\n        }\r\n        if (currentCharacter(state) === '.') {\r\n          // this number has a radix point\r\n          state.token += '.';\r\n          next(state);\r\n          // get the digits after the radix\r\n          while (parse.isHexDigit(currentCharacter(state))) {\r\n            state.token += currentCharacter(state);\r\n            next(state);\r\n          }\r\n        } else if (currentCharacter(state) === 'i') {\r\n          // this number has a word size suffix\r\n          state.token += 'i';\r\n          next(state);\r\n          // get the word size\r\n          while (parse.isDigit(currentCharacter(state))) {\r\n            state.token += currentCharacter(state);\r\n            next(state);\r\n          }\r\n        }\r\n        return;\r\n      }\r\n\r\n      // get number, can have a single dot\r\n      if (currentCharacter(state) === '.') {\r\n        state.token += currentCharacter(state);\r\n        next(state);\r\n        if (!parse.isDigit(currentCharacter(state))) {\r\n          // this is no number, it is just a dot (can be dot notation)\r\n          state.tokenType = TOKENTYPE.DELIMITER;\r\n          return;\r\n        }\r\n      } else {\r\n        while (parse.isDigit(currentCharacter(state))) {\r\n          state.token += currentCharacter(state);\r\n          next(state);\r\n        }\r\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\r\n          state.token += currentCharacter(state);\r\n          next(state);\r\n        }\r\n      }\r\n      while (parse.isDigit(currentCharacter(state))) {\r\n        state.token += currentCharacter(state);\r\n        next(state);\r\n      }\r\n      // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\r\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\r\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\r\n          state.token += currentCharacter(state);\r\n          next(state);\r\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\r\n            state.token += currentCharacter(state);\r\n            next(state);\r\n          }\r\n          // Scientific notation MUST be followed by an exponent\r\n          if (!parse.isDigit(currentCharacter(state))) {\r\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\r\n          }\r\n          while (parse.isDigit(currentCharacter(state))) {\r\n            state.token += currentCharacter(state);\r\n            next(state);\r\n          }\r\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\r\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\r\n          }\r\n        } else if (nextCharacter(state) === '.') {\r\n          next(state);\r\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    // check for variables, functions, named operators\r\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\r\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\r\n        state.token += currentCharacter(state);\r\n        next(state);\r\n      }\r\n      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {\r\n        state.tokenType = TOKENTYPE.DELIMITER;\r\n      } else {\r\n        state.tokenType = TOKENTYPE.SYMBOL;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // something unknown is found, wrong characters -> a syntax error\r\n    state.tokenType = TOKENTYPE.UNKNOWN;\r\n    while (currentCharacter(state) !== '') {\r\n      state.token += currentCharacter(state);\r\n      next(state);\r\n    }\r\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\r\n  }\r\n\r\n  /**\r\n   * Get next token and skip newline tokens\r\n   */\r\n  function getTokenSkipNewline(state) {\r\n    do {\r\n      getToken(state);\r\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\r\n  }\r\n\r\n  /**\r\n   * Open parameters.\r\n   * New line characters will be ignored until closeParams(state) is called\r\n   */\r\n  function openParams(state) {\r\n    state.nestingLevel++;\r\n  }\r\n\r\n  /**\r\n   * Close parameters.\r\n   * New line characters will no longer be ignored\r\n   */\r\n  function closeParams(state) {\r\n    state.nestingLevel--;\r\n  }\r\n\r\n  /**\r\n   * Checks whether the current character `c` is a valid alpha character:\r\n   *\r\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\r\n   * - An underscore                        Ascii: _\r\n   * - A dollar sign                        Ascii: $\r\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\r\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\r\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\r\n   *\r\n   * The previous and next characters are needed to determine whether\r\n   * this character is part of a unicode surrogate pair.\r\n   *\r\n   * @param {string} c      Current character in the expression\r\n   * @param {string} cPrev  Previous character\r\n   * @param {string} cNext  Next character\r\n   * @return {boolean}\r\n   */\r\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\r\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\r\n  };\r\n\r\n  /**\r\n   * Test whether a character is a valid latin, greek, or letter-like character\r\n   * @param {string} c\r\n   * @return {boolean}\r\n   */\r\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\r\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\r\n  };\r\n\r\n  /**\r\n   * Test whether two given 16 bit characters form a surrogate pair of a\r\n   * unicode math symbol.\r\n   *\r\n   * https://unicode-table.com/en/\r\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\r\n   *\r\n   * Note: In ES6 will be unicode aware:\r\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\r\n   * https://mathiasbynens.be/notes/es6-unicode-regex\r\n   *\r\n   * @param {string} high\r\n   * @param {string} low\r\n   * @return {boolean}\r\n   */\r\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\r\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\r\n  };\r\n\r\n  /**\r\n   * Check whether given character c is a white space character: space, tab, or enter\r\n   * @param {string} c\r\n   * @param {number} nestingLevel\r\n   * @return {boolean}\r\n   */\r\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\r\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\r\n    return c === ' ' || c === '\\t' || c === '\\n' && nestingLevel > 0;\r\n  };\r\n\r\n  /**\r\n   * Test whether the character c is a decimal mark (dot).\r\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\r\n   * @param {string} c\r\n   * @param {string} cNext\r\n   * @return {boolean}\r\n   */\r\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\r\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\r\n  };\r\n\r\n  /**\r\n   * checks if the given char c is a digit or dot\r\n   * @param {string} c   a string with one character\r\n   * @return {boolean}\r\n   */\r\n  parse.isDigitDot = function isDigitDot(c) {\r\n    return c >= '0' && c <= '9' || c === '.';\r\n  };\r\n\r\n  /**\r\n   * checks if the given char c is a digit\r\n   * @param {string} c   a string with one character\r\n   * @return {boolean}\r\n   */\r\n  parse.isDigit = function isDigit(c) {\r\n    return c >= '0' && c <= '9';\r\n  };\r\n\r\n  /**\r\n   * checks if the given char c is a hex digit\r\n   * @param {string} c   a string with one character\r\n   * @return {boolean}\r\n   */\r\n  parse.isHexDigit = function isHexDigit(c) {\r\n    return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\r\n  };\r\n\r\n  /**\r\n   * Start of the parse levels below, in order of precedence\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseStart(expression, extraNodes) {\r\n    var state = initialState();\r\n    _extends(state, {\r\n      expression,\r\n      extraNodes\r\n    });\r\n    getToken(state);\r\n    var node = parseBlock(state);\r\n\r\n    // check for garbage at the end of the expression\r\n    // an expression ends with a empty character '' and tokenType DELIMITER\r\n    if (state.token !== '') {\r\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\r\n        // user entered a not existing operator like \"//\"\r\n\r\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\r\n        throw createError(state, 'Unexpected operator ' + state.token);\r\n      } else {\r\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Parse a block with expressions. Expressions can be separated by a newline\r\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\r\n   * of the preceding line is returned.\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseBlock(state) {\r\n    var node;\r\n    var blocks = [];\r\n    var visible;\r\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\r\n      node = parseAssignment(state);\r\n      if (state.comment) {\r\n        node.comment = state.comment;\r\n      }\r\n    }\r\n\r\n    // TODO: simplify this loop\r\n    while (state.token === '\\n' || state.token === ';') {\r\n      // eslint-disable-line no-unmodified-loop-condition\r\n      if (blocks.length === 0 && node) {\r\n        visible = state.token !== ';';\r\n        blocks.push({\r\n          node,\r\n          visible\r\n        });\r\n      }\r\n      getToken(state);\r\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\r\n        node = parseAssignment(state);\r\n        if (state.comment) {\r\n          node.comment = state.comment;\r\n        }\r\n        visible = state.token !== ';';\r\n        blocks.push({\r\n          node,\r\n          visible\r\n        });\r\n      }\r\n    }\r\n    if (blocks.length > 0) {\r\n      return new BlockNode(blocks);\r\n    } else {\r\n      if (!node) {\r\n        node = new ConstantNode(undefined);\r\n        if (state.comment) {\r\n          node.comment = state.comment;\r\n        }\r\n      }\r\n      return node;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assignment of a function or variable,\r\n   * - can be a variable like 'a=2.3'\r\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\r\n   * - defining a function like 'f(x) = x^2'\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseAssignment(state) {\r\n    var name, args, value, valid;\r\n    var node = parseConditional(state);\r\n    if (state.token === '=') {\r\n      if (isSymbolNode(node)) {\r\n        // parse a variable assignment like 'a = 2/3'\r\n        name = node.name;\r\n        getTokenSkipNewline(state);\r\n        value = parseAssignment(state);\r\n        return new AssignmentNode(new SymbolNode(name), value);\r\n      } else if (isAccessorNode(node)) {\r\n        // parse a matrix subset assignment like 'A[1,2] = 4'\r\n        getTokenSkipNewline(state);\r\n        value = parseAssignment(state);\r\n        return new AssignmentNode(node.object, node.index, value);\r\n      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {\r\n        // parse function assignment like 'f(x) = x^2'\r\n        valid = true;\r\n        args = [];\r\n        name = node.name;\r\n        node.args.forEach(function (arg, index) {\r\n          if (isSymbolNode(arg)) {\r\n            args[index] = arg.name;\r\n          } else {\r\n            valid = false;\r\n          }\r\n        });\r\n        if (valid) {\r\n          getTokenSkipNewline(state);\r\n          value = parseAssignment(state);\r\n          return new FunctionAssignmentNode(name, args, value);\r\n        }\r\n      }\r\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * conditional operation\r\n   *\r\n   *     condition ? truePart : falsePart\r\n   *\r\n   * Note: conditional operator is right-associative\r\n   *\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseConditional(state) {\r\n    var node = parseLogicalOr(state);\r\n    while (state.token === '?') {\r\n      // eslint-disable-line no-unmodified-loop-condition\r\n      // set a conditional level, the range operator will be ignored as long\r\n      // as conditionalLevel === state.nestingLevel.\r\n      var prev = state.conditionalLevel;\r\n      state.conditionalLevel = state.nestingLevel;\r\n      getTokenSkipNewline(state);\r\n      var condition = node;\r\n      var trueExpr = parseAssignment(state);\r\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\r\n      state.conditionalLevel = null;\r\n      getTokenSkipNewline(state);\r\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\r\n\r\n      node = new ConditionalNode(condition, trueExpr, falseExpr);\r\n\r\n      // restore the previous conditional level\r\n      state.conditionalLevel = prev;\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * logical or, 'x or y'\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseLogicalOr(state) {\r\n    var node = parseLogicalXor(state);\r\n    while (state.token === 'or') {\r\n      // eslint-disable-line no-unmodified-loop-condition\r\n      getTokenSkipNewline(state);\r\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * logical exclusive or, 'x xor y'\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseLogicalXor(state) {\r\n    var node = parseLogicalAnd(state);\r\n    while (state.token === 'xor') {\r\n      // eslint-disable-line no-unmodified-loop-condition\r\n      getTokenSkipNewline(state);\r\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * logical and, 'x and y'\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseLogicalAnd(state) {\r\n    var node = parseBitwiseOr(state);\r\n    while (state.token === 'and') {\r\n      // eslint-disable-line no-unmodified-loop-condition\r\n      getTokenSkipNewline(state);\r\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * bitwise or, 'x | y'\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseBitwiseOr(state) {\r\n    var node = parseBitwiseXor(state);\r\n    while (state.token === '|') {\r\n      // eslint-disable-line no-unmodified-loop-condition\r\n      getTokenSkipNewline(state);\r\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * bitwise exclusive or (xor), 'x ^| y'\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseBitwiseXor(state) {\r\n    var node = parseBitwiseAnd(state);\r\n    while (state.token === '^|') {\r\n      // eslint-disable-line no-unmodified-loop-condition\r\n      getTokenSkipNewline(state);\r\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * bitwise and, 'x & y'\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseBitwiseAnd(state) {\r\n    var node = parseRelational(state);\r\n    while (state.token === '&') {\r\n      // eslint-disable-line no-unmodified-loop-condition\r\n      getTokenSkipNewline(state);\r\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Parse a chained conditional, like 'a > b >= c'\r\n   * @return {Node} node\r\n   */\r\n  function parseRelational(state) {\r\n    var params = [parseShift(state)];\r\n    var conditionals = [];\r\n    var operators = {\r\n      '==': 'equal',\r\n      '!=': 'unequal',\r\n      '<': 'smaller',\r\n      '>': 'larger',\r\n      '<=': 'smallerEq',\r\n      '>=': 'largerEq'\r\n    };\r\n    while (hasOwnProperty(operators, state.token)) {\r\n      // eslint-disable-line no-unmodified-loop-condition\r\n      var cond = {\r\n        name: state.token,\r\n        fn: operators[state.token]\r\n      };\r\n      conditionals.push(cond);\r\n      getTokenSkipNewline(state);\r\n      params.push(parseShift(state));\r\n    }\r\n    if (params.length === 1) {\r\n      return params[0];\r\n    } else if (params.length === 2) {\r\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\r\n    } else {\r\n      return new RelationalNode(conditionals.map(c => c.fn), params);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseShift(state) {\r\n    var node, name, fn, params;\r\n    node = parseConversion(state);\r\n    var operators = {\r\n      '<<': 'leftShift',\r\n      '>>': 'rightArithShift',\r\n      '>>>': 'rightLogShift'\r\n    };\r\n    while (hasOwnProperty(operators, state.token)) {\r\n      name = state.token;\r\n      fn = operators[name];\r\n      getTokenSkipNewline(state);\r\n      params = [node, parseConversion(state)];\r\n      node = new OperatorNode(name, fn, params);\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * conversion operators 'to' and 'in'\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseConversion(state) {\r\n    var node, name, fn, params;\r\n    node = parseRange(state);\r\n    var operators = {\r\n      to: 'to',\r\n      in: 'to' // alias of 'to'\r\n    };\r\n\r\n    while (hasOwnProperty(operators, state.token)) {\r\n      name = state.token;\r\n      fn = operators[name];\r\n      getTokenSkipNewline(state);\r\n      if (name === 'in' && state.token === '') {\r\n        // end of expression -> this is the unit 'in' ('inch')\r\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\r\n      } else {\r\n        // operator 'a to b' or 'a in b'\r\n        params = [node, parseRange(state)];\r\n        node = new OperatorNode(name, fn, params);\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseRange(state) {\r\n    var node;\r\n    var params = [];\r\n    if (state.token === ':') {\r\n      // implicit start=1 (one-based)\r\n      node = new ConstantNode(1);\r\n    } else {\r\n      // explicit start\r\n      node = parseAddSubtract(state);\r\n    }\r\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\r\n      // we ignore the range operator when a conditional operator is being processed on the same level\r\n      params.push(node);\r\n\r\n      // parse step and end\r\n      while (state.token === ':' && params.length < 3) {\r\n        // eslint-disable-line no-unmodified-loop-condition\r\n        getTokenSkipNewline(state);\r\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\r\n          // implicit end\r\n          params.push(new SymbolNode('end'));\r\n        } else {\r\n          // explicit end\r\n          params.push(parseAddSubtract(state));\r\n        }\r\n      }\r\n      if (params.length === 3) {\r\n        // params = [start, step, end]\r\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\r\n      } else {\r\n        // length === 2\r\n        // params = [start, end]\r\n        node = new RangeNode(params[0], params[1]); // start, end\r\n      }\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * add or subtract\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseAddSubtract(state) {\r\n    var node, name, fn, params;\r\n    node = parseMultiplyDivide(state);\r\n    var operators = {\r\n      '+': 'add',\r\n      '-': 'subtract'\r\n    };\r\n    while (hasOwnProperty(operators, state.token)) {\r\n      name = state.token;\r\n      fn = operators[name];\r\n      getTokenSkipNewline(state);\r\n      var rightNode = parseMultiplyDivide(state);\r\n      if (rightNode.isPercentage) {\r\n        params = [node, new OperatorNode('*', 'multiply', [node, rightNode])];\r\n      } else {\r\n        params = [node, rightNode];\r\n      }\r\n      node = new OperatorNode(name, fn, params);\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * multiply, divide, modulus\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseMultiplyDivide(state) {\r\n    var node, last, name, fn;\r\n    node = parseImplicitMultiplication(state);\r\n    last = node;\r\n    var operators = {\r\n      '*': 'multiply',\r\n      '.*': 'dotMultiply',\r\n      '/': 'divide',\r\n      './': 'dotDivide'\r\n    };\r\n    while (true) {\r\n      if (hasOwnProperty(operators, state.token)) {\r\n        // explicit operators\r\n        name = state.token;\r\n        fn = operators[name];\r\n        getTokenSkipNewline(state);\r\n        last = parseImplicitMultiplication(state);\r\n        node = new OperatorNode(name, fn, [node, last]);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * implicit multiplication\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseImplicitMultiplication(state) {\r\n    var node, last;\r\n    node = parseRule2(state);\r\n    last = node;\r\n    while (true) {\r\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === '!') || state.token === '(') {\r\n        // parse implicit multiplication\r\n        //\r\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\r\n        // number:      implicit multiplication like '(2+3)2'\r\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\r\n        last = parseRule2(state);\r\n        node = new OperatorNode('*', 'multiply', [node, last], true /* implicit */);\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\r\n   * And as amended in https://github.com/josdejong/mathjs/issues/2370#issuecomment-1054052164\r\n   * Explicit division gets higher precedence than implicit multiplication\r\n   * when the division matches this pattern:\r\n   *   [unaryPrefixOp]?[number] / [number] [symbol]\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseRule2(state) {\r\n    var node = parsePercentage(state);\r\n    var last = node;\r\n    var tokenStates = [];\r\n    while (true) {\r\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\r\n      if (state.token === '/' && rule2Node(last)) {\r\n        // Look ahead to see if the next token is a number\r\n        tokenStates.push(_extends({}, state));\r\n        getTokenSkipNewline(state);\r\n\r\n        // Match the \"number / number\" part of the pattern\r\n        if (state.tokenType === TOKENTYPE.NUMBER) {\r\n          // Look ahead again\r\n          tokenStates.push(_extends({}, state));\r\n          getTokenSkipNewline(state);\r\n\r\n          // Match the \"symbol\" part of the pattern, or a left parenthesis\r\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {\r\n            // We've matched the pattern \"number / number symbol\".\r\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\r\n            _extends(state, tokenStates.pop());\r\n            tokenStates.pop();\r\n            last = parsePercentage(state);\r\n            node = new OperatorNode('/', 'divide', [node, last]);\r\n          } else {\r\n            // Not a match, so rewind\r\n            tokenStates.pop();\r\n            _extends(state, tokenStates.pop());\r\n            break;\r\n          }\r\n        } else {\r\n          // Not a match, so rewind\r\n          _extends(state, tokenStates.pop());\r\n          break;\r\n        }\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * percentage or mod\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parsePercentage(state) {\r\n    var node, name, fn, params;\r\n    node = parseUnary(state);\r\n    var operators = {\r\n      '%': 'mod',\r\n      mod: 'mod'\r\n    };\r\n    while (hasOwnProperty(operators, state.token)) {\r\n      name = state.token;\r\n      fn = operators[name];\r\n      getTokenSkipNewline(state);\r\n      if (name === '%' && state.tokenType === TOKENTYPE.DELIMITER && state.token !== '(') {\r\n        // If the expression contains only %, then treat that as /100\r\n        node = new OperatorNode('/', 'divide', [node, new ConstantNode(100)], false, true);\r\n      } else {\r\n        params = [node, parseUnary(state)];\r\n        node = new OperatorNode(name, fn, params);\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Unary plus and minus, and logical and bitwise not\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseUnary(state) {\r\n    var name, params, fn;\r\n    var operators = {\r\n      '-': 'unaryMinus',\r\n      '+': 'unaryPlus',\r\n      '~': 'bitNot',\r\n      not: 'not'\r\n    };\r\n    if (hasOwnProperty(operators, state.token)) {\r\n      fn = operators[state.token];\r\n      name = state.token;\r\n      getTokenSkipNewline(state);\r\n      params = [parseUnary(state)];\r\n      return new OperatorNode(name, fn, params);\r\n    }\r\n    return parsePow(state);\r\n  }\r\n\r\n  /**\r\n   * power\r\n   * Note: power operator is right associative\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parsePow(state) {\r\n    var node, name, fn, params;\r\n    node = parseLeftHandOperators(state);\r\n    if (state.token === '^' || state.token === '.^') {\r\n      name = state.token;\r\n      fn = name === '^' ? 'pow' : 'dotPow';\r\n      getTokenSkipNewline(state);\r\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\r\n      node = new OperatorNode(name, fn, params);\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Left hand operators: factorial x!, ctranspose x'\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseLeftHandOperators(state) {\r\n    var node, name, fn, params;\r\n    node = parseCustomNodes(state);\r\n    var operators = {\r\n      '!': 'factorial',\r\n      '\\'': 'ctranspose'\r\n    };\r\n    while (hasOwnProperty(operators, state.token)) {\r\n      name = state.token;\r\n      fn = operators[name];\r\n      getToken(state);\r\n      params = [node];\r\n      node = new OperatorNode(name, fn, params);\r\n      node = parseAccessors(state, node);\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Parse a custom node handler. A node handler can be used to process\r\n   * nodes in a custom way, for example for handling a plot.\r\n   *\r\n   * A handler must be passed as second argument of the parse function.\r\n   * - must extend math.Node\r\n   * - must contain a function _compile(defs: Object) : string\r\n   * - must contain a function find(filter: Object) : Node[]\r\n   * - must contain a function toString() : string\r\n   * - the constructor is called with a single argument containing all parameters\r\n   *\r\n   * For example:\r\n   *\r\n   *     nodes = {\r\n   *       'plot': PlotHandler\r\n   *     }\r\n   *\r\n   * The constructor of the handler is called as:\r\n   *\r\n   *     node = new PlotHandler(params)\r\n   *\r\n   * The handler will be invoked when evaluating an expression like:\r\n   *\r\n   *     node = math.parse('plot(sin(x), x)', nodes)\r\n   *\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseCustomNodes(state) {\r\n    var params = [];\r\n    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {\r\n      var CustomNode = state.extraNodes[state.token];\r\n      getToken(state);\r\n\r\n      // parse parameters\r\n      if (state.token === '(') {\r\n        params = [];\r\n        openParams(state);\r\n        getToken(state);\r\n        if (state.token !== ')') {\r\n          params.push(parseAssignment(state));\r\n\r\n          // parse a list with parameters\r\n          while (state.token === ',') {\r\n            // eslint-disable-line no-unmodified-loop-condition\r\n            getToken(state);\r\n            params.push(parseAssignment(state));\r\n          }\r\n        }\r\n        if (state.token !== ')') {\r\n          throw createSyntaxError(state, 'Parenthesis ) expected');\r\n        }\r\n        closeParams(state);\r\n        getToken(state);\r\n      }\r\n\r\n      // create a new custom node\r\n      // noinspection JSValidateTypes\r\n      return new CustomNode(params);\r\n    }\r\n    return parseSymbol(state);\r\n  }\r\n\r\n  /**\r\n   * parse symbols: functions, variables, constants, units\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseSymbol(state) {\r\n    var node, name;\r\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\r\n      name = state.token;\r\n      getToken(state);\r\n      if (hasOwnProperty(CONSTANTS, name)) {\r\n        // true, false, null, ...\r\n        node = new ConstantNode(CONSTANTS[name]);\r\n      } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {\r\n        // NaN, Infinity\r\n        node = new ConstantNode(numeric(name, 'number'));\r\n      } else {\r\n        node = new SymbolNode(name);\r\n      }\r\n\r\n      // parse function parameters and matrix index\r\n      node = parseAccessors(state, node);\r\n      return node;\r\n    }\r\n    return parseDoubleQuotesString(state);\r\n  }\r\n\r\n  /**\r\n   * parse accessors:\r\n   * - function invocation in round brackets (...), for example sqrt(2)\r\n   * - index enclosed in square brackets [...], for example A[2,3]\r\n   * - dot notation for properties, like foo.bar\r\n   * @param {Object} state\r\n   * @param {Node} node    Node on which to apply the parameters. If there\r\n   *                       are no parameters in the expression, the node\r\n   *                       itself is returned\r\n   * @param {string[]} [types]  Filter the types of notations\r\n   *                            can be ['(', '[', '.']\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseAccessors(state, node, types) {\r\n    var params;\r\n    while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {\r\n      // eslint-disable-line no-unmodified-loop-condition\r\n      params = [];\r\n      if (state.token === '(') {\r\n        if (isSymbolNode(node) || isAccessorNode(node)) {\r\n          // function invocation like fn(2, 3) or obj.fn(2, 3)\r\n          openParams(state);\r\n          getToken(state);\r\n          if (state.token !== ')') {\r\n            params.push(parseAssignment(state));\r\n\r\n            // parse a list with parameters\r\n            while (state.token === ',') {\r\n              // eslint-disable-line no-unmodified-loop-condition\r\n              getToken(state);\r\n              params.push(parseAssignment(state));\r\n            }\r\n          }\r\n          if (state.token !== ')') {\r\n            throw createSyntaxError(state, 'Parenthesis ) expected');\r\n          }\r\n          closeParams(state);\r\n          getToken(state);\r\n          node = new FunctionNode(node, params);\r\n        } else {\r\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\r\n          // don't parse it here but let it be handled by parseImplicitMultiplication\r\n          // with correct precedence\r\n          return node;\r\n        }\r\n      } else if (state.token === '[') {\r\n        // index notation like variable[2, 3]\r\n        openParams(state);\r\n        getToken(state);\r\n        if (state.token !== ']') {\r\n          params.push(parseAssignment(state));\r\n\r\n          // parse a list with parameters\r\n          while (state.token === ',') {\r\n            // eslint-disable-line no-unmodified-loop-condition\r\n            getToken(state);\r\n            params.push(parseAssignment(state));\r\n          }\r\n        }\r\n        if (state.token !== ']') {\r\n          throw createSyntaxError(state, 'Parenthesis ] expected');\r\n        }\r\n        closeParams(state);\r\n        getToken(state);\r\n        node = new AccessorNode(node, new IndexNode(params));\r\n      } else {\r\n        // dot notation like variable.prop\r\n        getToken(state);\r\n        if (state.tokenType !== TOKENTYPE.SYMBOL) {\r\n          throw createSyntaxError(state, 'Property name expected after dot');\r\n        }\r\n        params.push(new ConstantNode(state.token));\r\n        getToken(state);\r\n        var dotNotation = true;\r\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Parse a double quotes string.\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseDoubleQuotesString(state) {\r\n    var node, str;\r\n    if (state.token === '\"') {\r\n      str = parseDoubleQuotesStringToken(state);\r\n\r\n      // create constant\r\n      node = new ConstantNode(str);\r\n\r\n      // parse index parameters\r\n      node = parseAccessors(state, node);\r\n      return node;\r\n    }\r\n    return parseSingleQuotesString(state);\r\n  }\r\n\r\n  /**\r\n   * Parse a string surrounded by double quotes \"...\"\r\n   * @return {string}\r\n   */\r\n  function parseDoubleQuotesStringToken(state) {\r\n    var str = '';\r\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\"') {\r\n      if (currentCharacter(state) === '\\\\') {\r\n        // escape character, immediately process the next\r\n        // character to prevent stopping at a next '\\\"'\r\n        str += currentCharacter(state);\r\n        next(state);\r\n      }\r\n      str += currentCharacter(state);\r\n      next(state);\r\n    }\r\n    getToken(state);\r\n    if (state.token !== '\"') {\r\n      throw createSyntaxError(state, 'End of string \" expected');\r\n    }\r\n    getToken(state);\r\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\r\n  }\r\n\r\n  /**\r\n   * Parse a single quotes string.\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseSingleQuotesString(state) {\r\n    var node, str;\r\n    if (state.token === '\\'') {\r\n      str = parseSingleQuotesStringToken(state);\r\n\r\n      // create constant\r\n      node = new ConstantNode(str);\r\n\r\n      // parse index parameters\r\n      node = parseAccessors(state, node);\r\n      return node;\r\n    }\r\n    return parseMatrix(state);\r\n  }\r\n\r\n  /**\r\n   * Parse a string surrounded by single quotes '...'\r\n   * @return {string}\r\n   */\r\n  function parseSingleQuotesStringToken(state) {\r\n    var str = '';\r\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\'') {\r\n      if (currentCharacter(state) === '\\\\') {\r\n        // escape character, immediately process the next\r\n        // character to prevent stopping at a next '\\''\r\n        str += currentCharacter(state);\r\n        next(state);\r\n      }\r\n      str += currentCharacter(state);\r\n      next(state);\r\n    }\r\n    getToken(state);\r\n    if (state.token !== '\\'') {\r\n      throw createSyntaxError(state, 'End of string \\' expected');\r\n    }\r\n    getToken(state);\r\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\r\n  }\r\n\r\n  /**\r\n   * parse the matrix\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseMatrix(state) {\r\n    var array, params, rows, cols;\r\n    if (state.token === '[') {\r\n      // matrix [...]\r\n      openParams(state);\r\n      getToken(state);\r\n      if (state.token !== ']') {\r\n        // this is a non-empty matrix\r\n        var row = parseRow(state);\r\n        if (state.token === ';') {\r\n          // 2 dimensional array\r\n          rows = 1;\r\n          params = [row];\r\n\r\n          // the rows of the matrix are separated by dot-comma's\r\n          while (state.token === ';') {\r\n            // eslint-disable-line no-unmodified-loop-condition\r\n            getToken(state);\r\n            params[rows] = parseRow(state);\r\n            rows++;\r\n          }\r\n          if (state.token !== ']') {\r\n            throw createSyntaxError(state, 'End of matrix ] expected');\r\n          }\r\n          closeParams(state);\r\n          getToken(state);\r\n\r\n          // check if the number of columns matches in all rows\r\n          cols = params[0].items.length;\r\n          for (var r = 1; r < rows; r++) {\r\n            if (params[r].items.length !== cols) {\r\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\r\n            }\r\n          }\r\n          array = new ArrayNode(params);\r\n        } else {\r\n          // 1 dimensional vector\r\n          if (state.token !== ']') {\r\n            throw createSyntaxError(state, 'End of matrix ] expected');\r\n          }\r\n          closeParams(state);\r\n          getToken(state);\r\n          array = row;\r\n        }\r\n      } else {\r\n        // this is an empty matrix \"[ ]\"\r\n        closeParams(state);\r\n        getToken(state);\r\n        array = new ArrayNode([]);\r\n      }\r\n      return parseAccessors(state, array);\r\n    }\r\n    return parseObject(state);\r\n  }\r\n\r\n  /**\r\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\r\n   * @return {ArrayNode} node\r\n   */\r\n  function parseRow(state) {\r\n    var params = [parseAssignment(state)];\r\n    var len = 1;\r\n    while (state.token === ',') {\r\n      // eslint-disable-line no-unmodified-loop-condition\r\n      getToken(state);\r\n\r\n      // parse expression\r\n      params[len] = parseAssignment(state);\r\n      len++;\r\n    }\r\n    return new ArrayNode(params);\r\n  }\r\n\r\n  /**\r\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseObject(state) {\r\n    if (state.token === '{') {\r\n      openParams(state);\r\n      var key;\r\n      var properties = {};\r\n      do {\r\n        getToken(state);\r\n        if (state.token !== '}') {\r\n          // parse key\r\n          if (state.token === '\"') {\r\n            key = parseDoubleQuotesStringToken(state);\r\n          } else if (state.token === '\\'') {\r\n            key = parseSingleQuotesStringToken(state);\r\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\r\n            key = state.token;\r\n            getToken(state);\r\n          } else {\r\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\r\n          }\r\n\r\n          // parse key/value separator\r\n          if (state.token !== ':') {\r\n            throw createSyntaxError(state, 'Colon : expected after object key');\r\n          }\r\n          getToken(state);\r\n\r\n          // parse key\r\n          properties[key] = parseAssignment(state);\r\n        }\r\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\r\n\r\n      if (state.token !== '}') {\r\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\r\n      }\r\n      closeParams(state);\r\n      getToken(state);\r\n      var node = new ObjectNode(properties);\r\n\r\n      // parse index parameters\r\n      node = parseAccessors(state, node);\r\n      return node;\r\n    }\r\n    return parseNumber(state);\r\n  }\r\n\r\n  /**\r\n   * parse a number\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseNumber(state) {\r\n    var numberStr;\r\n    if (state.tokenType === TOKENTYPE.NUMBER) {\r\n      // this is a number\r\n      numberStr = state.token;\r\n      getToken(state);\r\n      return new ConstantNode(numeric(numberStr, config.number));\r\n    }\r\n    return parseParentheses(state);\r\n  }\r\n\r\n  /**\r\n   * parentheses\r\n   * @return {Node} node\r\n   * @private\r\n   */\r\n  function parseParentheses(state) {\r\n    var node;\r\n\r\n    // check if it is a parenthesized expression\r\n    if (state.token === '(') {\r\n      // parentheses (...)\r\n      openParams(state);\r\n      getToken(state);\r\n      node = parseAssignment(state); // start again\r\n\r\n      if (state.token !== ')') {\r\n        throw createSyntaxError(state, 'Parenthesis ) expected');\r\n      }\r\n      closeParams(state);\r\n      getToken(state);\r\n      node = new ParenthesisNode(node);\r\n      node = parseAccessors(state, node);\r\n      return node;\r\n    }\r\n    return parseEnd(state);\r\n  }\r\n\r\n  /**\r\n   * Evaluated when the expression is not yet ended but expected to end\r\n   * @return {Node} res\r\n   * @private\r\n   */\r\n  function parseEnd(state) {\r\n    if (state.token === '') {\r\n      // syntax error or unexpected end of expression\r\n      throw createSyntaxError(state, 'Unexpected end of expression');\r\n    } else {\r\n      throw createSyntaxError(state, 'Value expected');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Shortcut for getting the current row value (one based)\r\n   * Returns the line of the currently handled expression\r\n   * @private\r\n   */\r\n  /* TODO: implement keeping track on the row number\r\n  function row () {\r\n    return null\r\n  }\r\n  */\r\n\r\n  /**\r\n   * Shortcut for getting the current col value (one based)\r\n   * Returns the column (position) where the last state.token starts\r\n   * @private\r\n   */\r\n  function col(state) {\r\n    return state.index - state.token.length + 1;\r\n  }\r\n\r\n  /**\r\n   * Create an error\r\n   * @param {Object} state\r\n   * @param {string} message\r\n   * @return {SyntaxError} instantiated error\r\n   * @private\r\n   */\r\n  function createSyntaxError(state, message) {\r\n    var c = col(state);\r\n    var error = new SyntaxError(message + ' (char ' + c + ')');\r\n    error.char = c;\r\n    return error;\r\n  }\r\n\r\n  /**\r\n   * Create an error\r\n   * @param {Object} state\r\n   * @param {string} message\r\n   * @return {Error} instantiated error\r\n   * @private\r\n   */\r\n  function createError(state, message) {\r\n    var c = col(state);\r\n    var error = new SyntaxError(message + ' (char ' + c + ')');\r\n    error.char = c;\r\n    return error;\r\n  }\r\n\r\n  // Now that we can parse, automatically convert strings to Nodes by parsing\r\n  typed.addConversion({\r\n    from: 'string',\r\n    to: 'Node',\r\n    convert: parse\r\n  });\r\n  return parse;\r\n});"]},"metadata":{},"sourceType":"module"}