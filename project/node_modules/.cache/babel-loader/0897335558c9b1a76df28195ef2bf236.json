{"ast":null,"code":"import { createElement, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { DataUtil } from '@syncfusion/ej2-data';\nimport { subtractThickness, valueToCoefficient, sum, redrawElement, isBreakLabel, ChartLocation } from '../../common/utils/helper';\nimport { subArray, inside, appendChildElement, stringToNumber } from '../../common/utils/helper';\nimport { Thickness, logBase, createZoomingLabels, getElement } from '../../common/utils/helper';\nimport { Size, Rect, measureText, TextOption, PathOption } from '@syncfusion/ej2-svg-base';\nimport { textElement, textTrim, getRotatedRectangleCoordinates, isRotatedRectIntersect, isZoomSet } from '../../common/utils/helper';\n/**\r\n * Specifies the Cartesian Axis Layout.\r\n */\n\nvar axisPadding = 10;\n\nvar CartesianAxisLayoutPanel =\n/** @class */\nfunction () {\n  /** @private */\n  function CartesianAxisLayoutPanel(chartModule) {\n    this.chart = chartModule;\n    this.padding = 5;\n  }\n  /**\r\n   * Measure the axis size.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.measureAxis = function (rect) {\n    var chart = this.chart;\n    var chartAreaWidth = chart.chartArea.width ? stringToNumber(chart.chartArea.width, chart.availableSize.width) : null;\n    this.crossAt(chart);\n    this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);\n    this.initialClipRect = rect;\n    this.leftSize = 0;\n    this.rightSize = 0;\n    this.topSize = 0;\n    this.bottomSize = 0; //Measure Axis size with initial Rect\n\n    this.measureRowAxis(chart, this.initialClipRect);\n    this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\n    this.measureColumnAxis(chart, this.initialClipRect);\n    this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\n\n    if (!this.chart.delayRedraw) {\n      this.calculateAxisSize(this.initialClipRect);\n    }\n\n    this.leftSize = 0;\n    this.rightSize = 0;\n    this.topSize = 0;\n    this.bottomSize = 0; //Measure Axis size with series Rect\n\n    this.measureRowAxis(chart, this.initialClipRect);\n    this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\n    this.measureColumnAxis(chart, this.initialClipRect);\n    this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\n\n    if (chartAreaWidth) {\n      this.calculateFixedChartArea(chart, chartAreaWidth);\n    }\n\n    if (!this.chart.delayRedraw) {\n      chart.refreshAxis();\n      this.calculateAxisSize(this.seriesClipRect);\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.calculateFixedChartArea = function (chart, chartAreaWidth) {\n    this.seriesClipRect.width = chartAreaWidth;\n    this.seriesClipRect.x = chart.availableSize.width - chart.margin.right - chartAreaWidth - (chart.legendSettings.position === \"Right\" ? chart.legendModule.legendBounds.width : 0);\n\n    for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n      var item = _a[_i];\n      this.seriesClipRect.x -= sum(item.farSizes);\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.measureRowAxis = function (chart, rect) {\n    var row;\n    this.calculateRowSize(rect);\n\n    for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\n      var item = _a[_i];\n      row = item;\n      row.nearSizes = [];\n      row.farSizes = [];\n      this.arrangeAxis(row);\n      this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));\n\n      if (this.leftSize < sum(row.nearSizes)) {\n        this.leftSize = sum(row.nearSizes);\n      }\n\n      if (this.rightSize < sum(row.farSizes)) {\n        this.rightSize = sum(row.farSizes);\n      }\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.measureColumnAxis = function (chart, rect) {\n    var column;\n    this.calculateColumnSize(rect);\n\n    for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\n      var item = _a[_i];\n      column = item;\n      column.farSizes = [];\n      column.nearSizes = [];\n      this.arrangeAxis(column);\n      this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));\n\n      if (this.bottomSize < sum(column.nearSizes)) {\n        this.bottomSize = sum(column.nearSizes);\n      }\n\n      if (this.topSize < sum(column.farSizes)) {\n        this.topSize = sum(column.farSizes);\n      }\n    }\n  };\n  /**\r\n   * Measure the column and row in chart.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.measureDefinition = function (definition, chart, size) {\n    var ele = 16; // scrollbar element height is 16.\n\n    for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {\n      var axis = _a[_i];\n      axis.scrollBarHeight = chart.scrollBarModule && chart.zoomModule && chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? ele : 0;\n      axis.scrollBarHeight = chart.scrollBarModule && (chart.zoomModule && chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) || axis.scrollbarSettings.enable) ? ele : 0;\n      axis.getModule(chart);\n      axis.baseModule.calculateRangeAndInterval(size, axis);\n      definition.computeSize(axis, axis.scrollBarHeight);\n    }\n\n    if (definition.farSizes.length > 0) {\n      definition.farSizes[definition.farSizes.length - 1] -= axisPadding;\n    }\n\n    if (definition.nearSizes.length > 0) {\n      definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding;\n    }\n  };\n  /**\r\n   * Measure the axis.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.calculateAxisSize = function (rect) {\n    var chart = this.chart;\n    var row;\n    var column;\n    var definition;\n    var axis;\n    var nearCount = 0;\n    var farCount = 0;\n    var size = 0;\n    var x;\n    var y;\n    var axisOffset;\n    this.calculateRowSize(rect);\n\n    for (var i = 0, len = chart.rows.length; i < len; i++) {\n      row = chart.rows[i];\n      nearCount = 0;\n      farCount = 0;\n\n      for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {\n        axis = row.axes[j];\n        axisOffset = axis.plotOffset;\n\n        if (axis.rect.height === 0) {\n          axis.rect.height = row.computedHeight;\n          size = 0;\n\n          for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {\n            definition = chart.rows[k];\n            size += definition.computedHeight;\n          }\n\n          axis.rect.y = row.computedTop - size + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);\n          axis.rect.height = axis.rect.height + size - this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset);\n          axis.rect.width = 0;\n        }\n\n        if (axis.isAxisOpposedPosition) {\n          x = rect.x + rect.width + sum(subArray(row.farSizes, farCount));\n          axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;\n          farCount++;\n        } else {\n          x = rect.x - sum(subArray(row.nearSizes, nearCount));\n          axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;\n          nearCount++;\n        }\n      }\n    }\n\n    this.calculateColumnSize(rect);\n\n    for (var i = 0, len = chart.columns.length; i < len; i++) {\n      column = chart.columns[i];\n      nearCount = 0;\n      farCount = 0;\n\n      for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {\n        axis = column.axes[j];\n        axisOffset = axis.plotOffset;\n\n        if (axis.rect.width === 0) {\n          for (var k = i, len_4 = i + axis.span; k < len_4; k++) {\n            definition = chart.columns[k];\n            axis.rect.width += definition.computedWidth;\n          }\n\n          axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);\n          axis.rect.width -= this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset);\n          axis.rect.height = 0;\n        }\n\n        if (axis.isAxisOpposedPosition) {\n          y = rect.y - sum(subArray(column.farSizes, farCount));\n          axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;\n          farCount++;\n        } else {\n          y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount));\n          axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;\n          nearCount++;\n        }\n      }\n    }\n  };\n  /**\r\n   * Measure the axis.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.measure = function () {\n    var chart = this.chart;\n    var row;\n    var column;\n    var definition;\n    var actualIndex;\n    var span;\n\n    for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n      var axis = _a[_i]; //definition.Axes = axis;\n\n      if (axis.orientation === 'Vertical') {\n        chart.verticalAxes.push(axis);\n        actualIndex = this.getActualRow(axis);\n        row = chart.rows[actualIndex];\n        this.pushAxis(row, axis);\n        span = actualIndex + axis.span > chart.rows.length ? chart.rows.length : actualIndex + axis.span;\n\n        for (var j = actualIndex + 1; j < span; j++) {\n          definition = chart.rows[j];\n          definition.axes[row.axes.length - 1] = axis;\n          chart.rows[j] = definition;\n        }\n\n        chart.rows[actualIndex] = row;\n      } else {\n        chart.horizontalAxes.push(axis);\n        actualIndex = this.getActualColumn(axis);\n        column = chart.columns[actualIndex];\n        this.pushAxis(column, axis);\n        span = actualIndex + axis.span > chart.columns.length ? chart.columns.length : actualIndex + axis.span;\n\n        for (var j = actualIndex + 1; j < span; j++) {\n          definition = chart.columns[j];\n          definition.axes[column.axes.length - 1] = axis;\n          chart.columns[j] = definition;\n        }\n\n        chart.columns[actualIndex] = column;\n      }\n\n      axis.isRTLEnabled = chart.enableRtl;\n      axis.setIsInversedAndOpposedPosition();\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.getAxisOffsetValue = function (position1, position2, plotOffset) {\n    var rangeOffset = position1 ? position1 + (position2 ? position2 : plotOffset) : position2 ? position2 + plotOffset : 2 * plotOffset;\n    return rangeOffset;\n  };\n\n  CartesianAxisLayoutPanel.prototype.crossAt = function (chart) {\n    for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\n      var axis = _a[_i];\n\n      if (axis.crossesAt === null) {\n        continue;\n      }\n\n      if (!axis.crossesInAxis) {\n        if (chart.requireInvertedAxis) {\n          axis.crossInAxis = axis.orientation === 'Horizontal' ? chart.primaryXAxis : chart.primaryYAxis;\n        } else {\n          axis.crossInAxis = axis.orientation === 'Horizontal' ? chart.primaryYAxis : chart.primaryXAxis;\n        }\n\n        axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n        continue;\n      } else {\n        for (var i = 2, len = chart.axisCollections.length; i < len; i++) {\n          if (axis.crossesInAxis === chart.axisCollections[i].name) {\n            axis.crossInAxis = chart.axisCollections[i];\n            axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\n            continue;\n          }\n        }\n      }\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.updateCrossAt = function (axis, crossAt) {\n    switch (axis.valueType) {\n      case 'DateTime':\n        var option = {\n          skeleton: 'full',\n          type: 'dateTime'\n        };\n        var dateParser = this.chart.intl.getDateParser(option);\n        var dateFormatter = this.chart.intl.getDateFormat(option);\n        return Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({\n          val: crossAt\n        }).val))));\n\n      case 'Category':\n        return parseFloat(crossAt) ? parseFloat(crossAt) : axis.labels.indexOf(crossAt);\n\n      case 'Logarithmic':\n        return logBase(crossAt, axis.logBase);\n\n      default:\n        return crossAt;\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.pushAxis = function (definition, axis) {\n    for (var i = 0, len = definition.axes.length; i <= len; i++) {\n      if (!definition.axes[i]) {\n        definition.axes[i] = axis;\n        break;\n      }\n    }\n  };\n\n  CartesianAxisLayoutPanel.prototype.arrangeAxis = function (definition) {\n    var axisCollection = [];\n\n    for (var i = 0, len = definition.axes.length; i <= len; i++) {\n      if (definition.axes[i]) {\n        axisCollection.push(definition.axes[i]);\n      }\n    }\n\n    definition.axes = axisCollection;\n  };\n\n  CartesianAxisLayoutPanel.prototype.getActualColumn = function (axis) {\n    var actualLength = this.chart.columns.length;\n    var pos = axis.columnIndex;\n    var result = pos >= actualLength ? actualLength - 1 : pos < 0 ? 0 : pos;\n    return result;\n  };\n\n  CartesianAxisLayoutPanel.prototype.getActualRow = function (axis) {\n    var actualLength = this.chart.rows.length;\n    var pos = axis.rowIndex;\n    var result = pos >= actualLength ? actualLength - 1 : pos < 0 ? 0 : pos;\n    return result;\n  };\n  /**\r\n   * Measure the row size.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.calculateRowSize = function (rect) {\n    /*! Calculate row size */\n    var chart = this.chart;\n    var row;\n    var rowTop = rect.y + rect.height;\n    var height = 0;\n    var remainingHeight = Math.max(0, rect.height);\n\n    for (var i = 0, len = chart.rows.length; i < len; i++) {\n      row = chart.rows[i];\n\n      if (row.height.indexOf('%') !== -1) {\n        height = Math.min(remainingHeight, rect.height * parseInt(row.height, 10) / 100);\n      } else {\n        height = Math.min(remainingHeight, parseInt(row.height, 10));\n      }\n\n      height = i !== len - 1 ? height : remainingHeight;\n      row.computedHeight = height;\n      rowTop -= height;\n      row.computedTop = rowTop;\n      remainingHeight -= height;\n    }\n  };\n  /**\r\n   * Measure the row size.\r\n   *\r\n   * @param {Rect} rect rect\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.calculateColumnSize = function (rect) {\n    /*! Calculate column size */\n    var chart = this.chart;\n    var column;\n    var columnLeft = rect.x;\n    var width = 0;\n    var remainingWidth = Math.max(0, rect.width);\n\n    for (var i = 0, len = chart.columns.length; i < len; i++) {\n      column = chart.columns[i];\n\n      if (column.width.indexOf('%') !== -1) {\n        width = Math.min(remainingWidth, rect.width * parseInt(column.width, 10) / 100);\n      } else {\n        width = Math.min(remainingWidth, parseInt(column.width, 10));\n      }\n\n      width = i !== len - 1 ? width : remainingWidth;\n      column.computedWidth = width;\n      column.computedLeft = columnLeft;\n      columnLeft += width;\n      remainingWidth -= width;\n    }\n  };\n  /**\r\n   * To render the axis element.\r\n   *\r\n   * @returns {void}\r\n   * @private\r\n   */\n  // tslint:disable-next-line:max-func-body-length\n\n\n  CartesianAxisLayoutPanel.prototype.renderAxes = function () {\n    var chart = this.chart;\n    var axis;\n    var axisElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisInsideCollection'\n    });\n    var axisLineElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisOutsideCollection'\n    });\n    var outsideElement;\n    var isInside;\n\n    for (var i = 0, len = chart.axisCollections.length; i < len; i++) {\n      var axisVisibility = true;\n      axis = chart.axisCollections[i];\n      this.element = chart.renderer.createGroup({\n        id: chart.element.id + 'AxisGroup' + i + 'Inside'\n      });\n      outsideElement = chart.renderer.createGroup({\n        id: chart.element.id + 'AxisGroup' + i + 'Outside'\n      });\n\n      for (var _i = 0, _a = this.chart.series; _i < _a.length; _i++) {\n        var series = _a[_i];\n\n        if (axis.name === series.yAxisName || axis.name === series.xAxisName) {\n          axisVisibility = series.visible;\n\n          if (axisVisibility) {\n            break;\n          } else {\n            continue;\n          }\n        }\n      }\n\n      if (!axisVisibility) {\n        break;\n      }\n\n      isInside = this.findAxisPosition(axis);\n\n      if (axis.orientation === 'Horizontal') {\n        axis.updateCrossValue();\n\n        if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\n          this.drawAxisLine(axis, i, axis.plotOffset, 0, isInside ? outsideElement : this.element, axis.updatedRect);\n        }\n\n        if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {\n          this.drawXAxisGridLine(axis, i, isInside || axis.tickPosition === 'Inside' ? outsideElement : this.element, axis.updatedRect);\n        }\n\n        if (axis.visible && axis.internalVisibility) {\n          this.drawXAxisLabels(axis, i, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n          this.drawXAxisBorder(axis, i, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n          this.drawXAxisTitle(axis, i, isInside ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n        }\n      } else {\n        axis.updateCrossValue();\n\n        if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\n          this.drawAxisLine(axis, i, 0, axis.plotOffset, isInside ? outsideElement : this.element, axis.updatedRect);\n        }\n\n        if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {\n          this.drawYAxisGridLine(axis, i, isInside || axis.tickPosition === 'Inside' ? outsideElement : this.element, axis.updatedRect);\n        }\n\n        if (axis.visible && axis.internalVisibility) {\n          this.drawYAxisLabels(axis, i, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n          this.drawYAxisBorder(axis, i, isInside || axis.labelPosition === 'Inside' ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n          this.drawYAxisTitle(axis, i, isInside ? outsideElement : this.element, axis.placeNextToAxisLine ? axis.updatedRect : axis.rect);\n        }\n      }\n\n      if (!this.chart.enableCanvas) {\n        axisElement.appendChild(this.element);\n\n        if (outsideElement && outsideElement.childNodes.length > 0) {\n          axisLineElement.appendChild(outsideElement);\n        }\n      }\n\n      if (chart.scrollBarModule && (chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming || axis.scrollbarSettings.enable)) {\n        this.renderScrollbar(chart, axis);\n      }\n    }\n\n    this.element = chart.renderer.createGroup({\n      id: chart.element.id + 'DefinitionLine'\n    });\n\n    for (var j = 0, len = chart.rows.length; j < len; j++) {\n      var row = chart.rows[j];\n\n      if (row.border.color) {\n        this.drawBottomLine(row, j, true);\n      }\n    }\n\n    for (var j = 0, len = chart.columns.length; j < len; j++) {\n      var column = chart.columns[j];\n\n      if (column.border.color) {\n        this.drawBottomLine(column, j, false);\n      }\n    }\n\n    if (!this.chart.enableCanvas) {\n      axisElement.appendChild(this.element);\n    }\n\n    appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);\n    return axisLineElement;\n  };\n  /**\r\n   * To render the axis scrollbar\r\n   *\r\n   * @param {Chart} chart chart\r\n   * @param {Axis} axis axis\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.renderScrollbar = function (chart, axis) {\n    var isZoomed = isNullOrUndefined(chart.zoomModule) ? false : chart.zoomModule.isZoomed;\n\n    if ((isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) || axis.scrollbarSettings.enable && (axis.zoomFactor <= 1 || axis.zoomPosition >= 0)) && (!axis.zoomingScrollBar.isScrollUI || chart.visibleSeries[0].type.indexOf('Bar') >= 0)) {\n      if (!chart.scrollElement) {\n        chart.scrollElement = redrawElement(chart.redraw, chart.element.id + '_scrollElement') || createElement('div', {\n          id: chart.element.id + '_scrollElement'\n        });\n      }\n\n      appendChildElement(false, chart.scrollElement, axis.zoomingScrollBar.render(true), true);\n    } else if (axis.zoomFactor === 1 && axis.zoomPosition === 0 && axis.zoomingScrollBar.svgObject && !axis.scrollbarSettings.enable) {\n      axis.zoomingScrollBar.destroy();\n    }\n\n    if (axis.zoomingScrollBar.isScrollUI) {\n      axis.zoomingScrollBar.isScrollUI = false;\n    }\n  };\n  /**\r\n   * To find the axis position\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @returns {boolean} axis position\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.findAxisPosition = function (axis) {\n    return axis.crossAt !== null && axis.isInside(axis.crossInAxis.visibleRange);\n  };\n  /**\r\n   * To render the bootom line of the columns and rows\r\n   *\r\n   * @param {Row | Column} definition definition\r\n   * @param {number} index index\r\n   * @param {boolean} isRow isRow\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawBottomLine = function (definition, index, isRow) {\n    var chart = this.chart;\n    var optionsLine = {};\n    var x1;\n    var x2;\n    var y1;\n    var y2;\n    var definitionName;\n\n    if (isRow) {\n      definition = definition;\n      y1 = y2 = definition.computedTop + definition.computedHeight;\n      x1 = this.seriesClipRect.x;\n      x2 = x1 + this.seriesClipRect.width;\n      definitionName = 'Row';\n    } else {\n      definition = definition;\n      x1 = x2 = definition.computedLeft;\n      y1 = this.seriesClipRect.y;\n      y2 = y1 + this.seriesClipRect.height;\n      definitionName = 'Column';\n    }\n\n    optionsLine = {\n      'id': chart.element.id + '_AxisBottom_' + definitionName + index,\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      'stroke-width': definition.border.width,\n      'stroke': definition.border.color\n    };\n    this.htmlObject = chart.renderer.drawLine(optionsLine);\n    this.element.appendChild(this.htmlObject);\n  };\n  /**\r\n   * To render the axis line\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {number} plotX plotX\r\n   * @param {number} plotY plotY\r\n   * @param {Element} parent parent\r\n   * @param {Rect} rect rect\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawAxisLine = function (axis, index, plotX, plotY, parent, rect) {\n    var chart = this.chart;\n    var optionsLine = {};\n    var element = getElement(chart.element.id + 'AxisLine_' + index);\n    var direction = element ? element.getAttribute('d') : '';\n    element = null;\n    optionsLine = {\n      'id': chart.element.id + 'AxisLine_' + index,\n      'd': 'M ' + (rect.x - plotX) + ' ' + (rect.y - plotY) + ' L ' + (rect.x + rect.width + plotX) + ' ' + (rect.y + rect.height + plotY),\n      'stroke-dasharray': axis.lineStyle.dashArray,\n      'stroke-width': axis.lineStyle.width,\n      'stroke': axis.lineStyle.color || chart.themeStyle.axisLine\n    };\n    this.htmlObject = chart.renderer.drawPath(optionsLine);\n    appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction);\n  };\n  /**\r\n   * To render the yAxis grid line\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {Element} parent parent\r\n   * @param {Rect} rect rect\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawYAxisGridLine = function (axis, index, parent, rect) {\n    var isLogAxis = axis.valueType === 'Logarithmic';\n    var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\n    var tempInterval;\n    var pointY = 0;\n    var majorGrid = '';\n    var majorTick = '';\n    var minorGridDirection;\n    var isOpposed = axis.isAxisOpposedPosition;\n    var tickSize = isOpposed ? axis.majorTickLines.height : -axis.majorTickLines.height;\n    var axisLineSize = isOpposed ? axis.lineStyle.width * 0.5 : -axis.lineStyle.width * 0.5;\n    var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? isOpposed ? axis.scrollBarHeight : -axis.scrollBarHeight : 0;\n    var isTickInside = axis.tickPosition === 'Inside';\n    var ticks = isTickInside ? rect.x - tickSize - axisLineSize : rect.x + tickSize + axisLineSize + scrollBarHeight;\n    var length = axis.visibleLabels.length;\n    var chartThemeStyle = this.chart.themeStyle;\n\n    if (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && length > 0) {\n      length += 1;\n    }\n\n    var minorGridLines = axis.minorGridLines;\n    var minorTickLines = axis.minorTickLines; //Gridlines\n\n    for (var i = 0; i < length; i++) {\n      tempInterval = !axis.visibleLabels[i] ? axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel : axis.visibleLabels[i].value - ticksbwtLabel;\n      pointY = valueToCoefficient(tempInterval, axis) * rect.height;\n      pointY = pointY * -1 + (rect.y + rect.height);\n\n      if (pointY >= rect.y && rect.y + rect.height >= pointY) {\n        if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointY)) {\n          majorGrid = 'M ' + this.seriesClipRect.x + ' ' + pointY + ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointY;\n          this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\n        }\n\n        majorTick = 'M ' + (rect.x + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' ' + pointY + ' L ' + ticks + ' ' + pointY;\n        this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\n\n        if ((minorGridLines.width > 0 || minorTickLines.width > 0) && axis.minorTicksPerInterval > 0) {\n          if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {\n            this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\n          }\n\n          minorGridDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n          this.renderGridLine(axis, index, minorGridDirection[0], minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, minorGridLines.dashArray);\n          this.renderGridLine(axis, index, minorGridDirection[1], minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\n\n          if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {\n            this.renderMinorGridOnZooming(axis, tempInterval + axis.visibleRange.interval, rect, i, index, chartThemeStyle, parent);\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * To check the border of the axis\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {number} value value\r\n   * @returns {boolean} check the border of the axis\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.isBorder = function (axis, index, value) {\n    var border = this.chart.chartArea.border;\n    var rect = this.seriesClipRect;\n    var orientation = axis.orientation;\n    var start = orientation === 'Horizontal' ? rect.x : rect.y;\n    var size = orientation === 'Horizontal' ? rect.width : rect.height;\n    var startIndex = orientation === 'Horizontal' ? 0 : axis.visibleLabels.length - 1;\n    var endIndex = orientation === 'Horizontal' ? axis.visibleLabels.length - 1 : 0;\n\n    if (axis.plotOffset > 0) {\n      return true;\n    } else if ((value === start || value === start + size) && (border.width <= 0 || border.color === 'transparent')) {\n      return true;\n    } else if (value !== start && index === startIndex || value !== start + size && index === endIndex) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * To render the yAxis label\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {Element} parent parent\r\n   * @param {Rect} rect rect\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawYAxisLabels = function (axis, index, parent, rect) {\n    var chart = this.chart;\n    var label;\n    var pointX = 0;\n    var pointY = 0;\n    var elementSize;\n    var labelSpace = axis.labelPadding;\n    var options;\n    var isAxisBreakLabel;\n    var isLabelInside = axis.labelPosition === 'Inside';\n    var isOpposed = axis.isAxisOpposedPosition;\n    var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n    var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\n    var angle = axis.angle % 360;\n    padding = isOpposed ? padding : -padding;\n    var labelElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels' + index\n    });\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight * (isOpposed ? 1 : -1) : 0;\n    var textHeight;\n    var textPadding;\n    var maxLineWidth;\n    var pixel = 10;\n    var isInverse = axis.isAxisInverse;\n    var previousEnd = isInverse ? rect.y : rect.y + rect.height;\n    var labelPadding;\n    var intervalLength;\n    var labelHeight;\n    var yAxisLabelX;\n    var isLabelOnAxisLineLeft = !isOpposed && !isLabelInside || isOpposed && isLabelInside;\n\n    if (isLabelInside) {\n      labelPadding = !isLabelOnAxisLineLeft ? -padding : padding;\n    } else {\n      labelPadding = !isLabelOnAxisLineLeft ? -padding + scrollBarHeight : padding + scrollBarHeight;\n    }\n\n    var sizeWidth = [];\n    var breakLabelSizeWidth = [];\n    axis.visibleLabels.map(function (item) {\n      sizeWidth.push(item.size['width']);\n      breakLabelSizeWidth.push(item.breakLabelSize['width']);\n    });\n    var LabelMaxWidth = Math.max.apply(Math, sizeWidth);\n    var breakLabelMaxWidth = Math.max.apply(Math, breakLabelSizeWidth);\n\n    for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n      label = axis.visibleLabels[i];\n      isAxisBreakLabel = isBreakLabel(axis.visibleLabels[i].originalText);\n      elementSize = isAxisBreakLabel ? axis.visibleLabels[i].breakLabelSize : axis.visibleLabels[i].size;\n      pointY = valueToCoefficient(axis.visibleLabels[i].value, axis) * rect.height + (chart.stockChart ? 7 : 0);\n      pointY = Math.floor(pointY * -1 + (rect.y + rect.height));\n      textHeight = elementSize.height / 8 * axis.visibleLabels[i].text.length / 2;\n      textPadding = elementSize.height / 4 * 3 + 3;\n      intervalLength = rect.height / axis.visibleLabels.length;\n      labelHeight = (axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle !== 0 && elementSize.width > intervalLength ? intervalLength : elementSize.width;\n      pointY = isAxisBreakLabel ? axis.labelPosition === 'Inside' ? pointY - elementSize.height / 2 - textHeight + textPadding : pointY - textHeight : axis.labelPosition === 'Inside' ? pointY + textPadding : pointY;\n\n      if (axis.majorGridLines.width > axis.majorTickLines.width) {\n        maxLineWidth = axis.majorGridLines.width;\n      } else {\n        maxLineWidth = axis.majorTickLines.width;\n      }\n\n      if (axis.labelStyle.textAlignment === 'Far') {\n        pointY = pointY - maxLineWidth - pixel;\n      } else if (axis.labelStyle.textAlignment === 'Near') {\n        pointY = pointY + maxLineWidth + pixel;\n      } else if (axis.labelStyle.textAlignment === 'Center') {\n        // eslint-disable-next-line no-self-assign\n        pointY = pointY;\n      } // label X value adjustment (Start)\n\n\n      if (isLabelInside) {\n        yAxisLabelX = labelPadding + (angle === 0 ? elementSize.width : isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth) / 2;\n      } else {\n        yAxisLabelX = labelPadding - (angle === 0 ? elementSize.width : isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth) / 2;\n      }\n\n      pointX = isOpposed ? rect.x - yAxisLabelX : rect.x + yAxisLabelX;\n      yAxisLabelX = labelPadding;\n      options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, 'middle', label.text, '', 'middle');\n\n      switch (axis.edgeLabelPlacement) {\n        case 'None':\n          break;\n\n        case 'Hide':\n          if ((i === 0 || isInverse && i === len - 1) && options.y > rect.y || (i === len - 1 || isInverse && i === 0) && options.y - elementSize.height * 0.5 < rect.y) {\n            options.text = '';\n          }\n\n          break;\n\n        case 'Shift':\n          if ((i === 0 || isInverse && i === len - 1) && options.y > rect.y) {\n            options.y = pointY = rect.y + rect.height;\n          } else if ((i === len - 1 || isInverse && i === 0) && options.y - elementSize.height * 0.5 < rect.y) {\n            options.y = pointY = rect.y + elementSize.height * 0.5;\n          }\n\n          break;\n      } // ------- Hide Calculation (Start) -------------\n\n\n      var previousYValue = options.y;\n      var currentYValue = options.y - labelHeight;\n\n      if (isAxisBreakLabel) {\n        previousYValue = options.y - labelHeight / 2;\n        currentYValue = options.y + labelHeight / 2;\n      }\n\n      if ((angle === 90 || angle === 270) && axis.labelIntersectAction === 'Hide' && i !== 0 && (!isInverse ? previousYValue >= previousEnd : currentYValue <= previousEnd)) {\n        continue;\n      }\n\n      previousEnd = isInverse ? previousYValue : currentYValue; // ------- Hide Calculation (End) -------------\n\n      options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\n      textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabel, labelElement, false, chart.redraw, true, true, null, null, null, null, chart.enableCanvas);\n    }\n\n    if (!this.chart.enableCanvas) {\n      if (!chart.delayRedraw) {\n        appendChildElement(chart.enableCanvas, parent, labelElement, chart.redraw);\n      } else if (axis.visible && axis.internalVisibility) {\n        this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n      }\n    }\n  };\n  /**\r\n   * To get X value based on lineBreakAlignment for Y axis line break labels only.\r\n   *\r\n   * @param {number} x text x position\r\n   * @param {Axis} axis y axis values\r\n   * @param {number} textWidth axis label width\r\n   * @returns {number} returns suitable axis label x position\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.getAxisLabelXvalue = function (x, axis, textWidth) {\n    var anchor = axis.lineBreakAlignment;\n    var isLabelInside = axis.labelPosition === 'Inside';\n    var isOpposed = axis.isAxisOpposedPosition;\n\n    if (isOpposed && isLabelInside || !isOpposed && !isLabelInside) {\n      return anchor === 'Right' ? x : anchor === 'Center' ? x - textWidth / 2 : x - textWidth;\n    } else {\n      return anchor === 'Left' ? x : anchor === 'Center' ? x + textWidth / 2 : x + textWidth;\n    }\n  };\n  /**\r\n   * To render the yAxis label border.\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {Element} parent parent\r\n   * @param {Rect} rect rect\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawYAxisBorder = function (axis, index, parent, rect) {\n    if (axis.border.width > 0) {\n      var startY = void 0;\n      var pointY = void 0;\n      var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;\n      var isOpposed = axis.isAxisOpposedPosition;\n      scrollBarHeight = (isOpposed ? 1 : -1) * scrollBarHeight;\n      var gap = rect.height / axis.visibleRange.delta * (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval);\n      var endY = void 0;\n      var length_1 = axis.maxLabelSize.width + 10 + (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0);\n      var labelBorder = '';\n      var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? -0.5 : 0;\n      var endX = isOpposed && axis.labelPosition === 'Inside' || !isOpposed && axis.labelPosition === 'Outside' ? rect.x - length_1 + scrollBarHeight : rect.x + length_1 + scrollBarHeight;\n\n      for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n        pointY = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n        pointY = (axis.isAxisInverse ? 1 - pointY : pointY) * rect.height;\n\n        if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n          startY = pointY * -1 + (rect.y + rect.height);\n          endY = pointY * -1 - gap + (rect.y + rect.height);\n        } else {\n          startY = pointY * -1 + gap / 2 + (rect.y + rect.height);\n          endY = pointY * -1 - gap / 2 + (rect.y + rect.height);\n        }\n\n        switch (axis.border.type) {\n          case 'Rectangle':\n          case 'WithoutTopBorder':\n            if (startY > rect.y + rect.height) {\n              labelBorder += 'M' + ' ' + endX + ' ' + (rect.y + rect.height) + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n            } else if (Math.floor(rect.y) > endY) {\n              labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + rect.y + ' ';\n            } else {\n              labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n\n              if (i === axis.visibleLabels.length - 1) {\n                labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n              }\n            }\n\n            break;\n\n          case 'WithoutTopandBottomBorder':\n            if (!(startY > rect.y + rect.height) && !(endY < Math.floor(rect.y))) {\n              labelBorder += 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + startY + ' ' + 'M' + ' ' + endX + ' ' + endY + ' ' + 'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY;\n            }\n\n            break;\n        }\n      }\n\n      labelBorder += axis.border.type === 'Rectangle' ? 'M' + ' ' + (rect.x + scrollBarHeight) + ' ' + rect.y + ' ' + 'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + (rect.y + rect.height) + ' ' : '';\n\n      if (labelBorder !== '') {\n        this.createAxisBorderElement(axis, index, labelBorder, parent);\n      }\n    }\n\n    if (axis.multiLevelLabels.length > 0 && this.chart.multiLevelLabelModule) {\n      this.chart.multiLevelLabelModule.renderYAxisMultiLevelLabels(axis, index, parent, rect);\n    }\n  };\n  /**\r\n   * To render the yAxis title\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {Element} parent parent\r\n   * @param {Rect} rect rect\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawYAxisTitle = function (axis, index, parent, rect) {\n    if (axis.title) {\n      var chart = this.chart;\n      var isOpposed = axis.isAxisOpposedPosition;\n      var labelRotation = isOpposed ? 90 : -90;\n      var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) + (axis.labelPosition === 'Inside' ? 0 : axis.maxLabelSize.width + axis.multiLevelLabelHeight + this.padding);\n      padding = isOpposed ? padding + axis.scrollBarHeight : -padding - axis.scrollBarHeight;\n      var x = rect.x + padding;\n      var y = rect.y + rect.height * 0.5;\n      var titleSize = axis.titleSize.height * (axis.titleCollection.length - 1);\n      var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y - axis.labelPadding - titleSize, 'middle', axis.titleCollection, 'rotate(' + labelRotation + ',' + x + ',' + y + ')', null, labelRotation);\n      var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitle, parent, null, null, null, null, null, null, null, null, chart.enableCanvas);\n      element.setAttribute('tabindex', axis.tabIndex.toString());\n      element.setAttribute('aria-label', axis.description || axis.title);\n    }\n  };\n  /**\r\n   * xAxis grid line calculation performed here\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {Element} parent parent\r\n   * @param {Rect} rect rect\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawXAxisGridLine = function (axis, index, parent, rect) {\n    var isLogAxis = axis.valueType === 'Logarithmic';\n    var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\n    var tempInterval;\n    var pointX = 0;\n    var majorGrid = '';\n    var majorTick = '';\n    var minorDirection;\n    var isOpposed = axis.isAxisOpposedPosition;\n    var tickSize = isOpposed ? -axis.majorTickLines.height : axis.majorTickLines.height;\n    var axisLineSize = isOpposed ? -axis.lineStyle.width * 0.5 : axis.lineStyle.width * 0.5;\n    var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? isOpposed ? -axis.scrollBarHeight : axis.scrollBarHeight : 0;\n    var ticksbwtLabel = axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n    var length = axis.visibleLabels.length;\n    var isTickInside = axis.tickPosition === 'Inside';\n    var ticks = isTickInside ? rect.y - tickSize - axisLineSize : rect.y + tickSize + axisLineSize + scrollBarHeight;\n    var chartThemeStyle = this.chart.themeStyle;\n\n    if (axis.valueType.indexOf('Category') > -1 && length > 0 && axis.labelPlacement === 'BetweenTicks') {\n      length += 1;\n    } //Gridlines\n\n\n    for (var i = 0; i < length; i++) {\n      if (axis.valueType !== 'DateTimeCategory') {\n        tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleLabels[i - 1].value + axis.visibleRange.interval - ticksbwtLabel;\n      } else {\n        tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;\n      }\n\n      pointX = valueToCoefficient(tempInterval, axis) * rect.width + rect.x;\n\n      if (pointX >= rect.x && rect.x + rect.width >= pointX) {\n        if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointX)) {\n          majorGrid = 'M ' + pointX + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) + ' L ' + pointX + ' ' + this.seriesClipRect.y;\n          this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\n        }\n\n        majorTick = 'M ' + pointX + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' L ' + pointX + ' ' + ticks;\n        this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\n\n        if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0)) {\n          if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {\n            this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\n          }\n\n          minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\n          this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);\n          this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\n\n          if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {\n            this.renderMinorGridOnZooming(axis, tempInterval + axis.visibleRange.interval, rect, i, index, chartThemeStyle, parent);\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * To render missing minor grid lines while zooming\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} tempInterval tempInterval\r\n   * @param {Rect} rect rect\r\n   * @param {number} i i\r\n   * @param {number} index index\r\n   * @param {IThemeStyle} chartThemeStyle chartThemeStyle\r\n   * @param {Element} parent parent\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.renderMinorGridOnZooming = function (axis, tempInterval, rect, i, index, chartThemeStyle, parent) {\n    var minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i, true);\n    this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', -1, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);\n    this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', -1, parent, chartThemeStyle.minorTickLine);\n  };\n  /**\r\n   * To calcualte the axis minor line\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} tempInterval tempInterval\r\n   * @param {Rect} rect rect\r\n   * @param {number} labelIndex labelIndex\r\n   * @param {boolean} isFirstLabel isFirstLabel\r\n   * @returns {string[]} axis minor line path\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawAxisMinorLine = function (axis, tempInterval, rect, labelIndex, isFirstLabel) {\n    var value = tempInterval;\n    var coor = 0;\n    var position = 0;\n    var range = axis.visibleRange;\n    var isTickInside = axis.tickPosition === 'Inside';\n    var direction = [];\n    var tickSize = axis.isAxisOpposedPosition ? -axis.minorTickLines.height : axis.minorTickLines.height;\n    var logStart;\n    var logEnd;\n    var logInterval = 1;\n    var logPosition = 1;\n    var ticksX = isTickInside ? rect.y - tickSize : rect.y + tickSize;\n    var ticksY = isTickInside ? rect.x + tickSize : rect.x - tickSize;\n    var minorGird = '';\n    var minorTick = '';\n    var isInverse = axis.isAxisInverse;\n\n    if (axis.valueType === 'Logarithmic') {\n      logStart = Math.pow(axis.logBase, value - range.interval);\n      logEnd = Math.pow(axis.logBase, value);\n      logInterval = (logEnd - logStart) / (axis.minorTicksPerInterval + 1);\n      logPosition = logStart + logInterval;\n    }\n\n    if (axis.orientation === 'Horizontal') {\n      for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n        value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\n        logPosition += logInterval;\n\n        if (inside(value, range)) {\n          position = (value - range.min) / (range.max - range.min);\n          position = Math.ceil((isInverse ? 1 - position : position) * rect.width);\n          coor = Math.floor(position + rect.x);\n          minorGird = minorGird.concat('M' + ' ' + coor + ' ' + this.seriesClipRect.y + 'L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height));\n          coor = Math.floor(position + rect.x);\n          minorTick = minorTick.concat('M' + ' ' + coor + ' ' + rect.y + 'L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\n        }\n      }\n    } else {\n      for (var j = 0; j < axis.minorTicksPerInterval; j++) {\n        value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\n\n        if (inside(value, range)) {\n          position = (value - range.min) / (range.max - range.min);\n          position = Math.ceil((isInverse ? 1 - position : position) * rect.height) * -1; // For inversed axis\n\n          coor = Math.floor(position + rect.y + rect.height);\n          minorGird = minorGird.concat('M' + ' ' + this.seriesClipRect.x + ' ' + coor + 'L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor + ' ');\n          coor = Math.floor(position + rect.y + rect.height);\n          minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + 'L ' + (ticksY - axis.scrollBarHeight) + ' ' + coor + ' ');\n        }\n\n        logPosition += logInterval;\n      }\n    }\n\n    direction.push(minorGird);\n    direction.push(minorTick);\n    return direction;\n  };\n  /**\r\n   * To find the numeric value of the log\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} logPosition logPosition\r\n   * @param {number} value value\r\n   * @param {number} labelIndex labelIndex\r\n   * @param {boolean} isFirstLabel isFirstLabel\r\n   * @returns {number} value\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.findLogNumeric = function (axis, logPosition, value, labelIndex, isFirstLabel) {\n    var range = axis.visibleRange;\n    var tempValue;\n\n    if (axis.valueType === 'Logarithmic') {\n      value = logBase(logPosition, axis.logBase);\n    } else if (axis.valueType === 'DateTime') {\n      tempValue = axis.dateTimeInterval / (axis.minorTicksPerInterval + 1);\n      value = isFirstLabel ? value - tempValue : value + tempValue;\n    } else if (axis.valueType === 'DateTimeCategory') {\n      var padding = axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\n      value += ((axis.visibleLabels[labelIndex + 1] ? axis.visibleLabels[labelIndex + 1].value - padding : axis.visibleRange.max) - (axis.visibleLabels[labelIndex] ? axis.visibleLabels[labelIndex].value - padding : axis.visibleRange.min)) / (axis.minorTicksPerInterval + 1);\n    } else {\n      tempValue = range.interval / (axis.minorTicksPerInterval + 1);\n      value = isFirstLabel ? value - tempValue : value + tempValue;\n    }\n\n    return value;\n  };\n  /**\r\n   * To render the xAxis Labels\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {Element} parent parent\r\n   * @param {Rect} rect rect\r\n   * @returns {void}\r\n   * @private\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawXAxisLabels = function (axis, index, parent, rect) {\n    var chart = this.chart;\n    var pointX = 0;\n    var pointY = 0;\n    var labelSpace = axis.labelPadding;\n    var labelHeight;\n    var elementSize;\n    var labelPadding;\n    var anchor;\n    var pixel = 10;\n    var labelElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels' + index\n    });\n    var islabelInside = axis.labelPosition === 'Inside';\n    var isOpposed = axis.isAxisOpposedPosition;\n    var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\n    var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\n    var angle = axis.angle % 360;\n    var isHorizontalAngle = angle === 0 || angle === -180 || angle === 180;\n    var options;\n    var labelWidth;\n    var isInverse = axis.isAxisInverse;\n    var previousEnd = isInverse ? rect.x + rect.width : rect.x;\n    var width = 0;\n    var length = axis.visibleLabels.length;\n    var intervalLength;\n    var label;\n    var isAxisBreakLabel;\n    var scrollBarHeight = axis.scrollbarSettings.enable || !islabelInside && isNullOrUndefined(axis.crossesAt) && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? axis.scrollBarHeight : 0;\n    var newPoints = [];\n    var isRotatedLabelIntersect = false;\n    padding += angle === 90 || angle === 270 || angle === -90 || angle === -270 ? islabelInside ? 5 : -5 : 0;\n    var isLabelUnderAxisLine = !isOpposed && !islabelInside || isOpposed && islabelInside;\n    var isEndAnchor = isLabelUnderAxisLine ? 360 >= angle && angle >= 180 || -1 >= angle && angle >= -180 : 1 <= angle && angle <= 180 || -181 >= angle && angle >= -360;\n\n    for (var i = 0, len = length; i < len; i++) {\n      label = axis.visibleLabels[i];\n      isAxisBreakLabel = isBreakLabel(label.originalText);\n      pointX = valueToCoefficient(label.value, axis) * rect.width + rect.x;\n      elementSize = label.size;\n      intervalLength = rect.width / length;\n      labelWidth = isAxisBreakLabel ? label.breakLabelSize.width : elementSize.width;\n      width = (axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle === 0 && labelWidth > intervalLength ? intervalLength : labelWidth;\n      labelHeight = elementSize.height / 4;\n      pointX -= isAxisBreakLabel || angle !== 0 ? 0 : width / 2; // label X value adjustment for label rotation (Start)\n\n      if (angle !== 0) {\n        if (isAxisBreakLabel) {\n          pointX -= axis.lineBreakAlignment === 'Left' ? label.breakLabelSize.width / 2 : axis.lineBreakAlignment === 'Right' ? -(label.breakLabelSize.width / 2) : 0;\n        } else {\n          pointX -= angle === -90 || angle === 270 ? -labelHeight : angle === 90 || angle === -270 ? labelHeight : 0;\n        }\n      } // label X value adjustment for label rotation (End)\n\n\n      if (axis.labelStyle.textAlignment === 'Far') {\n        pointX = pointX + width - pixel;\n      } else if (axis.labelStyle.textAlignment === 'Near') {\n        pointX = pointX - width + pixel;\n      } else if (axis.labelStyle.textAlignment === 'Center') {\n        // eslint-disable-next-line no-self-assign\n        pointX = pointX;\n      } // For line break label alignment like left, right & center in angle 0\n\n\n      if (isAxisBreakLabel && axis.lineBreakAlignment !== 'Center' && angle === 0) {\n        pointX += axis.lineBreakAlignment === 'Left' ? -(width / 2) : width / 2;\n      }\n\n      var paddingForBreakLabel = isAxisBreakLabel ? isHorizontalAngle ? elementSize.height : label.breakLabelSize.width / 2 : 0;\n      padding = isAxisBreakLabel ? tickSpace + labelSpace + axis.lineStyle.width * 0.5 : padding; // label Y value adjustment (Start)\n\n      if (islabelInside && angle) {\n        if (isAxisBreakLabel) {\n          pointY = isOpposed ? rect.y + padding + paddingForBreakLabel : rect.y - padding - paddingForBreakLabel;\n        } else {\n          pointY = isOpposed ? rect.y + padding + labelHeight : rect.y - padding - labelHeight;\n        }\n      } else {\n        if (isAxisBreakLabel) {\n          labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + paddingForBreakLabel) : padding + scrollBarHeight + (angle ? paddingForBreakLabel : 3 * labelHeight);\n        } else {\n          labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + (angle ? labelHeight : label.index > 1 ? 2 * labelHeight : 0)) : padding + scrollBarHeight + (angle ? 1 : 3) * labelHeight;\n        }\n\n        pointY = rect.y + labelPadding * label.index;\n      } // label Y value adjustment (End)\n\n\n      if (isAxisBreakLabel) {\n        anchor = this.getAnchor(axis); // for break label self alignment\n      } else {\n        anchor = chart.enableRtl ? isEndAnchor ? '' : 'end' : chart.isRtlEnabled || isEndAnchor ? 'end' : '';\n      }\n\n      options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, anchor);\n\n      if (axis.edgeLabelPlacement && angle === 0) {\n        switch (axis.edgeLabelPlacement) {\n          case 'None':\n            break;\n\n          case 'Hide':\n            if ((i === 0 || isInverse && i === len - 1) && options.x < rect.x || (i === len - 1 || isInverse && i === 0) && options.x + width > rect.x + rect.width) {\n              continue;\n            }\n\n            break;\n\n          case 'Shift':\n            if ((i === 0 || isInverse && i === len - 1) && options.x < rect.x) {\n              intervalLength -= rect.x - options.x;\n              options.x = pointX = rect.x;\n            } else if ((i === len - 1 || isInverse && i === 0) && options.x + width > rect.x + rect.width) {\n              if (elementSize.width > intervalLength && axis.labelIntersectAction === 'Trim') {\n                intervalLength -= options.x + width - (rect.x + rect.width);\n              } else {\n                intervalLength = width;\n              }\n\n              options.x = pointX = rect.x + rect.width - intervalLength;\n            }\n\n            break;\n        }\n      }\n\n      options.text = this.getLabelText(label, axis, intervalLength); // ------- Hide Calculation (Start) -------------\n      // Currect label actual start value (Start)\n\n      var xValue = void 0;\n      var xValue2 = void 0;\n\n      if (isAxisBreakLabel && angle === 0) {\n        if (axis.lineBreakAlignment === 'Right') {\n          xValue = options.x - width;\n          xValue2 = options.x;\n        } else if (axis.lineBreakAlignment === 'Center') {\n          xValue = options.x - width / 2;\n          xValue2 = options.x + width / 2;\n        } else {\n          xValue = options.x;\n          xValue2 = options.x + width;\n        }\n      } else {\n        xValue = options.x;\n        xValue2 = options.x + width;\n      } // Currect label actual start value (End)\n\n\n      if (angle === 0 && axis.labelIntersectAction === 'Hide' && i !== 0 && (!isInverse ? xValue <= previousEnd : xValue2 >= previousEnd)) {\n        continue;\n      } // Previous label actual end value (Start)\n\n\n      if (isAxisBreakLabel) {\n        if (axis.lineBreakAlignment === 'Right') {\n          previousEnd = isInverse ? options.x - width : options.x;\n        } else if (axis.lineBreakAlignment === 'Center') {\n          previousEnd = isInverse ? options.x - width / 2 : options.x + width / 2;\n        } else {\n          previousEnd = isInverse ? options.x : options.x + width;\n        }\n      } else {\n        previousEnd = isInverse ? options.x : options.x + width;\n      } // Previous label actual end value (End)\n      // ------- Hide Calculation (End) -------------\n      // label Rotataion calculation (Start)\n\n\n      if (angle !== 0) {\n        var height = void 0;\n        var rect_1 = void 0;\n\n        if (isAxisBreakLabel) {\n          var xAdjustment = 0;\n          var yAdjustment = 0;\n          height = label.breakLabelSize.height;\n          yAdjustment = label.breakLabelSize.height - 4; // 4 for label bound correction\n          // xAdjustment (Start)\n\n          if (axis.lineBreakAlignment === 'Center') {\n            xAdjustment = -(label.breakLabelSize.width / 2);\n          } else if (axis.lineBreakAlignment === 'Right') {\n            xAdjustment = -label.breakLabelSize.width;\n          } // xAdjustment (End)\n\n\n          if (isLabelUnderAxisLine) {\n            yAdjustment = label.breakLabelSize.height / (options.text.length + 1);\n          }\n\n          rect_1 = new Rect(options.x + xAdjustment, options.y - yAdjustment, label.breakLabelSize.width, height);\n        } else {\n          height = pointY - (options.y - (label.size.height / 2 + 10));\n          rect_1 = new Rect(options.x, options.y - (label.size.height / 2 - 5), label.size.width, height);\n        }\n\n        var rectCoordinates = this.getRectanglePoints(rect_1);\n        var rectCenterX = isAxisBreakLabel ? rect_1.x + rect_1.width / 2 : pointX;\n        var rectCenterY = isAxisBreakLabel ? rect_1.y + rect_1.height / 2 : pointY - height / 2;\n\n        if (isAxisBreakLabel) {\n          options.transform = 'rotate(' + angle + ',' + rectCenterX + ',' + rectCenterY + ')';\n        } else {\n          options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\n        }\n\n        newPoints.push(getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle));\n        isRotatedLabelIntersect = false;\n\n        for (var index_1 = i; index_1 > 0; index_1--) {\n          if (newPoints[i] && newPoints[index_1 - 1] && isRotatedRectIntersect(newPoints[i], newPoints[index_1 - 1])) {\n            isRotatedLabelIntersect = true;\n            newPoints[i] = null;\n            break;\n          }\n        }\n      } // label Rotataion calculation (End)\n\n\n      textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabel, labelElement, axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside'), chart.redraw, true, null, null, null, label.size, isRotatedLabelIntersect, chart.enableCanvas);\n    }\n\n    if (!this.chart.enableCanvas) {\n      if (!chart.delayRedraw) {\n        parent.appendChild(labelElement);\n      } else if (axis.visible && axis.internalVisibility) {\n        this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\n      }\n    }\n  };\n  /**\r\n   * To get text anchor value for line break labels.\r\n   *\r\n   * @param {Axis} axis axis model\r\n   * @returns {string} returns text anchor\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.getAnchor = function (axis) {\n    return axis.lineBreakAlignment === 'Center' ? 'middle' : this.chart.enableRtl ? axis.lineBreakAlignment === 'Left' ? 'end' : 'start' : axis.lineBreakAlignment === 'Left' ? 'start' : 'end';\n  };\n  /**\r\n   * Get rect coordinates\r\n   *\r\n   * @param {Rect} rect rect\r\n   * @returns {ChartLocation[]} rectangle points\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.getRectanglePoints = function (rect) {\n    var point1 = new ChartLocation(rect.x, rect.y);\n    var point2 = new ChartLocation(rect.x + rect.width, rect.y);\n    var point3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\n    var point4 = new ChartLocation(rect.x, rect.y + rect.height);\n    return [point1, point2, point3, point4];\n  };\n  /**\r\n   * To get axis label text\r\n   *\r\n   * @param {VisibleLabels} label label\r\n   * @param {Axis} axis axis\r\n   * @param {number} intervalLength intervalLength\r\n   * @returns {string | string[]} label or label collection\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.getLabelText = function (label, axis, intervalLength) {\n    if (isBreakLabel(label.originalText)) {\n      var result = [];\n      var str = void 0;\n\n      for (var index = 0; index < label.text.length; index++) {\n        str = this.findAxisLabel(axis, label.text[index], intervalLength);\n        result.push(str);\n      }\n\n      return result;\n    } else {\n      return this.findAxisLabel(axis, label.text, intervalLength);\n    }\n  };\n  /**\r\n   * To render the x-axis label border.\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {Element} parent parent\r\n   * @param {Rect} axisRect axisRect\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawXAxisBorder = function (axis, index, parent, axisRect) {\n    if (axis.border.width > 0) {\n      var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;\n      var isOpposed = axis.isAxisOpposedPosition;\n      var startX = void 0;\n      var startY = axisRect.y + (isOpposed ? -1 : 1) * scrollBarHeight;\n      var padding = 10;\n      var pointX = void 0;\n      var gap = axisRect.width / axis.visibleRange.delta * (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval);\n      var endX = void 0;\n      var length_2 = axis.maxLabelSize.height + (axis.tickPosition === axis.labelPosition ? axis.majorTickLines.height : 0);\n      var labelBorder = '';\n      var ticksbwtLabel = axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks' ? -0.5 : 0;\n      var endY = isOpposed && axis.labelPosition === 'Inside' || !isOpposed && axis.labelPosition === 'Outside' ? axisRect.y + length_2 + padding + scrollBarHeight : axisRect.y - length_2 - padding - scrollBarHeight;\n\n      for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\n        pointX = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\n        pointX = (axis.isAxisInverse ? 1 - pointX : pointX) * axisRect.width;\n\n        if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\n          startX = pointX + axisRect.x;\n          endX = pointX + gap + axisRect.x;\n        } else {\n          startX = pointX - gap * 0.5 + axisRect.x;\n          endX = pointX + gap * 0.5 + axisRect.x;\n        }\n\n        switch (axis.border.type) {\n          case 'Rectangle':\n          case 'WithoutTopBorder':\n            if (startX < axisRect.x) {\n              labelBorder += 'M' + ' ' + axisRect.x + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n            } else if (Math.floor(endX) > axisRect.width + axisRect.x && !(axis.visibleLabels.length === 1)) {\n              labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'L' + ' ' + (axisRect.width + axisRect.x) + ' ' + endY + ' ';\n            } else {\n              labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ';\n\n              if (i === 0) {\n                labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'M ' + startX + ' ' + endY + ' L ' + axisRect.x + ' ' + endY;\n              }\n\n              if (i === axis.visibleLabels.length - 1) {\n                labelBorder += 'M' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ' + 'M ' + endX + ' ' + endY + ' L ' + (axisRect.width + axisRect.x) + ' ' + endY;\n              }\n            }\n\n            break;\n\n          case 'WithoutTopandBottomBorder':\n            if (!(startX < axisRect.x) && !(Math.floor(endX) > axisRect.width + axisRect.x)) {\n              labelBorder += 'M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' + 'M ' + endX + ' ' + startY + ' L ' + endX + ' ' + endY;\n            }\n\n            break;\n        }\n      }\n\n      labelBorder += axis.border.type === 'Rectangle' ? 'M ' + ' ' + axisRect.x + ' ' + startY + 'L' + ' ' + (axisRect.x + axisRect.width) + ' ' + startY : '';\n\n      if (labelBorder !== '') {\n        this.createAxisBorderElement(axis, index, labelBorder, parent);\n      }\n    }\n\n    if (this.chart.multiLevelLabelModule && axis.multiLevelLabels.length > 0) {\n      this.chart.multiLevelLabelModule.renderXAxisMultiLevelLabels(axis, index, parent, axisRect);\n    }\n  };\n  /**\r\n   * To create border element of the axis\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {string} labelBorder labelBorder\r\n   * @param {Element} parent parent\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.createAxisBorderElement = function (axis, index, labelBorder, parent) {\n    var element = getElement(this.chart.element.id + '_BorderLine_' + index);\n    var direction = element ? element.getAttribute('d') : '';\n    var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + '_BorderLine_' + index, 'transparent', axis.border.width, axis.border.color || this.chart.themeStyle.axisLine, 1, '', labelBorder));\n    borderElement.style.pointerEvents = 'none';\n    appendChildElement(this.chart.enableCanvas, parent, borderElement, this.chart.redraw, true, 'x', 'y', null, direction, true);\n  };\n  /**\r\n   * To find the axis label of the intersect action\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {string} label label\r\n   * @param {number} width width\r\n   * @returns {string} label\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.findAxisLabel = function (axis, label, width) {\n    return axis.labelIntersectAction === 'Trim' ? axis.angle % 360 === 0 && !axis.enableTrim ? textTrim(width, label, axis.labelStyle) : label : label;\n  };\n  /**\r\n   * X-Axis Title function performed\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {Element} parent parent\r\n   * @param {Rect} rect rect\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.drawXAxisTitle = function (axis, index, parent, rect) {\n    if (axis.title) {\n      var chart = this.chart;\n      var elementSize = measureText(axis.title, axis.titleStyle);\n      var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;\n      var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) + (axis.labelPosition === 'Inside' ? 0 : axis.maxLabelSize.height + axis.multiLevelLabelHeight + axis.labelPadding);\n      var titleSize = axis.titleSize.height * (axis.titleCollection.length - 1);\n      padding = axis.isAxisOpposedPosition ? -(padding + elementSize.height / 4 + scrollBarHeight + titleSize) : padding + 3 * elementSize.height / 4 + scrollBarHeight;\n      var options = new TextOption(chart.element.id + '_AxisTitle_' + index, rect.x + rect.width * 0.5, rect.y + padding, 'middle', axis.titleCollection);\n      var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitle, parent, null, null, null, null, null, null, null, null, chart.enableCanvas);\n      element.setAttribute('aria-label', axis.description || axis.title);\n      element.setAttribute('tabindex', axis.tabIndex.toString());\n    }\n  };\n  /**\r\n   * To render the axis grid and tick lines(Both Major and Minor)\r\n   *\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {string} gridDirection gridDirection\r\n   * @param {MajorTickLinesModel | MinorTickLinesModel | MajorGridLinesModel | MinorGridLinesModel} gridModel gridModel\r\n   * @param {string} gridId gridId\r\n   * @param {number} gridIndex gridIndex\r\n   * @param {Element} parent parent\r\n   * @param {string} themeColor themeColor\r\n   * @param {string} dashArray dashArray\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.renderGridLine = function (axis, index, gridDirection, gridModel, gridId, gridIndex, parent, themeColor, dashArray) {\n    if (dashArray === void 0) {\n      dashArray = null;\n    }\n\n    var chart = this.chart;\n    var direction;\n    var element;\n\n    if (gridModel.width > 0 && axis.visible && axis.internalVisibility && gridDirection) {\n      element = getElement(chart.element.id + gridId + index + '_' + gridIndex);\n      direction = element ? element.getAttribute('d') : null;\n      element = null;\n      this.htmlObject = chart.renderer.drawPath(new PathOption(chart.element.id + gridId + index + '_' + gridIndex, 'transparent', gridModel.width, gridModel.color || themeColor, null, dashArray, gridDirection));\n      appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, true);\n    }\n  };\n  /**\r\n   * To Find the parent node of the axis\r\n   *\r\n   * @param {string} elementId elementId\r\n   * @param {Element} label label\r\n   * @param {number} index index\r\n   * @returns {Element} parent node of the axis\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.findParentNode = function (elementId, label, index) {\n    if (document.getElementById(elementId + 'AxisGroup' + index + 'Inside').contains(document.getElementById(label.id))) {\n      return document.getElementById(elementId + 'AxisGroup' + index + 'Inside');\n    } else {\n      return document.getElementById(elementId + 'AxisGroup' + index + 'Outside');\n    }\n  };\n  /**\r\n   * Create Zooming Labels Function Called here\r\n   *\r\n   * @param {Chart} chart chart\r\n   * @param {Element} labelElement labelElement\r\n   * @param {Axis} axis axis\r\n   * @param {number} index index\r\n   * @param {Rect} rect rect\r\n   * @returns {void}\r\n   */\n\n\n  CartesianAxisLayoutPanel.prototype.createZoomingLabel = function (chart, labelElement, axis, index, rect) {\n    var parentNode = this.findParentNode(chart.element.id, labelElement, index);\n    labelElement.setAttribute('opacity', '0.3');\n    var zoomElement = chart.renderer.createGroup({\n      id: chart.element.id + 'AxisLabels_Zoom' + index\n    });\n    zoomElement = createZoomingLabels(chart, axis, zoomElement, index, axis.orientation === 'Vertical', rect);\n    parentNode.replaceChild(labelElement, document.getElementById(labelElement.id));\n\n    if (getElement(chart.element.id + 'AxisLabels_Zoom' + index)) {\n      parentNode.replaceChild(zoomElement, document.getElementById(zoomElement.id));\n    } else {\n      parentNode.appendChild(zoomElement);\n    }\n  };\n\n  return CartesianAxisLayoutPanel;\n}();\n\nexport { CartesianAxisLayoutPanel };","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/@syncfusion/ej2-react-charts/node_modules/@syncfusion/ej2-charts/src/chart/axis/cartesian-panel.js"],"names":["createElement","isNullOrUndefined","DataUtil","subtractThickness","valueToCoefficient","sum","redrawElement","isBreakLabel","ChartLocation","subArray","inside","appendChildElement","stringToNumber","Thickness","logBase","createZoomingLabels","getElement","Size","Rect","measureText","TextOption","PathOption","textElement","textTrim","getRotatedRectangleCoordinates","isRotatedRectIntersect","isZoomSet","axisPadding","CartesianAxisLayoutPanel","chartModule","chart","padding","prototype","measureAxis","rect","chartAreaWidth","chartArea","width","availableSize","crossAt","seriesClipRect","x","y","height","initialClipRect","leftSize","rightSize","topSize","bottomSize","measureRowAxis","measureColumnAxis","delayRedraw","calculateAxisSize","calculateFixedChartArea","refreshAxis","margin","right","legendSettings","position","legendModule","legendBounds","_i","_a","rows","length","item","farSizes","row","calculateRowSize","nearSizes","arrangeAxis","measureDefinition","computedHeight","column","calculateColumnSize","columns","computedWidth","definition","size","ele","axes","axis","scrollBarHeight","scrollBarModule","zoomModule","zoomSettings","enableScrollbar","enableScrollbarOnZooming","isZoomed","zoomFactor","zoomPosition","scrollbarSettings","enable","getModule","baseModule","calculateRangeAndInterval","computeSize","nearCount","farCount","axisOffset","i","len","j","len_1","plotOffset","k","len_2","span","computedTop","plotOffsetTop","getAxisOffsetValue","plotOffsetBottom","isAxisOpposedPosition","len_3","len_4","computedLeft","plotOffsetLeft","plotOffsetRight","measure","actualIndex","axisCollections","orientation","verticalAxes","push","getActualRow","pushAxis","horizontalAxes","getActualColumn","isRTLEnabled","enableRtl","setIsInversedAndOpposedPosition","position1","position2","rangeOffset","crossesAt","crossesInAxis","requireInvertedAxis","crossInAxis","primaryXAxis","primaryYAxis","updateCrossAt","name","valueType","option","skeleton","type","dateParser","intl","getDateParser","dateFormatter","getDateFormat","Date","parse","parseJson","val","parseFloat","labels","indexOf","axisCollection","actualLength","pos","columnIndex","result","rowIndex","rowTop","remainingHeight","Math","max","min","parseInt","columnLeft","remainingWidth","renderAxes","axisElement","renderer","createGroup","id","element","axisLineElement","outsideElement","isInside","axisVisibility","series","yAxisName","xAxisName","visible","findAxisPosition","updateCrossValue","internalVisibility","lineStyle","drawAxisLine","updatedRect","majorGridLines","majorTickLines","drawXAxisGridLine","tickPosition","drawXAxisLabels","labelPosition","placeNextToAxisLine","drawXAxisBorder","drawXAxisTitle","drawYAxisGridLine","drawYAxisLabels","drawYAxisBorder","drawYAxisTitle","enableCanvas","appendChild","childNodes","renderScrollbar","border","color","drawBottomLine","svgObject","redraw","zoomingScrollBar","isScrollUI","visibleSeries","scrollElement","render","destroy","visibleRange","index","isRow","optionsLine","x1","x2","y1","y2","definitionName","htmlObject","drawLine","plotX","plotY","parent","direction","getAttribute","dashArray","themeStyle","axisLine","drawPath","isLogAxis","isCategoryAxis","tempInterval","pointY","majorGrid","majorTick","minorGridDirection","isOpposed","tickSize","axisLineSize","ticksbwtLabel","labelPlacement","isTickInside","ticks","visibleLabels","chartThemeStyle","minorGridLines","minorTickLines","value","interval","isBorder","renderGridLine","majorGridLine","majorTickLine","minorTicksPerInterval","renderMinorGridOnZooming","drawAxisMinorLine","minorGridLine","minorTickLine","start","startIndex","endIndex","label","pointX","elementSize","labelSpace","labelPadding","options","isAxisBreakLabel","isLabelInside","tickSpace","angle","labelElement","textHeight","textPadding","maxLineWidth","pixel","isInverse","isAxisInverse","previousEnd","intervalLength","labelHeight","yAxisLabelX","isLabelOnAxisLineLeft","sizeWidth","breakLabelSizeWidth","map","breakLabelSize","LabelMaxWidth","apply","breakLabelMaxWidth","originalText","stockChart","floor","text","labelIntersectAction","labelStyle","textAlignment","edgeLabelPlacement","previousYValue","currentYValue","transform","axisLabel","createZoomingLabel","getAxisLabelXvalue","textWidth","anchor","lineBreakAlignment","startY","gap","delta","dateTimeInterval","endY","length_1","maxLabelSize","labelBorder","endX","createAxisBorderElement","multiLevelLabels","multiLevelLabelModule","renderYAxisMultiLevelLabels","title","labelRotation","titlePadding","multiLevelLabelHeight","titleSize","titleCollection","titleStyle","axisTitle","setAttribute","tabIndex","toString","description","minorDirection","labelIndex","isFirstLabel","coor","range","logStart","logEnd","logInterval","logPosition","ticksX","ticksY","minorGird","minorTick","pow","findLogNumeric","ceil","concat","tempValue","islabelInside","isHorizontalAngle","labelWidth","newPoints","isRotatedLabelIntersect","isLabelUnderAxisLine","isEndAnchor","paddingForBreakLabel","getAnchor","isRtlEnabled","getLabelText","xValue","xValue2","rect_1","xAdjustment","yAdjustment","rectCoordinates","getRectanglePoints","rectCenterX","rectCenterY","index_1","point1","point2","point3","point4","str","findAxisLabel","axisRect","startX","length_2","renderXAxisMultiLevelLabels","borderElement","style","pointerEvents","enableTrim","gridDirection","gridModel","gridId","gridIndex","themeColor","findParentNode","elementId","document","getElementById","contains","parentNode","zoomElement","replaceChild"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,iBAAxB,QAAiD,sBAAjD;AACA,SAASC,QAAT,QAAyB,sBAAzB;AACA,SAASC,iBAAT,EAA4BC,kBAA5B,EAAgDC,GAAhD,EAAqDC,aAArD,EAAoEC,YAApE,EAAkFC,aAAlF,QAAuG,2BAAvG;AACA,SAASC,QAAT,EAAmBC,MAAnB,EAA2BC,kBAA3B,EAA+CC,cAA/C,QAAqE,2BAArE;AACA,SAASC,SAAT,EAAoBC,OAApB,EAA6BC,mBAA7B,EAAkDC,UAAlD,QAAoE,2BAApE;AACA,SAASC,IAAT,EAAeC,IAAf,EAAqBC,WAArB,EAAkCC,UAAlC,EAA8CC,UAA9C,QAAgE,0BAAhE;AACA,SAASC,WAAT,EAAsBC,QAAtB,EAAgCC,8BAAhC,EAAgEC,sBAAhE,EAAwFC,SAAxF,QAAyG,2BAAzG;AACA;AACA;AACA;;AACA,IAAIC,WAAW,GAAG,EAAlB;;AACA,IAAIC,wBAAwB;AAAG;AAAe,YAAY;AACtD;AACA,WAASA,wBAAT,CAAkCC,WAAlC,EAA+C;AAC3C,SAAKC,KAAL,GAAaD,WAAb;AACA,SAAKE,OAAL,GAAe,CAAf;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIH,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCC,WAAnC,GAAiD,UAAUC,IAAV,EAAgB;AAC7D,QAAIJ,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIK,cAAc,GAAGL,KAAK,CAACM,SAAN,CAAgBC,KAAhB,GAAwBzB,cAAc,CAACkB,KAAK,CAACM,SAAN,CAAgBC,KAAjB,EAAwBP,KAAK,CAACQ,aAAN,CAAoBD,KAA5C,CAAtC,GAA2F,IAAhH;AACA,SAAKE,OAAL,CAAaT,KAAb;AACA,SAAKU,cAAL,GAAsB,IAAItB,IAAJ,CAASgB,IAAI,CAACO,CAAd,EAAiBP,IAAI,CAACQ,CAAtB,EAAyBR,IAAI,CAACG,KAA9B,EAAqCH,IAAI,CAACS,MAA1C,CAAtB;AACA,SAAKC,eAAL,GAAuBV,IAAvB;AACA,SAAKW,QAAL,GAAgB,CAAhB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKC,OAAL,GAAe,CAAf;AACA,SAAKC,UAAL,GAAkB,CAAlB,CAT6D,CAU7D;;AACA,SAAKC,cAAL,CAAoBnB,KAApB,EAA2B,KAAKc,eAAhC;AACA,SAAKA,eAAL,GAAuBzC,iBAAiB,CAAC,KAAKyC,eAAN,EAAuB,IAAI/B,SAAJ,CAAc,KAAKgC,QAAnB,EAA6B,KAAKC,SAAlC,EAA6C,CAA7C,EAAgD,CAAhD,CAAvB,CAAxC;AACA,SAAKI,iBAAL,CAAuBpB,KAAvB,EAA8B,KAAKc,eAAnC;AACA,SAAKA,eAAL,GAAuBzC,iBAAiB,CAAC,KAAKyC,eAAN,EAAuB,IAAI/B,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,KAAKkC,OAAzB,EAAkC,KAAKC,UAAvC,CAAvB,CAAxC;;AACA,QAAI,CAAC,KAAKlB,KAAL,CAAWqB,WAAhB,EAA6B;AACzB,WAAKC,iBAAL,CAAuB,KAAKR,eAA5B;AACH;;AACD,SAAKC,QAAL,GAAgB,CAAhB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKC,OAAL,GAAe,CAAf;AACA,SAAKC,UAAL,GAAkB,CAAlB,CArB6D,CAsB7D;;AACA,SAAKC,cAAL,CAAoBnB,KAApB,EAA2B,KAAKc,eAAhC;AACA,SAAKJ,cAAL,GAAsBrC,iBAAiB,CAAC,KAAKqC,cAAN,EAAsB,IAAI3B,SAAJ,CAAc,KAAKgC,QAAnB,EAA6B,KAAKC,SAAlC,EAA6C,CAA7C,EAAgD,CAAhD,CAAtB,CAAvC;AACA,SAAKI,iBAAL,CAAuBpB,KAAvB,EAA8B,KAAKc,eAAnC;AACA,SAAKJ,cAAL,GAAsBrC,iBAAiB,CAAC,KAAKqC,cAAN,EAAsB,IAAI3B,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,KAAKkC,OAAzB,EAAkC,KAAKC,UAAvC,CAAtB,CAAvC;;AACA,QAAIb,cAAJ,EAAoB;AAChB,WAAKkB,uBAAL,CAA6BvB,KAA7B,EAAoCK,cAApC;AACH;;AACD,QAAI,CAAC,KAAKL,KAAL,CAAWqB,WAAhB,EAA6B;AACzBrB,MAAAA,KAAK,CAACwB,WAAN;AACA,WAAKF,iBAAL,CAAuB,KAAKZ,cAA5B;AACH;AACJ,GAlCD;;AAmCAZ,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCqB,uBAAnC,GAA6D,UAAUvB,KAAV,EAAiBK,cAAjB,EAAiC;AAC1F,SAAKK,cAAL,CAAoBH,KAApB,GAA4BF,cAA5B;AACA,SAAKK,cAAL,CAAoBC,CAApB,GAAwBX,KAAK,CAACQ,aAAN,CAAoBD,KAApB,GAA4BP,KAAK,CAACyB,MAAN,CAAaC,KAAzC,GAAiDrB,cAAjD,IACnBL,KAAK,CAAC2B,cAAN,CAAqBC,QAArB,KAAkC,OAAlC,GAA4C5B,KAAK,CAAC6B,YAAN,CAAmBC,YAAnB,CAAgCvB,KAA5E,GAAoF,CADjE,CAAxB;;AAEA,SAAK,IAAIwB,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGhC,KAAK,CAACiC,IAA5B,EAAkCF,EAAE,GAAGC,EAAE,CAACE,MAA1C,EAAkDH,EAAE,EAApD,EAAwD;AACpD,UAAII,IAAI,GAAGH,EAAE,CAACD,EAAD,CAAb;AACA,WAAKrB,cAAL,CAAoBC,CAApB,IAAyBpC,GAAG,CAAC4D,IAAI,CAACC,QAAN,CAA5B;AACH;AACJ,GARD;;AASAtC,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCiB,cAAnC,GAAoD,UAAUnB,KAAV,EAAiBI,IAAjB,EAAuB;AACvE,QAAIiC,GAAJ;AACA,SAAKC,gBAAL,CAAsBlC,IAAtB;;AACA,SAAK,IAAI2B,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGhC,KAAK,CAACiC,IAA5B,EAAkCF,EAAE,GAAGC,EAAE,CAACE,MAA1C,EAAkDH,EAAE,EAApD,EAAwD;AACpD,UAAII,IAAI,GAAGH,EAAE,CAACD,EAAD,CAAb;AACAM,MAAAA,GAAG,GAAGF,IAAN;AACAE,MAAAA,GAAG,CAACE,SAAJ,GAAgB,EAAhB;AACAF,MAAAA,GAAG,CAACD,QAAJ,GAAe,EAAf;AACA,WAAKI,WAAL,CAAiBH,GAAjB;AACA,WAAKI,iBAAL,CAAuBJ,GAAvB,EAA4BrC,KAA5B,EAAmC,IAAIb,IAAJ,CAASa,KAAK,CAACQ,aAAN,CAAoBD,KAA7B,EAAoC8B,GAAG,CAACK,cAAxC,CAAnC;;AACA,UAAI,KAAK3B,QAAL,GAAgBxC,GAAG,CAAC8D,GAAG,CAACE,SAAL,CAAvB,EAAwC;AACpC,aAAKxB,QAAL,GAAgBxC,GAAG,CAAC8D,GAAG,CAACE,SAAL,CAAnB;AACH;;AACD,UAAI,KAAKvB,SAAL,GAAiBzC,GAAG,CAAC8D,GAAG,CAACD,QAAL,CAAxB,EAAwC;AACpC,aAAKpB,SAAL,GAAiBzC,GAAG,CAAC8D,GAAG,CAACD,QAAL,CAApB;AACH;AACJ;AACJ,GAjBD;;AAkBAtC,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCkB,iBAAnC,GAAuD,UAAUpB,KAAV,EAAiBI,IAAjB,EAAuB;AAC1E,QAAIuC,MAAJ;AACA,SAAKC,mBAAL,CAAyBxC,IAAzB;;AACA,SAAK,IAAI2B,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGhC,KAAK,CAAC6C,OAA5B,EAAqCd,EAAE,GAAGC,EAAE,CAACE,MAA7C,EAAqDH,EAAE,EAAvD,EAA2D;AACvD,UAAII,IAAI,GAAGH,EAAE,CAACD,EAAD,CAAb;AACAY,MAAAA,MAAM,GAAGR,IAAT;AACAQ,MAAAA,MAAM,CAACP,QAAP,GAAkB,EAAlB;AACAO,MAAAA,MAAM,CAACJ,SAAP,GAAmB,EAAnB;AACA,WAAKC,WAAL,CAAiBG,MAAjB;AACA,WAAKF,iBAAL,CAAuBE,MAAvB,EAA+B3C,KAA/B,EAAsC,IAAIb,IAAJ,CAASwD,MAAM,CAACG,aAAhB,EAA+B9C,KAAK,CAACQ,aAAN,CAAoBK,MAAnD,CAAtC;;AACA,UAAI,KAAKK,UAAL,GAAkB3C,GAAG,CAACoE,MAAM,CAACJ,SAAR,CAAzB,EAA6C;AACzC,aAAKrB,UAAL,GAAkB3C,GAAG,CAACoE,MAAM,CAACJ,SAAR,CAArB;AACH;;AACD,UAAI,KAAKtB,OAAL,GAAe1C,GAAG,CAACoE,MAAM,CAACP,QAAR,CAAtB,EAAyC;AACrC,aAAKnB,OAAL,GAAe1C,GAAG,CAACoE,MAAM,CAACP,QAAR,CAAlB;AACH;AACJ;AACJ,GAjBD;AAkBA;AACJ;AACA;AACA;AACA;AACA;;;AACItC,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCuC,iBAAnC,GAAuD,UAAUM,UAAV,EAAsB/C,KAAtB,EAA6BgD,IAA7B,EAAmC;AACtF,QAAIC,GAAG,GAAG,EAAV,CADsF,CACxE;;AACd,SAAK,IAAIlB,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGe,UAAU,CAACG,IAAjC,EAAuCnB,EAAE,GAAGC,EAAE,CAACE,MAA/C,EAAuDH,EAAE,EAAzD,EAA6D;AACzD,UAAIoB,IAAI,GAAGnB,EAAE,CAACD,EAAD,CAAb;AACAoB,MAAAA,IAAI,CAACC,eAAL,GAAuBpD,KAAK,CAACqD,eAAN,IAAyBrD,KAAK,CAACsD,UAA/B,IAA6CtD,KAAK,CAACuD,YAAN,CAAmBC,eAAhE,IACnBL,IAAI,CAACM,wBADc,IACczD,KAAK,CAACsD,UAAN,CAAiBI,QAD/B,KAC4CP,IAAI,CAACQ,UAAL,GAAkB,CAAlB,IAAuBR,IAAI,CAACS,YAAL,GAAoB,CADvF,IAC4FX,GAD5F,GACkG,CADzH;AAEAE,MAAAA,IAAI,CAACC,eAAL,GAAuBpD,KAAK,CAACqD,eAAN,KAA0BrD,KAAK,CAACsD,UAAN,IAAoBtD,KAAK,CAACuD,YAAN,CAAmBC,eAAvC,IAC7CL,IAAI,CAACM,wBADwC,IACZzD,KAAK,CAACsD,UAAN,CAAiBI,QADL,KACkBP,IAAI,CAACQ,UAAL,GAAkB,CAAlB,IAAuBR,IAAI,CAACS,YAAL,GAAoB,CAD7D,KAE1CT,IAAI,CAACU,iBAAL,CAAuBC,MAFP,IAEiBb,GAFjB,GAEuB,CAF9C;AAGAE,MAAAA,IAAI,CAACY,SAAL,CAAe/D,KAAf;AACAmD,MAAAA,IAAI,CAACa,UAAL,CAAgBC,yBAAhB,CAA0CjB,IAA1C,EAAgDG,IAAhD;AACAJ,MAAAA,UAAU,CAACmB,WAAX,CAAuBf,IAAvB,EAA6BA,IAAI,CAACC,eAAlC;AACH;;AACD,QAAIL,UAAU,CAACX,QAAX,CAAoBF,MAApB,GAA6B,CAAjC,EAAoC;AAChCa,MAAAA,UAAU,CAACX,QAAX,CAAoBW,UAAU,CAACX,QAAX,CAAoBF,MAApB,GAA6B,CAAjD,KAAuDrC,WAAvD;AACH;;AACD,QAAIkD,UAAU,CAACR,SAAX,CAAqBL,MAArB,GAA8B,CAAlC,EAAqC;AACjCa,MAAAA,UAAU,CAACR,SAAX,CAAqBQ,UAAU,CAACR,SAAX,CAAqBL,MAArB,GAA8B,CAAnD,KAAyDrC,WAAzD;AACH;AACJ,GAnBD;AAoBA;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCoB,iBAAnC,GAAuD,UAAUlB,IAAV,EAAgB;AACnE,QAAIJ,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIqC,GAAJ;AACA,QAAIM,MAAJ;AACA,QAAII,UAAJ;AACA,QAAII,IAAJ;AACA,QAAIgB,SAAS,GAAG,CAAhB;AACA,QAAIC,QAAQ,GAAG,CAAf;AACA,QAAIpB,IAAI,GAAG,CAAX;AACA,QAAIrC,CAAJ;AACA,QAAIC,CAAJ;AACA,QAAIyD,UAAJ;AACA,SAAK/B,gBAAL,CAAsBlC,IAAtB;;AACA,SAAK,IAAIkE,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGvE,KAAK,CAACiC,IAAN,CAAWC,MAAjC,EAAyCoC,CAAC,GAAGC,GAA7C,EAAkDD,CAAC,EAAnD,EAAuD;AACnDjC,MAAAA,GAAG,GAAGrC,KAAK,CAACiC,IAAN,CAAWqC,CAAX,CAAN;AACAH,MAAAA,SAAS,GAAG,CAAZ;AACAC,MAAAA,QAAQ,GAAG,CAAX;;AACA,WAAK,IAAII,CAAC,GAAG,CAAR,EAAWC,KAAK,GAAGpC,GAAG,CAACa,IAAJ,CAAShB,MAAjC,EAAyCsC,CAAC,GAAGC,KAA7C,EAAoDD,CAAC,EAArD,EAAyD;AACrDrB,QAAAA,IAAI,GAAGd,GAAG,CAACa,IAAJ,CAASsB,CAAT,CAAP;AACAH,QAAAA,UAAU,GAAGlB,IAAI,CAACuB,UAAlB;;AACA,YAAIvB,IAAI,CAAC/C,IAAL,CAAUS,MAAV,KAAqB,CAAzB,EAA4B;AACxBsC,UAAAA,IAAI,CAAC/C,IAAL,CAAUS,MAAV,GAAmBwB,GAAG,CAACK,cAAvB;AACAM,UAAAA,IAAI,GAAG,CAAP;;AACA,eAAK,IAAI2B,CAAC,GAAGL,CAAC,GAAG,CAAZ,EAAeM,KAAK,GAAGN,CAAC,GAAGnB,IAAI,CAAC0B,IAArC,EAA2CF,CAAC,GAAGC,KAA/C,EAAsDD,CAAC,EAAvD,EAA2D;AACvD5B,YAAAA,UAAU,GAAG/C,KAAK,CAACiC,IAAN,CAAW0C,CAAX,CAAb;AACA3B,YAAAA,IAAI,IAAID,UAAU,CAACL,cAAnB;AACH;;AACDS,UAAAA,IAAI,CAAC/C,IAAL,CAAUQ,CAAV,GAAeyB,GAAG,CAACyC,WAAJ,GAAkB9B,IAAnB,IAA4BG,IAAI,CAAC4B,aAAL,GAAqB5B,IAAI,CAAC4B,aAA1B,GAA0CV,UAAtE,CAAd;AACAlB,UAAAA,IAAI,CAAC/C,IAAL,CAAUS,MAAV,GAAoBsC,IAAI,CAAC/C,IAAL,CAAUS,MAAV,GAAmBmC,IAApB,GACd,KAAKgC,kBAAL,CAAwB7B,IAAI,CAAC4B,aAA7B,EAA4C5B,IAAI,CAAC8B,gBAAjD,EAAmE9B,IAAI,CAACuB,UAAxE,CADL;AAEAvB,UAAAA,IAAI,CAAC/C,IAAL,CAAUG,KAAV,GAAkB,CAAlB;AACH;;AACD,YAAI4C,IAAI,CAAC+B,qBAAT,EAAgC;AAC5BvE,UAAAA,CAAC,GAAGP,IAAI,CAACO,CAAL,GAASP,IAAI,CAACG,KAAd,GAAsBhC,GAAG,CAACI,QAAQ,CAAC0D,GAAG,CAACD,QAAL,EAAegC,QAAf,CAAT,CAA7B;AACAjB,UAAAA,IAAI,CAAC/C,IAAL,CAAUO,CAAV,GAAcwC,IAAI,CAAC/C,IAAL,CAAUO,CAAV,IAAeA,CAAf,GAAmBwC,IAAI,CAAC/C,IAAL,CAAUO,CAA7B,GAAiCA,CAA/C;AACAyD,UAAAA,QAAQ;AACX,SAJD,MAKK;AACDzD,UAAAA,CAAC,GAAGP,IAAI,CAACO,CAAL,GAASpC,GAAG,CAACI,QAAQ,CAAC0D,GAAG,CAACE,SAAL,EAAgB4B,SAAhB,CAAT,CAAhB;AACAhB,UAAAA,IAAI,CAAC/C,IAAL,CAAUO,CAAV,GAAcwC,IAAI,CAAC/C,IAAL,CAAUO,CAAV,IAAeA,CAAf,GAAmBwC,IAAI,CAAC/C,IAAL,CAAUO,CAA7B,GAAiCA,CAA/C;AACAwD,UAAAA,SAAS;AACZ;AACJ;AACJ;;AACD,SAAKvB,mBAAL,CAAyBxC,IAAzB;;AACA,SAAK,IAAIkE,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGvE,KAAK,CAAC6C,OAAN,CAAcX,MAApC,EAA4CoC,CAAC,GAAGC,GAAhD,EAAqDD,CAAC,EAAtD,EAA0D;AACtD3B,MAAAA,MAAM,GAAG3C,KAAK,CAAC6C,OAAN,CAAcyB,CAAd,CAAT;AACAH,MAAAA,SAAS,GAAG,CAAZ;AACAC,MAAAA,QAAQ,GAAG,CAAX;;AACA,WAAK,IAAII,CAAC,GAAG,CAAR,EAAWW,KAAK,GAAGxC,MAAM,CAACO,IAAP,CAAYhB,MAApC,EAA4CsC,CAAC,GAAGW,KAAhD,EAAuDX,CAAC,EAAxD,EAA4D;AACxDrB,QAAAA,IAAI,GAAGR,MAAM,CAACO,IAAP,CAAYsB,CAAZ,CAAP;AACAH,QAAAA,UAAU,GAAGlB,IAAI,CAACuB,UAAlB;;AACA,YAAIvB,IAAI,CAAC/C,IAAL,CAAUG,KAAV,KAAoB,CAAxB,EAA2B;AACvB,eAAK,IAAIoE,CAAC,GAAGL,CAAR,EAAWc,KAAK,GAAId,CAAC,GAAGnB,IAAI,CAAC0B,IAAlC,EAAyCF,CAAC,GAAGS,KAA7C,EAAoDT,CAAC,EAArD,EAAyD;AACrD5B,YAAAA,UAAU,GAAG/C,KAAK,CAAC6C,OAAN,CAAc8B,CAAd,CAAb;AACAxB,YAAAA,IAAI,CAAC/C,IAAL,CAAUG,KAAV,IAAmBwC,UAAU,CAACD,aAA9B;AACH;;AACDK,UAAAA,IAAI,CAAC/C,IAAL,CAAUO,CAAV,GAAcgC,MAAM,CAAC0C,YAAP,IAAuBlC,IAAI,CAACmC,cAAL,GAAsBnC,IAAI,CAACmC,cAA3B,GAA4CjB,UAAnE,CAAd;AACAlB,UAAAA,IAAI,CAAC/C,IAAL,CAAUG,KAAV,IAAoB,KAAKyE,kBAAL,CAAwB7B,IAAI,CAACmC,cAA7B,EAA6CnC,IAAI,CAACoC,eAAlD,EAAmEpC,IAAI,CAACuB,UAAxE,CAApB;AACAvB,UAAAA,IAAI,CAAC/C,IAAL,CAAUS,MAAV,GAAmB,CAAnB;AACH;;AACD,YAAIsC,IAAI,CAAC+B,qBAAT,EAAgC;AAC5BtE,UAAAA,CAAC,GAAGR,IAAI,CAACQ,CAAL,GAASrC,GAAG,CAACI,QAAQ,CAACgE,MAAM,CAACP,QAAR,EAAkBgC,QAAlB,CAAT,CAAhB;AACAjB,UAAAA,IAAI,CAAC/C,IAAL,CAAUQ,CAAV,GAAcuC,IAAI,CAAC/C,IAAL,CAAUQ,CAAV,IAAeA,CAAf,GAAmBuC,IAAI,CAAC/C,IAAL,CAAUQ,CAA7B,GAAiCA,CAA/C;AACAwD,UAAAA,QAAQ;AACX,SAJD,MAKK;AACDxD,UAAAA,CAAC,GAAGR,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAAd,GAAuBtC,GAAG,CAACI,QAAQ,CAACgE,MAAM,CAACJ,SAAR,EAAmB4B,SAAnB,CAAT,CAA9B;AACAhB,UAAAA,IAAI,CAAC/C,IAAL,CAAUQ,CAAV,GAAcuC,IAAI,CAAC/C,IAAL,CAAUQ,CAAV,IAAeA,CAAf,GAAmBuC,IAAI,CAAC/C,IAAL,CAAUQ,CAA7B,GAAiCA,CAA/C;AACAuD,UAAAA,SAAS;AACZ;AACJ;AACJ;AACJ,GAzED;AA0EA;AACJ;AACA;AACA;AACA;AACA;;;AACIrE,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCsF,OAAnC,GAA6C,YAAY;AACrD,QAAIxF,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIqC,GAAJ;AACA,QAAIM,MAAJ;AACA,QAAII,UAAJ;AACA,QAAI0C,WAAJ;AACA,QAAIZ,IAAJ;;AACA,SAAK,IAAI9C,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGhC,KAAK,CAAC0F,eAA5B,EAA6C3D,EAAE,GAAGC,EAAE,CAACE,MAArD,EAA6DH,EAAE,EAA/D,EAAmE;AAC/D,UAAIoB,IAAI,GAAGnB,EAAE,CAACD,EAAD,CAAb,CAD+D,CAE/D;;AACA,UAAIoB,IAAI,CAACwC,WAAL,KAAqB,UAAzB,EAAqC;AACjC3F,QAAAA,KAAK,CAAC4F,YAAN,CAAmBC,IAAnB,CAAwB1C,IAAxB;AACAsC,QAAAA,WAAW,GAAG,KAAKK,YAAL,CAAkB3C,IAAlB,CAAd;AACAd,QAAAA,GAAG,GAAGrC,KAAK,CAACiC,IAAN,CAAWwD,WAAX,CAAN;AACA,aAAKM,QAAL,CAAc1D,GAAd,EAAmBc,IAAnB;AACA0B,QAAAA,IAAI,GAAKY,WAAW,GAAGtC,IAAI,CAAC0B,IAApB,GAA4B7E,KAAK,CAACiC,IAAN,CAAWC,MAAvC,GAAgDlC,KAAK,CAACiC,IAAN,CAAWC,MAA3D,GAAqEuD,WAAW,GAAGtC,IAAI,CAAC0B,IAAhG;;AACA,aAAK,IAAIL,CAAC,GAAGiB,WAAW,GAAG,CAA3B,EAA8BjB,CAAC,GAAGK,IAAlC,EAAwCL,CAAC,EAAzC,EAA6C;AACzCzB,UAAAA,UAAU,GAAG/C,KAAK,CAACiC,IAAN,CAAWuC,CAAX,CAAb;AACAzB,UAAAA,UAAU,CAACG,IAAX,CAAgBb,GAAG,CAACa,IAAJ,CAAShB,MAAT,GAAkB,CAAlC,IAAuCiB,IAAvC;AACAnD,UAAAA,KAAK,CAACiC,IAAN,CAAWuC,CAAX,IAAgBzB,UAAhB;AACH;;AACD/C,QAAAA,KAAK,CAACiC,IAAN,CAAWwD,WAAX,IAA0BpD,GAA1B;AACH,OAZD,MAaK;AACDrC,QAAAA,KAAK,CAACgG,cAAN,CAAqBH,IAArB,CAA0B1C,IAA1B;AACAsC,QAAAA,WAAW,GAAG,KAAKQ,eAAL,CAAqB9C,IAArB,CAAd;AACAR,QAAAA,MAAM,GAAG3C,KAAK,CAAC6C,OAAN,CAAc4C,WAAd,CAAT;AACA,aAAKM,QAAL,CAAcpD,MAAd,EAAsBQ,IAAtB;AACA0B,QAAAA,IAAI,GAAKY,WAAW,GAAGtC,IAAI,CAAC0B,IAApB,GAA4B7E,KAAK,CAAC6C,OAAN,CAAcX,MAA1C,GAAmDlC,KAAK,CAAC6C,OAAN,CAAcX,MAAjE,GAA2EuD,WAAW,GAAGtC,IAAI,CAAC0B,IAAtG;;AACA,aAAK,IAAIL,CAAC,GAAGiB,WAAW,GAAG,CAA3B,EAA8BjB,CAAC,GAAGK,IAAlC,EAAwCL,CAAC,EAAzC,EAA6C;AACzCzB,UAAAA,UAAU,GAAG/C,KAAK,CAAC6C,OAAN,CAAc2B,CAAd,CAAb;AACAzB,UAAAA,UAAU,CAACG,IAAX,CAAgBP,MAAM,CAACO,IAAP,CAAYhB,MAAZ,GAAqB,CAArC,IAA0CiB,IAA1C;AACAnD,UAAAA,KAAK,CAAC6C,OAAN,CAAc2B,CAAd,IAAmBzB,UAAnB;AACH;;AACD/C,QAAAA,KAAK,CAAC6C,OAAN,CAAc4C,WAAd,IAA6B9C,MAA7B;AACH;;AACDQ,MAAAA,IAAI,CAAC+C,YAAL,GAAoBlG,KAAK,CAACmG,SAA1B;AACAhD,MAAAA,IAAI,CAACiD,+BAAL;AACH;AACJ,GAvCD;;AAwCAtG,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC8E,kBAAnC,GAAwD,UAAUqB,SAAV,EAAqBC,SAArB,EAAgC5B,UAAhC,EAA4C;AAChG,QAAI6B,WAAW,GAAGF,SAAS,GAAIA,SAAS,IAAIC,SAAS,GAAGA,SAAH,GACjD5B,UADoC,CAAb,GACP4B,SAAS,GAAGA,SAAS,GAAG5B,UAAf,GAA4B,IAAIA,UAD7D;AAEA,WAAO6B,WAAP;AACH,GAJD;;AAKAzG,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCO,OAAnC,GAA6C,UAAUT,KAAV,EAAiB;AAC1D,SAAK,IAAI+B,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGhC,KAAK,CAAC0F,eAA5B,EAA6C3D,EAAE,GAAGC,EAAE,CAACE,MAArD,EAA6DH,EAAE,EAA/D,EAAmE;AAC/D,UAAIoB,IAAI,GAAGnB,EAAE,CAACD,EAAD,CAAb;;AACA,UAAIoB,IAAI,CAACqD,SAAL,KAAmB,IAAvB,EAA6B;AACzB;AACH;;AACD,UAAI,CAACrD,IAAI,CAACsD,aAAV,EAAyB;AACrB,YAAIzG,KAAK,CAAC0G,mBAAV,EAA+B;AAC3BvD,UAAAA,IAAI,CAACwD,WAAL,GAAqBxD,IAAI,CAACwC,WAAL,KAAqB,YAAvB,GAAwC3F,KAAK,CAAC4G,YAA9C,GAA6D5G,KAAK,CAAC6G,YAAtF;AACH,SAFD,MAGK;AACD1D,UAAAA,IAAI,CAACwD,WAAL,GAAqBxD,IAAI,CAACwC,WAAL,KAAqB,YAAvB,GAAwC3F,KAAK,CAAC6G,YAA9C,GAA6D7G,KAAK,CAAC4G,YAAtF;AACH;;AACDzD,QAAAA,IAAI,CAAC1C,OAAL,GAAe,KAAKqG,aAAL,CAAmB3D,IAAI,CAACwD,WAAxB,EAAqCxD,IAAI,CAACqD,SAA1C,CAAf;AACA;AACH,OATD,MAUK;AACD,aAAK,IAAIlC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGvE,KAAK,CAAC0F,eAAN,CAAsBxD,MAA5C,EAAoDoC,CAAC,GAAGC,GAAxD,EAA6DD,CAAC,EAA9D,EAAkE;AAC9D,cAAInB,IAAI,CAACsD,aAAL,KAAuBzG,KAAK,CAAC0F,eAAN,CAAsBpB,CAAtB,EAAyByC,IAApD,EAA0D;AACtD5D,YAAAA,IAAI,CAACwD,WAAL,GAAmB3G,KAAK,CAAC0F,eAAN,CAAsBpB,CAAtB,CAAnB;AACAnB,YAAAA,IAAI,CAAC1C,OAAL,GAAe,KAAKqG,aAAL,CAAmB3D,IAAI,CAACwD,WAAxB,EAAqCxD,IAAI,CAACqD,SAA1C,CAAf;AACA;AACH;AACJ;AACJ;AACJ;AACJ,GA1BD;;AA2BA1G,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC4G,aAAnC,GAAmD,UAAU3D,IAAV,EAAgB1C,OAAhB,EAAyB;AACxE,YAAQ0C,IAAI,CAAC6D,SAAb;AACI,WAAK,UAAL;AACI,YAAIC,MAAM,GAAG;AACTC,UAAAA,QAAQ,EAAE,MADD;AAETC,UAAAA,IAAI,EAAE;AAFG,SAAb;AAIA,YAAIC,UAAU,GAAG,KAAKpH,KAAL,CAAWqH,IAAX,CAAgBC,aAAhB,CAA8BL,MAA9B,CAAjB;AACA,YAAIM,aAAa,GAAG,KAAKvH,KAAL,CAAWqH,IAAX,CAAgBG,aAAhB,CAA8BP,MAA9B,CAApB;AACA,eAAOQ,IAAI,CAACC,KAAL,CAAWN,UAAU,CAACG,aAAa,CAAC,IAAIE,IAAJ,CAASrJ,QAAQ,CAACsJ,KAAT,CAAeC,SAAf,CAAyB;AAAEC,UAAAA,GAAG,EAAEnH;AAAP,SAAzB,EAA2CmH,GAApD,CAAD,CAAd,CAArB,CAAP;;AACJ,WAAK,UAAL;AACI,eAAOC,UAAU,CAACpH,OAAD,CAAV,GAAsBoH,UAAU,CAACpH,OAAD,CAAhC,GAA4C0C,IAAI,CAAC2E,MAAL,CAAYC,OAAZ,CAAoBtH,OAApB,CAAnD;;AACJ,WAAK,aAAL;AACI,eAAOzB,OAAO,CAACyB,OAAD,EAAU0C,IAAI,CAACnE,OAAf,CAAd;;AACJ;AACI,eAAOyB,OAAP;AAdR;AAgBH,GAjBD;;AAkBAX,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC6F,QAAnC,GAA8C,UAAUhD,UAAV,EAAsBI,IAAtB,EAA4B;AACtE,SAAK,IAAImB,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGxB,UAAU,CAACG,IAAX,CAAgBhB,MAAtC,EAA8CoC,CAAC,IAAIC,GAAnD,EAAwDD,CAAC,EAAzD,EAA6D;AACzD,UAAI,CAACvB,UAAU,CAACG,IAAX,CAAgBoB,CAAhB,CAAL,EAAyB;AACrBvB,QAAAA,UAAU,CAACG,IAAX,CAAgBoB,CAAhB,IAAqBnB,IAArB;AACA;AACH;AACJ;AACJ,GAPD;;AAQArD,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCsC,WAAnC,GAAiD,UAAUO,UAAV,EAAsB;AACnE,QAAIiF,cAAc,GAAG,EAArB;;AACA,SAAK,IAAI1D,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGxB,UAAU,CAACG,IAAX,CAAgBhB,MAAtC,EAA8CoC,CAAC,IAAIC,GAAnD,EAAwDD,CAAC,EAAzD,EAA6D;AACzD,UAAIvB,UAAU,CAACG,IAAX,CAAgBoB,CAAhB,CAAJ,EAAwB;AACpB0D,QAAAA,cAAc,CAACnC,IAAf,CAAoB9C,UAAU,CAACG,IAAX,CAAgBoB,CAAhB,CAApB;AACH;AACJ;;AACDvB,IAAAA,UAAU,CAACG,IAAX,GAAkB8E,cAAlB;AACH,GARD;;AASAlI,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC+F,eAAnC,GAAqD,UAAU9C,IAAV,EAAgB;AACjE,QAAI8E,YAAY,GAAG,KAAKjI,KAAL,CAAW6C,OAAX,CAAmBX,MAAtC;AACA,QAAIgG,GAAG,GAAG/E,IAAI,CAACgF,WAAf;AACA,QAAIC,MAAM,GAAGF,GAAG,IAAID,YAAP,GAAsBA,YAAY,GAAG,CAArC,GAA0CC,GAAG,GAAG,CAAN,GAAU,CAAV,GAAcA,GAArE;AACA,WAAOE,MAAP;AACH,GALD;;AAMAtI,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC4F,YAAnC,GAAkD,UAAU3C,IAAV,EAAgB;AAC9D,QAAI8E,YAAY,GAAG,KAAKjI,KAAL,CAAWiC,IAAX,CAAgBC,MAAnC;AACA,QAAIgG,GAAG,GAAG/E,IAAI,CAACkF,QAAf;AACA,QAAID,MAAM,GAAGF,GAAG,IAAID,YAAP,GAAsBA,YAAY,GAAG,CAArC,GAA0CC,GAAG,GAAG,CAAN,GAAU,CAAV,GAAcA,GAArE;AACA,WAAOE,MAAP;AACH,GALD;AAMA;AACJ;AACA;AACA;AACA;;;AACItI,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCoC,gBAAnC,GAAsD,UAAUlC,IAAV,EAAgB;AAClE;AACA,QAAIJ,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIqC,GAAJ;AACA,QAAIiG,MAAM,GAAGlI,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAA3B;AACA,QAAIA,MAAM,GAAG,CAAb;AACA,QAAI0H,eAAe,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYrI,IAAI,CAACS,MAAjB,CAAtB;;AACA,SAAK,IAAIyD,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGvE,KAAK,CAACiC,IAAN,CAAWC,MAAjC,EAAyCoC,CAAC,GAAGC,GAA7C,EAAkDD,CAAC,EAAnD,EAAuD;AACnDjC,MAAAA,GAAG,GAAGrC,KAAK,CAACiC,IAAN,CAAWqC,CAAX,CAAN;;AACA,UAAIjC,GAAG,CAACxB,MAAJ,CAAWkH,OAAX,CAAmB,GAAnB,MAA4B,CAAC,CAAjC,EAAoC;AAChClH,QAAAA,MAAM,GAAG2H,IAAI,CAACE,GAAL,CAASH,eAAT,EAA2BnI,IAAI,CAACS,MAAL,GAAc8H,QAAQ,CAACtG,GAAG,CAACxB,MAAL,EAAa,EAAb,CAAtB,GAAyC,GAApE,CAAT;AACH,OAFD,MAGK;AACDA,QAAAA,MAAM,GAAG2H,IAAI,CAACE,GAAL,CAASH,eAAT,EAA0BI,QAAQ,CAACtG,GAAG,CAACxB,MAAL,EAAa,EAAb,CAAlC,CAAT;AACH;;AACDA,MAAAA,MAAM,GAAIyD,CAAC,KAAMC,GAAG,GAAG,CAAd,GAAoB1D,MAApB,GAA6B0H,eAAtC;AACAlG,MAAAA,GAAG,CAACK,cAAJ,GAAqB7B,MAArB;AACAyH,MAAAA,MAAM,IAAIzH,MAAV;AACAwB,MAAAA,GAAG,CAACyC,WAAJ,GAAkBwD,MAAlB;AACAC,MAAAA,eAAe,IAAI1H,MAAnB;AACH;AACJ,GArBD;AAsBA;AACJ;AACA;AACA;AACA;AACA;;;AACIf,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC0C,mBAAnC,GAAyD,UAAUxC,IAAV,EAAgB;AACrE;AACA,QAAIJ,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAI2C,MAAJ;AACA,QAAIiG,UAAU,GAAGxI,IAAI,CAACO,CAAtB;AACA,QAAIJ,KAAK,GAAG,CAAZ;AACA,QAAIsI,cAAc,GAAGL,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYrI,IAAI,CAACG,KAAjB,CAArB;;AACA,SAAK,IAAI+D,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGvE,KAAK,CAAC6C,OAAN,CAAcX,MAApC,EAA4CoC,CAAC,GAAGC,GAAhD,EAAqDD,CAAC,EAAtD,EAA0D;AACtD3B,MAAAA,MAAM,GAAG3C,KAAK,CAAC6C,OAAN,CAAcyB,CAAd,CAAT;;AACA,UAAI3B,MAAM,CAACpC,KAAP,CAAawH,OAAb,CAAqB,GAArB,MAA8B,CAAC,CAAnC,EAAsC;AAClCxH,QAAAA,KAAK,GAAGiI,IAAI,CAACE,GAAL,CAASG,cAAT,EAA0BzI,IAAI,CAACG,KAAL,GAAaoI,QAAQ,CAAChG,MAAM,CAACpC,KAAR,EAAe,EAAf,CAArB,GAA0C,GAApE,CAAR;AACH,OAFD,MAGK;AACDA,QAAAA,KAAK,GAAGiI,IAAI,CAACE,GAAL,CAASG,cAAT,EAAyBF,QAAQ,CAAChG,MAAM,CAACpC,KAAR,EAAe,EAAf,CAAjC,CAAR;AACH;;AACDA,MAAAA,KAAK,GAAI+D,CAAC,KAAMC,GAAG,GAAG,CAAd,GAAoBhE,KAApB,GAA4BsI,cAApC;AACAlG,MAAAA,MAAM,CAACG,aAAP,GAAuBvC,KAAvB;AACAoC,MAAAA,MAAM,CAAC0C,YAAP,GAAsBuD,UAAtB;AACAA,MAAAA,UAAU,IAAIrI,KAAd;AACAsI,MAAAA,cAAc,IAAItI,KAAlB;AACH;AACJ,GArBD;AAsBA;AACJ;AACA;AACA;AACA;AACA;AACI;;;AACAT,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC4I,UAAnC,GAAgD,YAAY;AACxD,QAAI9I,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAImD,IAAJ;AACA,QAAI4F,WAAW,GAAG/I,KAAK,CAACgJ,QAAN,CAAeC,WAAf,CAA2B;AAAEC,MAAAA,EAAE,EAAElJ,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB;AAAzB,KAA3B,CAAlB;AACA,QAAIE,eAAe,GAAGpJ,KAAK,CAACgJ,QAAN,CAAeC,WAAf,CAA2B;AAAEC,MAAAA,EAAE,EAAElJ,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB;AAAzB,KAA3B,CAAtB;AACA,QAAIG,cAAJ;AACA,QAAIC,QAAJ;;AACA,SAAK,IAAIhF,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGvE,KAAK,CAAC0F,eAAN,CAAsBxD,MAA5C,EAAoDoC,CAAC,GAAGC,GAAxD,EAA6DD,CAAC,EAA9D,EAAkE;AAC9D,UAAIiF,cAAc,GAAG,IAArB;AACApG,MAAAA,IAAI,GAAGnD,KAAK,CAAC0F,eAAN,CAAsBpB,CAAtB,CAAP;AACA,WAAK6E,OAAL,GAAenJ,KAAK,CAACgJ,QAAN,CAAeC,WAAf,CAA2B;AAAEC,QAAAA,EAAE,EAAElJ,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB,WAAnB,GAAiC5E,CAAjC,GAAqC;AAA3C,OAA3B,CAAf;AACA+E,MAAAA,cAAc,GAAGrJ,KAAK,CAACgJ,QAAN,CAAeC,WAAf,CAA2B;AAAEC,QAAAA,EAAE,EAAElJ,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB,WAAnB,GAAiC5E,CAAjC,GAAqC;AAA3C,OAA3B,CAAjB;;AACA,WAAK,IAAIvC,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAG,KAAKhC,KAAL,CAAWwJ,MAAjC,EAAyCzH,EAAE,GAAGC,EAAE,CAACE,MAAjD,EAAyDH,EAAE,EAA3D,EAA+D;AAC3D,YAAIyH,MAAM,GAAGxH,EAAE,CAACD,EAAD,CAAf;;AACA,YAAIoB,IAAI,CAAC4D,IAAL,KAAcyC,MAAM,CAACC,SAArB,IAAkCtG,IAAI,CAAC4D,IAAL,KAAcyC,MAAM,CAACE,SAA3D,EAAsE;AAClEH,UAAAA,cAAc,GAAGC,MAAM,CAACG,OAAxB;;AACA,cAAIJ,cAAJ,EAAoB;AAChB;AACH,WAFD,MAGK;AACD;AACH;AACJ;AACJ;;AACD,UAAI,CAACA,cAAL,EAAqB;AACjB;AACH;;AACDD,MAAAA,QAAQ,GAAG,KAAKM,gBAAL,CAAsBzG,IAAtB,CAAX;;AACA,UAAIA,IAAI,CAACwC,WAAL,KAAqB,YAAzB,EAAuC;AACnCxC,QAAAA,IAAI,CAAC0G,gBAAL;;AACA,YAAI1G,IAAI,CAACwG,OAAL,IAAgBxG,IAAI,CAAC2G,kBAArB,IAA2C3G,IAAI,CAAC4G,SAAL,CAAexJ,KAAf,GAAuB,CAAtE,EAAyE;AACrE,eAAKyJ,YAAL,CAAkB7G,IAAlB,EAAwBmB,CAAxB,EAA2BnB,IAAI,CAACuB,UAAhC,EAA4C,CAA5C,EAA+C4E,QAAQ,GAAGD,cAAH,GAAoB,KAAKF,OAAhF,EAAyFhG,IAAI,CAAC8G,WAA9F;AACH;;AACD,YAAI9G,IAAI,CAAC+G,cAAL,CAAoB3J,KAApB,GAA4B,CAA5B,IAAiC4C,IAAI,CAACgH,cAAL,CAAoB5J,KAApB,GAA4B,CAAjE,EAAoE;AAChE,eAAK6J,iBAAL,CAAuBjH,IAAvB,EAA6BmB,CAA7B,EAAiCgF,QAAQ,IAAInG,IAAI,CAACkH,YAAL,KAAsB,QAAnC,GAA+ChB,cAA/C,GAAgE,KAAKF,OAArG,EAA8GhG,IAAI,CAAC8G,WAAnH;AACH;;AACD,YAAI9G,IAAI,CAACwG,OAAL,IAAgBxG,IAAI,CAAC2G,kBAAzB,EAA6C;AACzC,eAAKQ,eAAL,CAAqBnH,IAArB,EAA2BmB,CAA3B,EAA+BgF,QAAQ,IAAInG,IAAI,CAACoH,aAAL,KAAuB,QAApC,GAAgDlB,cAAhD,GAAiE,KAAKF,OAApG,EAA8GhG,IAAI,CAACqH,mBAAL,GAA2BrH,IAAI,CAAC8G,WAAhC,GAA8C9G,IAAI,CAAC/C,IAAjK;AACA,eAAKqK,eAAL,CAAqBtH,IAArB,EAA2BmB,CAA3B,EAA+BgF,QAAQ,IAAInG,IAAI,CAACoH,aAAL,KAAuB,QAApC,GAAgDlB,cAAhD,GAAiE,KAAKF,OAApG,EAA8GhG,IAAI,CAACqH,mBAAL,GAA2BrH,IAAI,CAAC8G,WAAhC,GAA8C9G,IAAI,CAAC/C,IAAjK;AACA,eAAKsK,cAAL,CAAoBvH,IAApB,EAA0BmB,CAA1B,EAA6BgF,QAAQ,GAAGD,cAAH,GAAoB,KAAKF,OAA9D,EAAwEhG,IAAI,CAACqH,mBAAL,GAA2BrH,IAAI,CAAC8G,WAAhC,GAA8C9G,IAAI,CAAC/C,IAA3H;AACH;AACJ,OAbD,MAcK;AACD+C,QAAAA,IAAI,CAAC0G,gBAAL;;AACA,YAAI1G,IAAI,CAACwG,OAAL,IAAgBxG,IAAI,CAAC2G,kBAArB,IAA2C3G,IAAI,CAAC4G,SAAL,CAAexJ,KAAf,GAAuB,CAAtE,EAAyE;AACrE,eAAKyJ,YAAL,CAAkB7G,IAAlB,EAAwBmB,CAAxB,EAA2B,CAA3B,EAA8BnB,IAAI,CAACuB,UAAnC,EAA+C4E,QAAQ,GAAGD,cAAH,GAAoB,KAAKF,OAAhF,EAAyFhG,IAAI,CAAC8G,WAA9F;AACH;;AACD,YAAI9G,IAAI,CAAC+G,cAAL,CAAoB3J,KAApB,GAA4B,CAA5B,IAAiC4C,IAAI,CAACgH,cAAL,CAAoB5J,KAApB,GAA4B,CAAjE,EAAoE;AAChE,eAAKoK,iBAAL,CAAuBxH,IAAvB,EAA6BmB,CAA7B,EAAiCgF,QAAQ,IAAInG,IAAI,CAACkH,YAAL,KAAsB,QAAnC,GAA+ChB,cAA/C,GAAgE,KAAKF,OAArG,EAA8GhG,IAAI,CAAC8G,WAAnH;AACH;;AACD,YAAI9G,IAAI,CAACwG,OAAL,IAAgBxG,IAAI,CAAC2G,kBAAzB,EAA6C;AACzC,eAAKc,eAAL,CAAqBzH,IAArB,EAA2BmB,CAA3B,EAA+BgF,QAAQ,IAAInG,IAAI,CAACoH,aAAL,KAAuB,QAApC,GAAgDlB,cAAhD,GAAiE,KAAKF,OAApG,EAA8GhG,IAAI,CAACqH,mBAAL,GAA2BrH,IAAI,CAAC8G,WAAhC,GAA8C9G,IAAI,CAAC/C,IAAjK;AACA,eAAKyK,eAAL,CAAqB1H,IAArB,EAA2BmB,CAA3B,EAA+BgF,QAAQ,IAAInG,IAAI,CAACoH,aAAL,KAAuB,QAApC,GAAgDlB,cAAhD,GAAiE,KAAKF,OAApG,EAA8GhG,IAAI,CAACqH,mBAAL,GAA2BrH,IAAI,CAAC8G,WAAhC,GAA8C9G,IAAI,CAAC/C,IAAjK;AACA,eAAK0K,cAAL,CAAoB3H,IAApB,EAA0BmB,CAA1B,EAA6BgF,QAAQ,GAAGD,cAAH,GAAoB,KAAKF,OAA9D,EAAwEhG,IAAI,CAACqH,mBAAL,GAA2BrH,IAAI,CAAC8G,WAAhC,GAA8C9G,IAAI,CAAC/C,IAA3H;AACH;AACJ;;AACD,UAAI,CAAC,KAAKJ,KAAL,CAAW+K,YAAhB,EAA8B;AAC1BhC,QAAAA,WAAW,CAACiC,WAAZ,CAAwB,KAAK7B,OAA7B;;AACA,YAAIE,cAAc,IAAIA,cAAc,CAAC4B,UAAf,CAA0B/I,MAA1B,GAAmC,CAAzD,EAA4D;AACxDkH,UAAAA,eAAe,CAAC4B,WAAhB,CAA4B3B,cAA5B;AACH;AACJ;;AACD,UAAIrJ,KAAK,CAACqD,eAAN,KAA2BrD,KAAK,CAACuD,YAAN,CAAmBC,eAAnB,IAAsCL,IAAI,CAACM,wBAA5C,IAC1BN,IAAI,CAACU,iBAAL,CAAuBC,MADvB,CAAJ,EACoC;AAChC,aAAKoH,eAAL,CAAqBlL,KAArB,EAA4BmD,IAA5B;AACH;AACJ;;AACD,SAAKgG,OAAL,GAAenJ,KAAK,CAACgJ,QAAN,CAAeC,WAAf,CAA2B;AAAEC,MAAAA,EAAE,EAAElJ,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB;AAAzB,KAA3B,CAAf;;AACA,SAAK,IAAI1E,CAAC,GAAG,CAAR,EAAWD,GAAG,GAAGvE,KAAK,CAACiC,IAAN,CAAWC,MAAjC,EAAyCsC,CAAC,GAAGD,GAA7C,EAAkDC,CAAC,EAAnD,EAAuD;AACnD,UAAInC,GAAG,GAAGrC,KAAK,CAACiC,IAAN,CAAWuC,CAAX,CAAV;;AACA,UAAInC,GAAG,CAAC8I,MAAJ,CAAWC,KAAf,EAAsB;AAClB,aAAKC,cAAL,CAAoBhJ,GAApB,EAAyBmC,CAAzB,EAA4B,IAA5B;AACH;AACJ;;AACD,SAAK,IAAIA,CAAC,GAAG,CAAR,EAAWD,GAAG,GAAGvE,KAAK,CAAC6C,OAAN,CAAcX,MAApC,EAA4CsC,CAAC,GAAGD,GAAhD,EAAqDC,CAAC,EAAtD,EAA0D;AACtD,UAAI7B,MAAM,GAAG3C,KAAK,CAAC6C,OAAN,CAAc2B,CAAd,CAAb;;AACA,UAAI7B,MAAM,CAACwI,MAAP,CAAcC,KAAlB,EAAyB;AACrB,aAAKC,cAAL,CAAoB1I,MAApB,EAA4B6B,CAA5B,EAA+B,KAA/B;AACH;AACJ;;AACD,QAAI,CAAC,KAAKxE,KAAL,CAAW+K,YAAhB,EAA8B;AAC1BhC,MAAAA,WAAW,CAACiC,WAAZ,CAAwB,KAAK7B,OAA7B;AACH;;AACDtK,IAAAA,kBAAkB,CAACmB,KAAK,CAAC+K,YAAP,EAAqB/K,KAAK,CAACsL,SAA3B,EAAsCvC,WAAtC,EAAmD/I,KAAK,CAACuL,MAAzD,CAAlB;AACA,WAAOnC,eAAP;AACH,GArFD;AAsFA;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACItJ,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCgL,eAAnC,GAAqD,UAAUlL,KAAV,EAAiBmD,IAAjB,EAAuB;AACxE,QAAIO,QAAQ,GAAGvF,iBAAiB,CAAC6B,KAAK,CAACsD,UAAP,CAAjB,GAAsC,KAAtC,GAA8CtD,KAAK,CAACsD,UAAN,CAAiBI,QAA9E;;AACA,QAAI,CAAEA,QAAQ,KAAKP,IAAI,CAACQ,UAAL,GAAkB,CAAlB,IAAuBR,IAAI,CAACS,YAAL,GAAoB,CAAhD,CAAT,IAAiET,IAAI,CAACU,iBAAL,CAAuBC,MAAvB,KACjEX,IAAI,CAACQ,UAAL,IAAmB,CAAnB,IAAwBR,IAAI,CAACS,YAAL,IAAqB,CADoB,CAAlE,MAEC,CAACT,IAAI,CAACqI,gBAAL,CAAsBC,UAAvB,IAAqCzL,KAAK,CAAC0L,aAAN,CAAoB,CAApB,EAAuBvE,IAAvB,CAA4BY,OAA5B,CAAoC,KAApC,KAA8C,CAFpF,CAAJ,EAE4F;AACxF,UAAI,CAAC/H,KAAK,CAAC2L,aAAX,EAA0B;AACtB3L,QAAAA,KAAK,CAAC2L,aAAN,GAAsBnN,aAAa,CAACwB,KAAK,CAACuL,MAAP,EAAevL,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB,gBAAlC,CAAb,IAAoEhL,aAAa,CAAC,KAAD,EAAQ;AAAEgL,UAAAA,EAAE,EAAElJ,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB;AAAzB,SAAR,CAAvG;AACH;;AACDrK,MAAAA,kBAAkB,CAAC,KAAD,EAAQmB,KAAK,CAAC2L,aAAd,EAA6BxI,IAAI,CAACqI,gBAAL,CAAsBI,MAAtB,CAA6B,IAA7B,CAA7B,EAAiE,IAAjE,CAAlB;AACH,KAPD,MAQK,IAAIzI,IAAI,CAACQ,UAAL,KAAoB,CAApB,IAAyBR,IAAI,CAACS,YAAL,KAAsB,CAA/C,IAAoDT,IAAI,CAACqI,gBAAL,CAAsBF,SAA1E,IAAuF,CAACnI,IAAI,CAACU,iBAAL,CAAuBC,MAAnH,EAA2H;AAC5HX,MAAAA,IAAI,CAACqI,gBAAL,CAAsBK,OAAtB;AACH;;AACD,QAAI1I,IAAI,CAACqI,gBAAL,CAAsBC,UAA1B,EAAsC;AAClCtI,MAAAA,IAAI,CAACqI,gBAAL,CAAsBC,UAAtB,GAAmC,KAAnC;AACH;AACJ,GAhBD;AAiBA;AACJ;AACA;AACA;AACA;AACA;;;AACI3L,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC0J,gBAAnC,GAAsD,UAAUzG,IAAV,EAAgB;AAClE,WAAOA,IAAI,CAAC1C,OAAL,KAAiB,IAAjB,IAAyB0C,IAAI,CAACmG,QAAL,CAAcnG,IAAI,CAACwD,WAAL,CAAiBmF,YAA/B,CAAhC;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIhM,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCmL,cAAnC,GAAoD,UAAUtI,UAAV,EAAsBgJ,KAAtB,EAA6BC,KAA7B,EAAoC;AACpF,QAAIhM,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIiM,WAAW,GAAG,EAAlB;AACA,QAAIC,EAAJ;AACA,QAAIC,EAAJ;AACA,QAAIC,EAAJ;AACA,QAAIC,EAAJ;AACA,QAAIC,cAAJ;;AACA,QAAIN,KAAJ,EAAW;AACPjJ,MAAAA,UAAU,GAAGA,UAAb;AACAqJ,MAAAA,EAAE,GAAGC,EAAE,GAAGtJ,UAAU,CAAC+B,WAAX,GAAyB/B,UAAU,CAACL,cAA9C;AACAwJ,MAAAA,EAAE,GAAG,KAAKxL,cAAL,CAAoBC,CAAzB;AACAwL,MAAAA,EAAE,GAAGD,EAAE,GAAG,KAAKxL,cAAL,CAAoBH,KAA9B;AACA+L,MAAAA,cAAc,GAAG,KAAjB;AACH,KAND,MAOK;AACDvJ,MAAAA,UAAU,GAAGA,UAAb;AACAmJ,MAAAA,EAAE,GAAGC,EAAE,GAAGpJ,UAAU,CAACsC,YAArB;AACA+G,MAAAA,EAAE,GAAG,KAAK1L,cAAL,CAAoBE,CAAzB;AACAyL,MAAAA,EAAE,GAAGD,EAAE,GAAG,KAAK1L,cAAL,CAAoBG,MAA9B;AACAyL,MAAAA,cAAc,GAAG,QAAjB;AACH;;AACDL,IAAAA,WAAW,GAAG;AACV,YAAMjM,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB,cAAnB,GAAoCoD,cAApC,GAAqDP,KADjD;AAEVG,MAAAA,EAAE,EAAEA,EAFM;AAGVE,MAAAA,EAAE,EAAEA,EAHM;AAIVD,MAAAA,EAAE,EAAEA,EAJM;AAKVE,MAAAA,EAAE,EAAEA,EALM;AAMV,sBAAgBtJ,UAAU,CAACoI,MAAX,CAAkB5K,KANxB;AAOV,gBAAUwC,UAAU,CAACoI,MAAX,CAAkBC;AAPlB,KAAd;AASA,SAAKmB,UAAL,GAAkBvM,KAAK,CAACgJ,QAAN,CAAewD,QAAf,CAAwBP,WAAxB,CAAlB;AACA,SAAK9C,OAAL,CAAa6B,WAAb,CAAyB,KAAKuB,UAA9B;AACH,GAjCD;AAkCA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIzM,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC8J,YAAnC,GAAkD,UAAU7G,IAAV,EAAgB4I,KAAhB,EAAuBU,KAAvB,EAA8BC,KAA9B,EAAqCC,MAArC,EAA6CvM,IAA7C,EAAmD;AACjG,QAAIJ,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIiM,WAAW,GAAG,EAAlB;AACA,QAAI9C,OAAO,GAAGjK,UAAU,CAACc,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB,WAAnB,GAAiC6C,KAAlC,CAAxB;AACA,QAAIa,SAAS,GAAGzD,OAAO,GAAGA,OAAO,CAAC0D,YAAR,CAAqB,GAArB,CAAH,GAA+B,EAAtD;AACA1D,IAAAA,OAAO,GAAG,IAAV;AACA8C,IAAAA,WAAW,GAAG;AACV,YAAMjM,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB,WAAnB,GAAiC6C,KAD7B;AAEV,WAAK,QAAQ3L,IAAI,CAACO,CAAL,GAAS8L,KAAjB,IAA0B,GAA1B,IAAiCrM,IAAI,CAACQ,CAAL,GAAS8L,KAA1C,IACD,KADC,IACQtM,IAAI,CAACO,CAAL,GAASP,IAAI,CAACG,KAAd,GAAsBkM,KAD9B,IACuC,GADvC,IAC8CrM,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAAd,GAAuB6L,KADrE,CAFK;AAIV,0BAAoBvJ,IAAI,CAAC4G,SAAL,CAAe+C,SAJzB;AAKV,sBAAgB3J,IAAI,CAAC4G,SAAL,CAAexJ,KALrB;AAMV,gBAAU4C,IAAI,CAAC4G,SAAL,CAAeqB,KAAf,IAAwBpL,KAAK,CAAC+M,UAAN,CAAiBC;AANzC,KAAd;AAQA,SAAKT,UAAL,GAAkBvM,KAAK,CAACgJ,QAAN,CAAeiE,QAAf,CAAwBhB,WAAxB,CAAlB;AACApN,IAAAA,kBAAkB,CAACmB,KAAK,CAAC+K,YAAP,EAAqB4B,MAArB,EAA6B,KAAKJ,UAAlC,EAA8CvM,KAAK,CAACuL,MAApD,EAA4D,IAA5D,EAAkE,GAAlE,EAAuE,GAAvE,EAA4E,IAA5E,EAAkFqB,SAAlF,CAAlB;AACH,GAhBD;AAiBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI9M,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCyK,iBAAnC,GAAuD,UAAUxH,IAAV,EAAgB4I,KAAhB,EAAuBY,MAAvB,EAA+BvM,IAA/B,EAAqC;AACxF,QAAI8M,SAAS,GAAG/J,IAAI,CAAC6D,SAAL,KAAmB,aAAnC;AACA,QAAImG,cAAc,GAAGhK,IAAI,CAAC6D,SAAL,CAAee,OAAf,CAAuB,UAAvB,IAAqC,CAAC,CAA3D;AACA,QAAIqF,YAAJ;AACA,QAAIC,MAAM,GAAG,CAAb;AACA,QAAIC,SAAS,GAAG,EAAhB;AACA,QAAIC,SAAS,GAAG,EAAhB;AACA,QAAIC,kBAAJ;AACA,QAAIC,SAAS,GAAGtK,IAAI,CAAC+B,qBAArB;AACA,QAAIwI,QAAQ,GAAGD,SAAS,GAAGtK,IAAI,CAACgH,cAAL,CAAoBtJ,MAAvB,GAAgC,CAACsC,IAAI,CAACgH,cAAL,CAAoBtJ,MAA7E;AACA,QAAI8M,YAAY,GAAIF,SAAD,GAActK,IAAI,CAAC4G,SAAL,CAAexJ,KAAf,GAAuB,GAArC,GAA2C,CAAC4C,IAAI,CAAC4G,SAAL,CAAexJ,KAAhB,GAAwB,GAAtF;AACA,QAAIqN,aAAa,GAAIzK,IAAI,CAAC6D,SAAL,KAAmB,UAAnB,IAAiC7D,IAAI,CAAC0K,cAAL,KAAwB,cAA1D,GAChB,GADgB,GACV,CADV;AAEA,QAAIzK,eAAe,GAAGjF,iBAAiB,CAACgF,IAAI,CAACqD,SAAN,CAAjB,GAAoCiH,SAAS,GAAGtK,IAAI,CAACC,eAAR,GAC/D,CAACD,IAAI,CAACC,eADY,GACM,CAD5B;AAEA,QAAI0K,YAAY,GAAG3K,IAAI,CAACkH,YAAL,KAAsB,QAAzC;AACA,QAAI0D,KAAK,GAAGD,YAAY,GAAI1N,IAAI,CAACO,CAAL,GAAS+M,QAAT,GAAoBC,YAAxB,GAAyCvN,IAAI,CAACO,CAAL,GAAS+M,QAAT,GAAoBC,YAApB,GAAmCvK,eAApG;AACA,QAAIlB,MAAM,GAAGiB,IAAI,CAAC6K,aAAL,CAAmB9L,MAAhC;AACA,QAAI+L,eAAe,GAAG,KAAKjO,KAAL,CAAW+M,UAAjC;;AACA,QAAI5J,IAAI,CAAC6D,SAAL,CAAee,OAAf,CAAuB,UAAvB,IAAqC,CAAC,CAAtC,IAA2C5E,IAAI,CAAC0K,cAAL,KAAwB,cAAnE,IAAqF3L,MAAM,GAAG,CAAlG,EAAqG;AACjGA,MAAAA,MAAM,IAAI,CAAV;AACH;;AACD,QAAIgM,cAAc,GAAG/K,IAAI,CAAC+K,cAA1B;AACA,QAAIC,cAAc,GAAGhL,IAAI,CAACgL,cAA1B,CAvBwF,CAwBxF;;AACA,SAAK,IAAI7J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpC,MAApB,EAA4BoC,CAAC,EAA7B,EAAiC;AAC7B8I,MAAAA,YAAY,GAAG,CAACjK,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,CAAD,GAA0BnB,IAAI,CAAC6K,aAAL,CAAmB1J,CAAC,GAAG,CAAvB,EAA0B8J,KAA1B,GAAkCjL,IAAI,CAAC2I,YAAL,CAAkBuC,QAArD,GAAiET,aAA1F,GACTzK,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,EAAsB8J,KAAtB,GAA8BR,aADpC;AAEAP,MAAAA,MAAM,GAAG/O,kBAAkB,CAAC8O,YAAD,EAAejK,IAAf,CAAlB,GAAyC/C,IAAI,CAACS,MAAvD;AACAwM,MAAAA,MAAM,GAAIA,MAAM,GAAG,CAAC,CAAX,IAAiBjN,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAA/B,CAAT;;AACA,UAAIwM,MAAM,IAAIjN,IAAI,CAACQ,CAAf,IAAqBR,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAAf,IAA0BwM,MAAlD,EAA0D;AACtD,YAAKzO,MAAM,CAACwO,YAAD,EAAejK,IAAI,CAAC2I,YAApB,CAAP,IAA6C,KAAKwC,QAAL,CAAcnL,IAAd,EAAoBmB,CAApB,EAAuB+I,MAAvB,CAAjD,EAAiF;AAC7EC,UAAAA,SAAS,GAAG,OAAO,KAAK5M,cAAL,CAAoBC,CAA3B,GAA+B,GAA/B,GAAsC0M,MAAtC,GACR,KADQ,IACC,KAAK3M,cAAL,CAAoBC,CAApB,GAAwB,KAAKD,cAAL,CAAoBH,KAD7C,IACsD,GADtD,GAC4D8M,MADxE;AAEA,eAAKkB,cAAL,CAAoBpL,IAApB,EAA0B4I,KAA1B,EAAiCuB,SAAjC,EAA4CnK,IAAI,CAAC+G,cAAjD,EAAiE,iBAAjE,EAAoF5F,CAApF,EAAuF,KAAK6E,OAA5F,EAAqG8E,eAAe,CAACO,aAArH,EAAoIrL,IAAI,CAAC+G,cAAL,CAAoB4C,SAAxJ;AACH;;AACDS,QAAAA,SAAS,GAAG,QAAQnN,IAAI,CAACO,CAAL,GAASgN,YAAT,IAAyBG,YAAY,GAAG1K,eAAH,GAAqB,CAA1D,CAAR,IAAwE,GAAxE,GAA8EiK,MAA9E,GACR,KADQ,GACCU,KADD,GACU,GADV,GACgBV,MAD5B;AAEA,aAAKkB,cAAL,CAAoBpL,IAApB,EAA0B4I,KAA1B,EAAiCwB,SAAjC,EAA4CpK,IAAI,CAACgH,cAAjD,EAAiE,iBAAjE,EAAoF7F,CAApF,EAAuFqI,MAAvF,EAA+FsB,eAAe,CAACQ,aAA/G;;AACA,YAAI,CAACP,cAAc,CAAC3N,KAAf,GAAuB,CAAvB,IAA4B4N,cAAc,CAAC5N,KAAf,GAAuB,CAApD,KAA0D4C,IAAI,CAACuL,qBAAL,GAA6B,CAA3F,EAA8F;AAC1F,cAAIpK,CAAC,KAAK,CAAN,IAAW1E,SAAS,CAACuD,IAAD,CAApB,IAA8B,CAAC+J,SAA/B,IAA4C,CAACC,cAAjD,EAAiE;AAC7D,iBAAKwB,wBAAL,CAA8BxL,IAA9B,EAAoCiK,YAApC,EAAkDhN,IAAlD,EAAwDkE,CAAxD,EAA2DyH,KAA3D,EAAkEkC,eAAlE,EAAmFtB,MAAnF;AACH;;AACDa,UAAAA,kBAAkB,GAAG,KAAKoB,iBAAL,CAAuBzL,IAAvB,EAA6BiK,YAA7B,EAA2ChN,IAA3C,EAAiDkE,CAAjD,CAArB;AACA,eAAKiK,cAAL,CAAoBpL,IAApB,EAA0B4I,KAA1B,EAAiCyB,kBAAkB,CAAC,CAAD,CAAnD,EAAwDU,cAAxD,EAAwE,iBAAxE,EAA2F5J,CAA3F,EAA8F,KAAK6E,OAAnG,EAA4G8E,eAAe,CAACY,aAA5H,EAA2IX,cAAc,CAACpB,SAA1J;AACA,eAAKyB,cAAL,CAAoBpL,IAApB,EAA0B4I,KAA1B,EAAiCyB,kBAAkB,CAAC,CAAD,CAAnD,EAAwDW,cAAxD,EAAwE,iBAAxE,EAA2F7J,CAA3F,EAA8FqI,MAA9F,EAAsGsB,eAAe,CAACa,aAAtH;;AACA,cAAIxK,CAAC,KAAKpC,MAAM,GAAG,CAAf,IAAoBtC,SAAS,CAACuD,IAAD,CAA7B,IAAuC+J,SAAvC,IAAoD,CAACC,cAAzD,EAAyE;AACrE,iBAAKwB,wBAAL,CAA8BxL,IAA9B,EAAqCiK,YAAY,GAAGjK,IAAI,CAAC2I,YAAL,CAAkBuC,QAAtE,EAAiFjO,IAAjF,EAAuFkE,CAAvF,EAA0FyH,KAA1F,EAAiGkC,eAAjG,EAAkHtB,MAAlH;AACH;AACJ;AACJ;AACJ;AACJ,GApDD;AAqDA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI7M,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCoO,QAAnC,GAA8C,UAAUnL,IAAV,EAAgB4I,KAAhB,EAAuBqC,KAAvB,EAA8B;AACxE,QAAIjD,MAAM,GAAG,KAAKnL,KAAL,CAAWM,SAAX,CAAqB6K,MAAlC;AACA,QAAI/K,IAAI,GAAG,KAAKM,cAAhB;AACA,QAAIiF,WAAW,GAAGxC,IAAI,CAACwC,WAAvB;AACA,QAAIoJ,KAAK,GAAIpJ,WAAW,KAAK,YAAjB,GAAiCvF,IAAI,CAACO,CAAtC,GAA0CP,IAAI,CAACQ,CAA3D;AACA,QAAIoC,IAAI,GAAI2C,WAAW,KAAK,YAAjB,GAAiCvF,IAAI,CAACG,KAAtC,GAA8CH,IAAI,CAACS,MAA9D;AACA,QAAImO,UAAU,GAAIrJ,WAAW,KAAK,YAAjB,GAAiC,CAAjC,GAAqCxC,IAAI,CAAC6K,aAAL,CAAmB9L,MAAnB,GAA4B,CAAlF;AACA,QAAI+M,QAAQ,GAAItJ,WAAW,KAAK,YAAjB,GAAiCxC,IAAI,CAAC6K,aAAL,CAAmB9L,MAAnB,GAA4B,CAA7D,GAAiE,CAAhF;;AACA,QAAIiB,IAAI,CAACuB,UAAL,GAAkB,CAAtB,EAAyB;AACrB,aAAO,IAAP;AACH,KAFD,MAGK,IAAI,CAAC0J,KAAK,KAAKW,KAAV,IAAmBX,KAAK,KAAMW,KAAK,GAAG/L,IAAvC,MAAkDmI,MAAM,CAAC5K,KAAP,IAAgB,CAAhB,IAAqB4K,MAAM,CAACC,KAAP,KAAiB,aAAxF,CAAJ,EAA4G;AAC7G,aAAO,IAAP;AACH,KAFI,MAGA,IAAKgD,KAAK,KAAKW,KAAV,IAAmBhD,KAAK,KAAKiD,UAA9B,IAA8CZ,KAAK,KAAMW,KAAK,GAAG/L,IAAnB,IAA4B+I,KAAK,KAAKkD,QAAxF,EAAmG;AACpG,aAAO,IAAP;AACH;;AACD,WAAO,KAAP;AACH,GAlBD;AAmBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACInP,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC0K,eAAnC,GAAqD,UAAUzH,IAAV,EAAgB4I,KAAhB,EAAuBY,MAAvB,EAA+BvM,IAA/B,EAAqC;AACtF,QAAIJ,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAIkP,KAAJ;AACA,QAAIC,MAAM,GAAG,CAAb;AACA,QAAI9B,MAAM,GAAG,CAAb;AACA,QAAI+B,WAAJ;AACA,QAAIC,UAAU,GAAGlM,IAAI,CAACmM,YAAtB;AACA,QAAIC,OAAJ;AACA,QAAIC,gBAAJ;AACA,QAAIC,aAAa,GAAGtM,IAAI,CAACoH,aAAL,KAAuB,QAA3C;AACA,QAAIkD,SAAS,GAAGtK,IAAI,CAAC+B,qBAArB;AACA,QAAIwK,SAAS,GAAGvM,IAAI,CAACoH,aAAL,KAAuBpH,IAAI,CAACkH,YAA5B,GAA2ClH,IAAI,CAACgH,cAAL,CAAoBtJ,MAA/D,GAAwE,CAAxF;AACA,QAAIZ,OAAO,GAAGyP,SAAS,GAAGL,UAAZ,GAAyBlM,IAAI,CAAC4G,SAAL,CAAexJ,KAAf,GAAuB,GAA9D;AACA,QAAIoP,KAAK,GAAGxM,IAAI,CAACwM,KAAL,GAAa,GAAzB;AACA1P,IAAAA,OAAO,GAAIwN,SAAD,GAAcxN,OAAd,GAAwB,CAACA,OAAnC;AACA,QAAI2P,YAAY,GAAG5P,KAAK,CAACgJ,QAAN,CAAeC,WAAf,CAA2B;AAAEC,MAAAA,EAAE,EAAElJ,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB,YAAnB,GAAkC6C;AAAxC,KAA3B,CAAnB;AACA,QAAI3I,eAAe,GAAGjF,iBAAiB,CAACgF,IAAI,CAACqD,SAAN,CAAjB,GAAoCrD,IAAI,CAACC,eAAL,IAAwBqK,SAAS,GAAG,CAAH,GAAO,CAAC,CAAzC,CAApC,GAAkF,CAAxG;AACA,QAAIoC,UAAJ;AACA,QAAIC,WAAJ;AACA,QAAIC,YAAJ;AACA,QAAIC,KAAK,GAAG,EAAZ;AACA,QAAIC,SAAS,GAAG9M,IAAI,CAAC+M,aAArB;AACA,QAAIC,WAAW,GAAGF,SAAS,GAAG7P,IAAI,CAACQ,CAAR,GAAaR,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAAtD;AACA,QAAIyO,YAAJ;AACA,QAAIc,cAAJ;AACA,QAAIC,WAAJ;AACA,QAAIC,WAAJ;AACA,QAAIC,qBAAqB,GAAK,CAAC9C,SAAD,IAAc,CAACgC,aAAhB,IAAmChC,SAAS,IAAIgC,aAA7E;;AACA,QAAIA,aAAJ,EAAmB;AACfH,MAAAA,YAAY,GAAG,CAACiB,qBAAD,GAAyB,CAACtQ,OAA1B,GAAoCA,OAAnD;AACH,KAFD,MAGK;AACDqP,MAAAA,YAAY,GAAG,CAACiB,qBAAD,GAAyB,CAACtQ,OAAD,GAAWmD,eAApC,GAAsDnD,OAAO,GAAGmD,eAA/E;AACH;;AACD,QAAIoN,SAAS,GAAG,EAAhB;AACA,QAAIC,mBAAmB,GAAG,EAA1B;AACAtN,IAAAA,IAAI,CAAC6K,aAAL,CAAmB0C,GAAnB,CAAuB,UAAUvO,IAAV,EAAgB;AACnCqO,MAAAA,SAAS,CAAC3K,IAAV,CAAe1D,IAAI,CAACa,IAAL,CAAU,OAAV,CAAf;AACAyN,MAAAA,mBAAmB,CAAC5K,IAApB,CAAyB1D,IAAI,CAACwO,cAAL,CAAoB,OAApB,CAAzB;AACH,KAHD;AAIA,QAAIC,aAAa,GAAGpI,IAAI,CAACC,GAAL,CAASoI,KAAT,CAAerI,IAAf,EAAqBgI,SAArB,CAApB;AACA,QAAIM,kBAAkB,GAAGtI,IAAI,CAACC,GAAL,CAASoI,KAAT,CAAerI,IAAf,EAAqBiI,mBAArB,CAAzB;;AACA,SAAK,IAAInM,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGpB,IAAI,CAAC6K,aAAL,CAAmB9L,MAAzC,EAAiDoC,CAAC,GAAGC,GAArD,EAA0DD,CAAC,EAA3D,EAA+D;AAC3D4K,MAAAA,KAAK,GAAG/L,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,CAAR;AACAkL,MAAAA,gBAAgB,GAAG/Q,YAAY,CAAC0E,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,EAAsByM,YAAvB,CAA/B;AACA3B,MAAAA,WAAW,GAAGI,gBAAgB,GAAGrM,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,EAAsBqM,cAAzB,GAA0CxN,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,EAAsBtB,IAA9F;AACAqK,MAAAA,MAAM,GAAI/O,kBAAkB,CAAC6E,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,EAAsB8J,KAAvB,EAA8BjL,IAA9B,CAAlB,GAAwD/C,IAAI,CAACS,MAA9D,IAAyEb,KAAK,CAACgR,UAAN,GAAmB,CAAnB,GAAuB,CAAhG,CAAT;AACA3D,MAAAA,MAAM,GAAG7E,IAAI,CAACyI,KAAL,CAAY5D,MAAM,GAAG,CAAC,CAAX,IAAiBjN,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAA/B,CAAX,CAAT;AACAgP,MAAAA,UAAU,GAAKT,WAAW,CAACvO,MAAZ,GAAqB,CAAtB,GAA2BsC,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,EAAsB4M,IAAtB,CAA2BhP,MAAtD,GAA+D,CAA7E;AACA4N,MAAAA,WAAW,GAAKV,WAAW,CAACvO,MAAZ,GAAqB,CAAtB,GAA2B,CAA5B,GAAiC,CAA/C;AACAuP,MAAAA,cAAc,GAAGhQ,IAAI,CAACS,MAAL,GAAcsC,IAAI,CAAC6K,aAAL,CAAmB9L,MAAlD;AACAmO,MAAAA,WAAW,GAAI,CAAClN,IAAI,CAACgO,oBAAL,KAA8B,MAA9B,IAAwChO,IAAI,CAACgO,oBAAL,KAA8B,MAAvE,KAAkFxB,KAAK,KAAK,CAA5F,IACXP,WAAW,CAAC7O,KAAZ,GAAoB6P,cADV,GAC4BA,cAD5B,GAC6ChB,WAAW,CAAC7O,KADvE;AAEA8M,MAAAA,MAAM,GAAImC,gBAAgB,GAAIrM,IAAI,CAACoH,aAAL,KAAuB,QAAvB,GAAmC8C,MAAM,GAAI+B,WAAW,CAACvO,MAAZ,GAAqB,CAA/B,GAAoCgP,UAApC,GAAiDC,WAApF,GACvBzC,MAAM,GAAGwC,UADU,GACM1M,IAAI,CAACoH,aAAL,KAAuB,QAAvB,GAAkC8C,MAAM,GAAGyC,WAA3C,GAAyDzC,MADzF;;AAEA,UAAIlK,IAAI,CAAC+G,cAAL,CAAoB3J,KAApB,GAA4B4C,IAAI,CAACgH,cAAL,CAAoB5J,KAApD,EAA2D;AACvDwP,QAAAA,YAAY,GAAG5M,IAAI,CAAC+G,cAAL,CAAoB3J,KAAnC;AACH,OAFD,MAGK;AACDwP,QAAAA,YAAY,GAAG5M,IAAI,CAACgH,cAAL,CAAoB5J,KAAnC;AACH;;AACD,UAAI4C,IAAI,CAACiO,UAAL,CAAgBC,aAAhB,KAAkC,KAAtC,EAA6C;AACzChE,QAAAA,MAAM,GAAGA,MAAM,GAAG0C,YAAT,GAAwBC,KAAjC;AACH,OAFD,MAGK,IAAI7M,IAAI,CAACiO,UAAL,CAAgBC,aAAhB,KAAkC,MAAtC,EAA8C;AAC/ChE,QAAAA,MAAM,GAAGA,MAAM,GAAG0C,YAAT,GAAwBC,KAAjC;AACH,OAFI,MAGA,IAAI7M,IAAI,CAACiO,UAAL,CAAgBC,aAAhB,KAAkC,QAAtC,EAAgD;AACjD;AACAhE,QAAAA,MAAM,GAAGA,MAAT;AACH,OA5B0D,CA6B3D;;;AACA,UAAIoC,aAAJ,EAAmB;AACfa,QAAAA,WAAW,GAAGhB,YAAY,GAAI,CAACK,KAAK,KAAK,CAAV,GAAcP,WAAW,CAAC7O,KAA1B,GAAmCiP,gBAAgB,GAAGsB,kBAAH,GAAwBF,aAA5E,IAA8F,CAA5H;AACH,OAFD,MAGK;AACDN,QAAAA,WAAW,GAAGhB,YAAY,GAAI,CAACK,KAAK,KAAK,CAAV,GAAcP,WAAW,CAAC7O,KAA1B,GAAmCiP,gBAAgB,GAAGsB,kBAAH,GAAwBF,aAA5E,IAA8F,CAA5H;AACH;;AACDzB,MAAAA,MAAM,GAAG1B,SAAS,GAAIrN,IAAI,CAACO,CAAL,GAAS2P,WAAb,GAA6BlQ,IAAI,CAACO,CAAL,GAAS2P,WAAxD;AACAA,MAAAA,WAAW,GAAGhB,YAAd;AACAC,MAAAA,OAAO,GAAG,IAAIjQ,UAAJ,CAAeU,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB6C,KAAnB,GAA2B,aAA3B,GAA2CzH,CAA1D,EAA6D6K,MAA7D,EAAqE9B,MAArE,EAA6E,QAA7E,EAAuF6B,KAAK,CAACgC,IAA7F,EAAmG,EAAnG,EAAuG,QAAvG,CAAV;;AACA,cAAQ/N,IAAI,CAACmO,kBAAb;AACI,aAAK,MAAL;AACI;;AACJ,aAAK,MAAL;AACI,cAAK,CAAChN,CAAC,KAAK,CAAN,IAAY2L,SAAS,IAAI3L,CAAC,KAAKC,GAAG,GAAG,CAAtC,KAA6CgL,OAAO,CAAC3O,CAAR,GAAYR,IAAI,CAACQ,CAA/D,IACC,CAAE0D,CAAC,KAAKC,GAAG,GAAG,CAAb,IAAoB0L,SAAS,IAAI3L,CAAC,KAAK,CAAxC,KAA+CiL,OAAO,CAAC3O,CAAR,GAAYwO,WAAW,CAACvO,MAAZ,GAAqB,GAAjC,GAAuCT,IAAI,CAACQ,CADhG,EACoG;AAChG2O,YAAAA,OAAO,CAAC2B,IAAR,GAAe,EAAf;AACH;;AACD;;AACJ,aAAK,OAAL;AACI,cAAI,CAAC5M,CAAC,KAAK,CAAN,IAAY2L,SAAS,IAAI3L,CAAC,KAAKC,GAAG,GAAG,CAAtC,KAA6CgL,OAAO,CAAC3O,CAAR,GAAYR,IAAI,CAACQ,CAAlE,EAAqE;AACjE2O,YAAAA,OAAO,CAAC3O,CAAR,GAAYyM,MAAM,GAAGjN,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAAnC;AACH,WAFD,MAGK,IAAI,CAAEyD,CAAC,KAAKC,GAAG,GAAG,CAAb,IAAoB0L,SAAS,IAAI3L,CAAC,KAAK,CAAxC,KAAgDiL,OAAO,CAAC3O,CAAR,GAAYwO,WAAW,CAACvO,MAAZ,GAAqB,GAAjC,GAAuCT,IAAI,CAACQ,CAAhG,EAAoG;AACrG2O,YAAAA,OAAO,CAAC3O,CAAR,GAAYyM,MAAM,GAAGjN,IAAI,CAACQ,CAAL,GAASwO,WAAW,CAACvO,MAAZ,GAAqB,GAAnD;AACH;;AACD;AAhBR,OAvC2D,CAyD3D;;;AACA,UAAI0Q,cAAc,GAAGhC,OAAO,CAAC3O,CAA7B;AACA,UAAI4Q,aAAa,GAAGjC,OAAO,CAAC3O,CAAR,GAAYyP,WAAhC;;AACA,UAAIb,gBAAJ,EAAsB;AAClB+B,QAAAA,cAAc,GAAIhC,OAAO,CAAC3O,CAAR,GAAayP,WAAW,GAAG,CAA7C;AACAmB,QAAAA,aAAa,GAAGjC,OAAO,CAAC3O,CAAR,GAAayP,WAAW,GAAG,CAA3C;AACH;;AACD,UAAI,CAACV,KAAK,KAAK,EAAV,IAAgBA,KAAK,KAAK,GAA3B,KAAmCxM,IAAI,CAACgO,oBAAL,KAA8B,MAAjE,IAA2E7M,CAAC,KAAK,CAAjF,KACC,CAAC2L,SAAD,GAAasB,cAAc,IAAIpB,WAA/B,GAA6CqB,aAAa,IAAIrB,WAD/D,CAAJ,EACiF;AAC7E;AACH;;AACDA,MAAAA,WAAW,GAAGF,SAAS,GAAGsB,cAAH,GAAoBC,aAA3C,CApE2D,CAqE3D;;AACAjC,MAAAA,OAAO,CAACkC,SAAR,GAAoB,YAAY9B,KAAZ,GAAoB,GAApB,GAA0BR,MAA1B,GAAmC,GAAnC,GAAyC9B,MAAzC,GAAkD,GAAtE;AACA7N,MAAAA,WAAW,CAACQ,KAAK,CAACgJ,QAAP,EAAiBuG,OAAjB,EAA0BL,KAAK,CAACkC,UAAhC,EAA4ClC,KAAK,CAACkC,UAAN,CAAiBhG,KAAjB,IAA0BpL,KAAK,CAAC+M,UAAN,CAAiB2E,SAAvF,EAAkG9B,YAAlG,EAAgH,KAAhH,EAAuH5P,KAAK,CAACuL,MAA7H,EAAqI,IAArI,EAA2I,IAA3I,EAAiJ,IAAjJ,EAAuJ,IAAvJ,EAA6J,IAA7J,EAAmK,IAAnK,EAAyKvL,KAAK,CAAC+K,YAA/K,CAAX;AACH;;AACD,QAAI,CAAC,KAAK/K,KAAL,CAAW+K,YAAhB,EAA8B;AAC1B,UAAI,CAAC/K,KAAK,CAACqB,WAAX,EAAwB;AACpBxC,QAAAA,kBAAkB,CAACmB,KAAK,CAAC+K,YAAP,EAAqB4B,MAArB,EAA6BiD,YAA7B,EAA2C5P,KAAK,CAACuL,MAAjD,CAAlB;AACH,OAFD,MAGK,IAAIpI,IAAI,CAACwG,OAAL,IAAgBxG,IAAI,CAAC2G,kBAAzB,EAA6C;AAC9C,aAAK6H,kBAAL,CAAwB,KAAK3R,KAA7B,EAAoC4P,YAApC,EAAkDzM,IAAlD,EAAwD4I,KAAxD,EAA+D3L,IAA/D;AACH;AACJ;AACJ,GA3HD;AA4HA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIN,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC0R,kBAAnC,GAAwD,UAAUjR,CAAV,EAAawC,IAAb,EAAmB0O,SAAnB,EAA8B;AAClF,QAAIC,MAAM,GAAG3O,IAAI,CAAC4O,kBAAlB;AACA,QAAItC,aAAa,GAAGtM,IAAI,CAACoH,aAAL,KAAuB,QAA3C;AACA,QAAIkD,SAAS,GAAGtK,IAAI,CAAC+B,qBAArB;;AACA,QAAKuI,SAAS,IAAIgC,aAAd,IAAiC,CAAChC,SAAD,IAAc,CAACgC,aAApD,EAAoE;AAChE,aAAQqC,MAAM,KAAK,OAAX,GAAqBnR,CAArB,GAA0BmR,MAAM,KAAK,QAAX,GAAuBnR,CAAC,GAAGkR,SAAS,GAAG,CAAvC,GAA6ClR,CAAC,GAAGkR,SAAnF;AACH,KAFD,MAGK;AACD,aAAQC,MAAM,KAAK,MAAX,GAAoBnR,CAApB,GAAyBmR,MAAM,KAAK,QAAX,GAAuBnR,CAAC,GAAGkR,SAAS,GAAG,CAAvC,GAA6ClR,CAAC,GAAGkR,SAAlF;AACH;AACJ,GAVD;AAWA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI/R,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC2K,eAAnC,GAAqD,UAAU1H,IAAV,EAAgB4I,KAAhB,EAAuBY,MAAvB,EAA+BvM,IAA/B,EAAqC;AACtF,QAAI+C,IAAI,CAACgI,MAAL,CAAY5K,KAAZ,GAAoB,CAAxB,EAA2B;AACvB,UAAIyR,MAAM,GAAG,KAAK,CAAlB;AACA,UAAI3E,MAAM,GAAG,KAAK,CAAlB;AACA,UAAIjK,eAAe,GAAGD,IAAI,CAACoH,aAAL,KAAuB,SAAvB,GAAmCpH,IAAI,CAACC,eAAxC,GAA0D,CAAhF;AACA,UAAIqK,SAAS,GAAGtK,IAAI,CAAC+B,qBAArB;AACA9B,MAAAA,eAAe,GAAG,CAACqK,SAAS,GAAG,CAAH,GAAO,CAAC,CAAlB,IAAuBrK,eAAzC;AACA,UAAI6O,GAAG,GAAI7R,IAAI,CAACS,MAAL,GAAcsC,IAAI,CAAC2I,YAAL,CAAkBoG,KAAjC,IAA2C/O,IAAI,CAAC6D,SAAL,KAAmB,UAAnB,GAAgC7D,IAAI,CAACgP,gBAArC,GAC/ChP,IAAI,CAAC2I,YAAL,CAAkBuC,QADd,CAAV;AAEA,UAAI+D,IAAI,GAAG,KAAK,CAAhB;AACA,UAAIC,QAAQ,GAAGlP,IAAI,CAACmP,YAAL,CAAkB/R,KAAlB,GAA0B,EAA1B,IAAiC4C,IAAI,CAACkH,YAAL,KAAsBlH,IAAI,CAACoH,aAA5B,GAC3CpH,IAAI,CAACgH,cAAL,CAAoBtJ,MADuB,GACd,CADlB,CAAf;AAEA,UAAI0R,WAAW,GAAG,EAAlB;AACA,UAAI3E,aAAa,GAAIzK,IAAI,CAAC6D,SAAL,KAAmB,UAAnB,IAAiC7D,IAAI,CAAC0K,cAAL,KAAwB,cAA1D,GAA4E,CAAC,GAA7E,GAAmF,CAAvG;AACA,UAAI2E,IAAI,GAAK/E,SAAS,IAAItK,IAAI,CAACoH,aAAL,KAAuB,QAArC,IAAmD,CAACkD,SAAD,IACxDtK,IAAI,CAACoH,aAAL,KAAuB,SADnB,GACiCnK,IAAI,CAACO,CAAL,GAAS0R,QAAT,GAAoBjP,eADrD,GACuEhD,IAAI,CAACO,CAAL,GAAS0R,QAAT,GAAoBjP,eADtG;;AAEA,WAAK,IAAIkB,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGpB,IAAI,CAAC6K,aAAL,CAAmB9L,MAAzC,EAAiDoC,CAAC,GAAGC,GAArD,EAA0DD,CAAC,EAA3D,EAA+D;AAC3D+I,QAAAA,MAAM,GAAG/O,kBAAkB,CAAC6E,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,EAAsB8J,KAAtB,GAA8BR,aAA/B,EAA8CzK,IAA9C,CAA3B;AACAkK,QAAAA,MAAM,GAAG,CAAClK,IAAI,CAAC+M,aAAL,GAAsB,IAAI7C,MAA1B,GAAoCA,MAArC,IAA+CjN,IAAI,CAACS,MAA7D;;AACA,YAAIsC,IAAI,CAAC6D,SAAL,KAAmB,UAAnB,IAAiC7D,IAAI,CAAC0K,cAAL,KAAwB,cAA7D,EAA6E;AACzEmE,UAAAA,MAAM,GAAI3E,MAAM,GAAG,CAAC,CAAX,IAAiBjN,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAA/B,CAAT;AACAuR,UAAAA,IAAI,GAAI/E,MAAM,GAAG,CAAC,CAAX,GAAiB4E,GAAjB,IAAyB7R,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAAvC,CAAP;AACH,SAHD,MAIK;AACDmR,UAAAA,MAAM,GAAI3E,MAAM,GAAG,CAAC,CAAX,GAAgB4E,GAAG,GAAG,CAAtB,IAA2B7R,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAAzC,CAAT;AACAuR,UAAAA,IAAI,GAAI/E,MAAM,GAAG,CAAC,CAAX,GAAgB4E,GAAG,GAAG,CAAtB,IAA2B7R,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAAzC,CAAP;AACH;;AACD,gBAAQsC,IAAI,CAACgI,MAAL,CAAYhE,IAApB;AACI,eAAK,WAAL;AACA,eAAK,kBAAL;AACI,gBAAI6K,MAAM,GAAI5R,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAA5B,EAAqC;AACjC0R,cAAAA,WAAW,IAAK,MAAM,GAAN,GAAYC,IAAZ,GAAmB,GAAnB,IAA0BpS,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAAxC,IAAkD,GAAlD,GAAwD,GAAxD,GAA8D,GAA9D,GAAoE2R,IAApE,GAA2E,GAA3E,GAAiFJ,IAAjF,GAAwF,GAAxG;AACH,aAFD,MAGK,IAAI5J,IAAI,CAACyI,KAAL,CAAW7Q,IAAI,CAACQ,CAAhB,IAAsBwR,IAA1B,EAAiC;AAClCG,cAAAA,WAAW,IAAK,MAAM,GAAN,IAAanS,IAAI,CAACO,CAAL,GAASyC,eAAtB,IAAyC,GAAzC,GAA+C4O,MAA/C,GAAwD,GAAxD,GAA8D,GAA9D,GAAoE,GAApE,GAA0EQ,IAA1E,GACV,GADU,GACJR,MADI,GACK,GADL,GACW,GADX,GACiB,GADjB,GACuBQ,IADvB,GAC8B,GAD9B,GACqCpS,IAAI,CAACQ,CAD1C,GAC+C,GAD/D;AAEH,aAHI,MAIA;AACD2R,cAAAA,WAAW,IAAK,MAAM,GAAN,IAAanS,IAAI,CAACO,CAAL,GAASyC,eAAtB,IAAyC,GAAzC,GAA+C4O,MAA/C,GAAwD,GAAxD,GAA8D,GAA9D,GAAoE,GAApE,GAA0EQ,IAA1E,GACZ,GADY,GACNR,MADM,GACG,GADH,GACS,GADT,GACe,GADf,GACqBQ,IADrB,GAC4B,GAD5B,GACkCJ,IADlC,GACyC,GADzD;;AAEA,kBAAI9N,CAAC,KAAKnB,IAAI,CAAC6K,aAAL,CAAmB9L,MAAnB,GAA4B,CAAtC,EAAyC;AACrCqQ,gBAAAA,WAAW,IAAK,MAAM,GAAN,IAAanS,IAAI,CAACO,CAAL,GAASyC,eAAtB,IAAyC,GAAzC,GAA+CgP,IAA/C,GAAsD,GAAtD,GAA4D,GAA5D,GAAkE,GAAlE,GACZI,IADY,GACL,GADK,GACCJ,IADD,GACQ,GADxB;AAEH;AACJ;;AACD;;AACJ,eAAK,2BAAL;AACI,gBAAI,EAAEJ,MAAM,GAAG5R,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAAzB,KAAoC,EAAGuR,IAAD,GAAS5J,IAAI,CAACyI,KAAL,CAAW7Q,IAAI,CAACQ,CAAhB,CAAX,CAAxC,EAAwE;AACpE2R,cAAAA,WAAW,IAAK,MAAM,GAAN,IAAanS,IAAI,CAACO,CAAL,GAASyC,eAAtB,IAAyC,GAAzC,GAA+C4O,MAA/C,GAAwD,GAAxD,GAA8D,GAA9D,GAAoE,GAApE,GAA0EQ,IAA1E,GACZ,GADY,GACNR,MADM,GACG,GADH,GACS,GADT,GACe,GADf,GACqBQ,IADrB,GAC4B,GAD5B,GACkCJ,IADlC,GACyC,GADzC,GAEZ,GAFY,GAEN,GAFM,IAEChS,IAAI,CAACO,CAAL,GAASyC,eAFV,IAE6B,GAF7B,GAEmCgP,IAFnD;AAGH;;AACD;AAzBR;AA2BH;;AACDG,MAAAA,WAAW,IAAKpP,IAAI,CAACgI,MAAL,CAAYhE,IAAZ,KAAqB,WAAtB,GAAsC,MAAM,GAAN,IAAa/G,IAAI,CAACO,CAAL,GAASyC,eAAtB,IAAyC,GAAzC,GAA+ChD,IAAI,CAACQ,CAApD,GAAwD,GAAxD,GAA8D,GAA9D,GAAoE,GAApE,IAChDR,IAAI,CAACO,CAAL,GAASyC,eADuC,IACpB,GADoB,IACbhD,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MADD,IACW,GADjD,GACwD,EADvE;;AAEA,UAAI0R,WAAW,KAAK,EAApB,EAAwB;AACpB,aAAKE,uBAAL,CAA6BtP,IAA7B,EAAmC4I,KAAnC,EAA0CwG,WAA1C,EAAuD5F,MAAvD;AACH;AACJ;;AACD,QAAIxJ,IAAI,CAACuP,gBAAL,CAAsBxQ,MAAtB,GAA+B,CAA/B,IAAoC,KAAKlC,KAAL,CAAW2S,qBAAnD,EAA0E;AACtE,WAAK3S,KAAL,CAAW2S,qBAAX,CAAiCC,2BAAjC,CAA6DzP,IAA7D,EAAmE4I,KAAnE,EAA0EY,MAA1E,EAAkFvM,IAAlF;AACH;AACJ,GAhED;AAiEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIN,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC4K,cAAnC,GAAoD,UAAU3H,IAAV,EAAgB4I,KAAhB,EAAuBY,MAAvB,EAA+BvM,IAA/B,EAAqC;AACrF,QAAI+C,IAAI,CAAC0P,KAAT,EAAgB;AACZ,UAAI7S,KAAK,GAAG,KAAKA,KAAjB;AACA,UAAIyN,SAAS,GAAGtK,IAAI,CAAC+B,qBAArB;AACA,UAAI4N,aAAa,GAAGrF,SAAS,GAAG,EAAH,GAAQ,CAAC,EAAtC;AACA,UAAIxN,OAAO,GAAG,CAACkD,IAAI,CAACkH,YAAL,KAAsB,QAAtB,GAAiC,CAAjC,GAAqClH,IAAI,CAACgH,cAAL,CAAoBtJ,MAApB,GAA6BsC,IAAI,CAAC4P,YAAxE,KACT5P,IAAI,CAACoH,aAAL,KAAuB,QAAvB,GAAkC,CAAlC,GACIpH,IAAI,CAACmP,YAAL,CAAkB/R,KAAlB,GAA0B4C,IAAI,CAAC6P,qBAA/B,GAAuD,KAAK/S,OAFvD,CAAd;AAGAA,MAAAA,OAAO,GAAGwN,SAAS,GAAGxN,OAAO,GAAGkD,IAAI,CAACC,eAAlB,GAAoC,CAACnD,OAAD,GAAWkD,IAAI,CAACC,eAAvE;AACA,UAAIzC,CAAC,GAAGP,IAAI,CAACO,CAAL,GAASV,OAAjB;AACA,UAAIW,CAAC,GAAGR,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAAL,GAAc,GAA/B;AACA,UAAIoS,SAAS,GAAI9P,IAAI,CAAC8P,SAAL,CAAepS,MAAf,IAAyBsC,IAAI,CAAC+P,eAAL,CAAqBhR,MAArB,GAA8B,CAAvD,CAAjB;AACA,UAAIqN,OAAO,GAAG,IAAIjQ,UAAJ,CAAeU,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB,aAAnB,GAAmC6C,KAAlD,EAAyDpL,CAAzD,EAA4DC,CAAC,GAAGuC,IAAI,CAACmM,YAAT,GAAwB2D,SAApF,EAA+F,QAA/F,EAAyG9P,IAAI,CAAC+P,eAA9G,EAA+H,YAAYJ,aAAZ,GAA4B,GAA5B,GAAmCnS,CAAnC,GAAwC,GAAxC,GAA+CC,CAA/C,GAAoD,GAAnL,EAAwL,IAAxL,EAA8LkS,aAA9L,CAAd;AACA,UAAI3J,OAAO,GAAG3J,WAAW,CAACQ,KAAK,CAACgJ,QAAP,EAAiBuG,OAAjB,EAA0BpM,IAAI,CAACgQ,UAA/B,EAA2ChQ,IAAI,CAACgQ,UAAL,CAAgB/H,KAAhB,IAAyBpL,KAAK,CAAC+M,UAAN,CAAiBqG,SAArF,EAAgGzG,MAAhG,EAAwG,IAAxG,EAA8G,IAA9G,EAAoH,IAApH,EAA0H,IAA1H,EAAgI,IAAhI,EAAsI,IAAtI,EAA4I,IAA5I,EAAkJ,IAAlJ,EAAwJ3M,KAAK,CAAC+K,YAA9J,CAAzB;AACA5B,MAAAA,OAAO,CAACkK,YAAR,CAAqB,UAArB,EAAiClQ,IAAI,CAACmQ,QAAL,CAAcC,QAAd,EAAjC;AACApK,MAAAA,OAAO,CAACkK,YAAR,CAAqB,YAArB,EAAmClQ,IAAI,CAACqQ,WAAL,IAAoBrQ,IAAI,CAAC0P,KAA5D;AACH;AACJ,GAjBD;AAkBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI/S,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCkK,iBAAnC,GAAuD,UAAUjH,IAAV,EAAgB4I,KAAhB,EAAuBY,MAAvB,EAA+BvM,IAA/B,EAAqC;AACxF,QAAI8M,SAAS,GAAG/J,IAAI,CAAC6D,SAAL,KAAmB,aAAnC;AACA,QAAImG,cAAc,GAAGhK,IAAI,CAAC6D,SAAL,CAAee,OAAf,CAAuB,UAAvB,IAAqC,CAAC,CAA3D;AACA,QAAIqF,YAAJ;AACA,QAAI+B,MAAM,GAAG,CAAb;AACA,QAAI7B,SAAS,GAAG,EAAhB;AACA,QAAIC,SAAS,GAAG,EAAhB;AACA,QAAIkG,cAAJ;AACA,QAAIhG,SAAS,GAAGtK,IAAI,CAAC+B,qBAArB;AACA,QAAIwI,QAAQ,GAAID,SAAD,GAAc,CAACtK,IAAI,CAACgH,cAAL,CAAoBtJ,MAAnC,GAA4CsC,IAAI,CAACgH,cAAL,CAAoBtJ,MAA/E;AACA,QAAI8M,YAAY,GAAIF,SAAD,GAAc,CAACtK,IAAI,CAAC4G,SAAL,CAAexJ,KAAhB,GAAwB,GAAtC,GAA4C4C,IAAI,CAAC4G,SAAL,CAAexJ,KAAf,GAAuB,GAAtF;AACA,QAAI6C,eAAe,GAAGjF,iBAAiB,CAACgF,IAAI,CAACqD,SAAN,CAAjB,GAAoCiH,SAAS,GAAG,CAACtK,IAAI,CAACC,eAAT,GAC/DD,IAAI,CAACC,eADa,GACK,CAD3B;AAEA,QAAIwK,aAAa,GAAIzK,IAAI,CAAC6D,SAAL,CAAee,OAAf,CAAuB,UAAvB,IAAqC,CAAC,CAAtC,IAA2C5E,IAAI,CAAC0K,cAAL,KAAwB,cAApE,GAChB,GADgB,GACV,CADV;AAEA,QAAI3L,MAAM,GAAGiB,IAAI,CAAC6K,aAAL,CAAmB9L,MAAhC;AACA,QAAI4L,YAAY,GAAG3K,IAAI,CAACkH,YAAL,KAAsB,QAAzC;AACA,QAAI0D,KAAK,GAAGD,YAAY,GAAI1N,IAAI,CAACQ,CAAL,GAAS8M,QAAT,GAAoBC,YAAxB,GAAyCvN,IAAI,CAACQ,CAAL,GAAS8M,QAAT,GAAoBC,YAApB,GAAmCvK,eAApG;AACA,QAAI6K,eAAe,GAAG,KAAKjO,KAAL,CAAW+M,UAAjC;;AACA,QAAI5J,IAAI,CAAC6D,SAAL,CAAee,OAAf,CAAuB,UAAvB,IAAqC,CAAC,CAAtC,IAA2C7F,MAAM,GAAG,CAApD,IAAyDiB,IAAI,CAAC0K,cAAL,KAAwB,cAArF,EAAqG;AACjG3L,MAAAA,MAAM,IAAI,CAAV;AACH,KArBuF,CAsBxF;;;AACA,SAAK,IAAIoC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpC,MAApB,EAA4BoC,CAAC,EAA7B,EAAiC;AAC7B,UAAInB,IAAI,CAAC6D,SAAL,KAAmB,kBAAvB,EAA2C;AACvCoG,QAAAA,YAAY,GAAGjK,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,IAAwBnB,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,EAAsB8J,KAAtB,GAA8BR,aAAtD,GACRzK,IAAI,CAAC6K,aAAL,CAAmB1J,CAAC,GAAG,CAAvB,EAA0B8J,KAA1B,GAAkCjL,IAAI,CAAC2I,YAAL,CAAkBuC,QAArD,GAAiET,aADvE;AAEH,OAHD,MAIK;AACDR,QAAAA,YAAY,GAAGjK,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,IACXnB,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,EAAsB8J,KAAtB,GAA8BR,aADnB,GACmCzK,IAAI,CAAC2I,YAAL,CAAkBrD,GADpE;AAEH;;AACD0G,MAAAA,MAAM,GAAI7Q,kBAAkB,CAAC8O,YAAD,EAAejK,IAAf,CAAlB,GAAyC/C,IAAI,CAACG,KAA/C,GAAwDH,IAAI,CAACO,CAAtE;;AACA,UAAIwO,MAAM,IAAI/O,IAAI,CAACO,CAAf,IAAqBP,IAAI,CAACO,CAAL,GAASP,IAAI,CAACG,KAAf,IAAyB4O,MAAjD,EAAyD;AACrD,YAAIvQ,MAAM,CAACwO,YAAD,EAAejK,IAAI,CAAC2I,YAApB,CAAN,IAA2C,KAAKwC,QAAL,CAAcnL,IAAd,EAAoBmB,CAApB,EAAuB6K,MAAvB,CAA/C,EAA+E;AAC3E7B,UAAAA,SAAS,GAAG,OAAO6B,MAAP,GAAgB,GAAhB,IAAuB,KAAKzO,cAAL,CAAoBE,CAApB,GAAwB,KAAKF,cAAL,CAAoBG,MAAnE,IACR,KADQ,GACAsO,MADA,GACS,GADT,GACe,KAAKzO,cAAL,CAAoBE,CAD/C;AAEA,eAAK2N,cAAL,CAAoBpL,IAApB,EAA0B4I,KAA1B,EAAiCuB,SAAjC,EAA4CnK,IAAI,CAAC+G,cAAjD,EAAiE,iBAAjE,EAAoF5F,CAApF,EAAuF,KAAK6E,OAA5F,EAAqG8E,eAAe,CAACO,aAArH,EAAoIrL,IAAI,CAAC+G,cAAL,CAAoB4C,SAAxJ;AACH;;AACDS,QAAAA,SAAS,GAAG,OAAQ4B,MAAR,GAAkB,GAAlB,IAAyB/O,IAAI,CAACQ,CAAL,GAAS+M,YAAT,IAAyBG,YAAY,GAAG1K,eAAH,GAAqB,CAA1D,CAAzB,IACN,KADM,GACG+L,MADH,GACa,GADb,GACmBpB,KAD/B;AAEA,aAAKQ,cAAL,CAAoBpL,IAApB,EAA0B4I,KAA1B,EAAiCwB,SAAjC,EAA4CpK,IAAI,CAACgH,cAAjD,EAAiE,iBAAjE,EAAoF7F,CAApF,EAAuFqI,MAAvF,EAA+FsB,eAAe,CAACQ,aAA/G;;AACA,YAAItL,IAAI,CAACuL,qBAAL,GAA6B,CAA7B,KAAmCvL,IAAI,CAAC+K,cAAL,CAAoB3N,KAApB,GAA4B,CAA5B,IAAiC4C,IAAI,CAACgL,cAAL,CAAoB5N,KAApB,GAA4B,CAAhG,CAAJ,EAAwG;AACpG,cAAI+D,CAAC,KAAK,CAAN,IAAW1E,SAAS,CAACuD,IAAD,CAApB,IAA8B,CAAC+J,SAA/B,IAA4C,CAACC,cAAjD,EAAiE;AAC7D,iBAAKwB,wBAAL,CAA8BxL,IAA9B,EAAoCiK,YAApC,EAAkDhN,IAAlD,EAAwDkE,CAAxD,EAA2DyH,KAA3D,EAAkEkC,eAAlE,EAAmFtB,MAAnF;AACH;;AACD8G,UAAAA,cAAc,GAAG,KAAK7E,iBAAL,CAAuBzL,IAAvB,EAA6BiK,YAA7B,EAA2ChN,IAA3C,EAAiDkE,CAAjD,CAAjB;AACA,eAAKiK,cAAL,CAAoBpL,IAApB,EAA0B4I,KAA1B,EAAiC0H,cAAc,CAAC,CAAD,CAA/C,EAAoDtQ,IAAI,CAAC+K,cAAzD,EAAyE,iBAAzE,EAA4F5J,CAA5F,EAA+F,KAAK6E,OAApG,EAA6G8E,eAAe,CAACY,aAA7H,EAA4I1L,IAAI,CAAC+K,cAAL,CAAoBpB,SAAhK;AACA,eAAKyB,cAAL,CAAoBpL,IAApB,EAA0B4I,KAA1B,EAAiC0H,cAAc,CAAC,CAAD,CAA/C,EAAoDtQ,IAAI,CAACgL,cAAzD,EAAyE,iBAAzE,EAA4F7J,CAA5F,EAA+FqI,MAA/F,EAAuGsB,eAAe,CAACa,aAAvH;;AACA,cAAIxK,CAAC,KAAKpC,MAAM,GAAG,CAAf,IAAoBtC,SAAS,CAACuD,IAAD,CAA7B,IAAuC+J,SAAvC,IAAoD,CAACC,cAAzD,EAAyE;AACrE,iBAAKwB,wBAAL,CAA8BxL,IAA9B,EAAqCiK,YAAY,GAAGjK,IAAI,CAAC2I,YAAL,CAAkBuC,QAAtE,EAAiFjO,IAAjF,EAAuFkE,CAAvF,EAA0FyH,KAA1F,EAAiGkC,eAAjG,EAAkHtB,MAAlH;AACH;AACJ;AACJ;AACJ;AACJ,GAvDD;AAwDA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI7M,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCyO,wBAAnC,GAA8D,UAAUxL,IAAV,EAAgBiK,YAAhB,EAA8BhN,IAA9B,EAAoCkE,CAApC,EAAuCyH,KAAvC,EAA8CkC,eAA9C,EAA+DtB,MAA/D,EAAuE;AACjI,QAAI8G,cAAc,GAAG,KAAK7E,iBAAL,CAAuBzL,IAAvB,EAA6BiK,YAA7B,EAA2ChN,IAA3C,EAAiDkE,CAAjD,EAAoD,IAApD,CAArB;AACA,SAAKiK,cAAL,CAAoBpL,IAApB,EAA0B4I,KAA1B,EAAiC0H,cAAc,CAAC,CAAD,CAA/C,EAAoDtQ,IAAI,CAAC+K,cAAzD,EAAyE,iBAAzE,EAA4F,CAAC,CAA7F,EAAgG,KAAK/E,OAArG,EAA8G8E,eAAe,CAACY,aAA9H,EAA6I1L,IAAI,CAAC+K,cAAL,CAAoBpB,SAAjK;AACA,SAAKyB,cAAL,CAAoBpL,IAApB,EAA0B4I,KAA1B,EAAiC0H,cAAc,CAAC,CAAD,CAA/C,EAAoDtQ,IAAI,CAACgL,cAAzD,EAAyE,iBAAzE,EAA4F,CAAC,CAA7F,EAAgGxB,MAAhG,EAAwGsB,eAAe,CAACa,aAAxH;AACH,GAJD;AAKA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIhP,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC0O,iBAAnC,GAAuD,UAAUzL,IAAV,EAAgBiK,YAAhB,EAA8BhN,IAA9B,EAAoCsT,UAApC,EAAgDC,YAAhD,EAA8D;AACjH,QAAIvF,KAAK,GAAGhB,YAAZ;AACA,QAAIwG,IAAI,GAAG,CAAX;AACA,QAAIhS,QAAQ,GAAG,CAAf;AACA,QAAIiS,KAAK,GAAG1Q,IAAI,CAAC2I,YAAjB;AACA,QAAIgC,YAAY,GAAG3K,IAAI,CAACkH,YAAL,KAAsB,QAAzC;AACA,QAAIuC,SAAS,GAAG,EAAhB;AACA,QAAIc,QAAQ,GAAGvK,IAAI,CAAC+B,qBAAL,GAA6B,CAAC/B,IAAI,CAACgL,cAAL,CAAoBtN,MAAlD,GAA2DsC,IAAI,CAACgL,cAAL,CAAoBtN,MAA9F;AACA,QAAIiT,QAAJ;AACA,QAAIC,MAAJ;AACA,QAAIC,WAAW,GAAG,CAAlB;AACA,QAAIC,WAAW,GAAG,CAAlB;AACA,QAAIC,MAAM,GAAGpG,YAAY,GAAI1N,IAAI,CAACQ,CAAL,GAAS8M,QAAb,GAA0BtN,IAAI,CAACQ,CAAL,GAAS8M,QAA5D;AACA,QAAIyG,MAAM,GAAGrG,YAAY,GAAI1N,IAAI,CAACO,CAAL,GAAS+M,QAAb,GAA0BtN,IAAI,CAACO,CAAL,GAAS+M,QAA5D;AACA,QAAI0G,SAAS,GAAG,EAAhB;AACA,QAAIC,SAAS,GAAG,EAAhB;AACA,QAAIpE,SAAS,GAAG9M,IAAI,CAAC+M,aAArB;;AACA,QAAI/M,IAAI,CAAC6D,SAAL,KAAmB,aAAvB,EAAsC;AAClC8M,MAAAA,QAAQ,GAAGtL,IAAI,CAAC8L,GAAL,CAASnR,IAAI,CAACnE,OAAd,EAAuBoP,KAAK,GAAGyF,KAAK,CAACxF,QAArC,CAAX;AACA0F,MAAAA,MAAM,GAAGvL,IAAI,CAAC8L,GAAL,CAASnR,IAAI,CAACnE,OAAd,EAAuBoP,KAAvB,CAAT;AACA4F,MAAAA,WAAW,GAAG,CAACD,MAAM,GAAGD,QAAV,KAAuB3Q,IAAI,CAACuL,qBAAL,GAA6B,CAApD,CAAd;AACAuF,MAAAA,WAAW,GAAGH,QAAQ,GAAGE,WAAzB;AACH;;AACD,QAAI7Q,IAAI,CAACwC,WAAL,KAAqB,YAAzB,EAAuC;AACnC,WAAK,IAAInB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrB,IAAI,CAACuL,qBAAzB,EAAgDlK,CAAC,EAAjD,EAAqD;AACjD4J,QAAAA,KAAK,GAAG,KAAKmG,cAAL,CAAoBpR,IAApB,EAA0B8Q,WAA1B,EAAuC7F,KAAvC,EAA8CsF,UAA9C,EAA0DC,YAA1D,CAAR;AACAM,QAAAA,WAAW,IAAID,WAAf;;AACA,YAAIpV,MAAM,CAACwP,KAAD,EAAQyF,KAAR,CAAV,EAA0B;AACtBjS,UAAAA,QAAQ,GAAI,CAACwM,KAAK,GAAGyF,KAAK,CAACnL,GAAf,KAAuBmL,KAAK,CAACpL,GAAN,GAAYoL,KAAK,CAACnL,GAAzC,CAAZ;AACA9G,UAAAA,QAAQ,GAAG4G,IAAI,CAACgM,IAAL,CAAU,CAACvE,SAAS,GAAI,IAAIrO,QAAR,GAAoBA,QAA9B,IAA0CxB,IAAI,CAACG,KAAzD,CAAX;AACAqT,UAAAA,IAAI,GAAIpL,IAAI,CAACyI,KAAL,CAAWrP,QAAQ,GAAGxB,IAAI,CAACO,CAA3B,CAAR;AACAyT,UAAAA,SAAS,GAAGA,SAAS,CAACK,MAAV,CAAiB,MAAM,GAAN,GAAYb,IAAZ,GAAmB,GAAnB,GAA0B,KAAKlT,cAAL,CAAoBE,CAA9C,GACvB,IADuB,GAChBgT,IADgB,GACT,GADS,IACF,KAAKlT,cAAL,CAAoBE,CAApB,GAAwB,KAAKF,cAAL,CAAoBG,MAD1C,CAAjB,CAAZ;AAEA+S,UAAAA,IAAI,GAAIpL,IAAI,CAACyI,KAAL,CAAWrP,QAAQ,GAAGxB,IAAI,CAACO,CAA3B,CAAR;AACA0T,UAAAA,SAAS,GAAGA,SAAS,CAACI,MAAV,CAAiB,MAAM,GAAN,GAAYb,IAAZ,GAAmB,GAAnB,GAA0BxT,IAAI,CAACQ,CAA/B,GACvB,IADuB,GAChBgT,IADgB,GACT,GADS,IACFM,MAAM,GAAG/Q,IAAI,CAACC,eADZ,CAAjB,CAAZ;AAEH;AACJ;AACJ,KAfD,MAgBK;AACD,WAAK,IAAIoB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrB,IAAI,CAACuL,qBAAzB,EAAgDlK,CAAC,EAAjD,EAAqD;AACjD4J,QAAAA,KAAK,GAAG,KAAKmG,cAAL,CAAoBpR,IAApB,EAA0B8Q,WAA1B,EAAuC7F,KAAvC,EAA8CsF,UAA9C,EAA0DC,YAA1D,CAAR;;AACA,YAAI/U,MAAM,CAACwP,KAAD,EAAQyF,KAAR,CAAV,EAA0B;AACtBjS,UAAAA,QAAQ,GAAI,CAACwM,KAAK,GAAGyF,KAAK,CAACnL,GAAf,KAAuBmL,KAAK,CAACpL,GAAN,GAAYoL,KAAK,CAACnL,GAAzC,CAAZ;AACA9G,UAAAA,QAAQ,GAAG4G,IAAI,CAACgM,IAAL,CAAU,CAAEvE,SAAS,GAAI,IAAIrO,QAAR,GAAoBA,QAA/B,IAA4CxB,IAAI,CAACS,MAA3D,IAAqE,CAAC,CAAjF,CAFsB,CAE8D;;AACpF+S,UAAAA,IAAI,GAAIpL,IAAI,CAACyI,KAAL,CAAWrP,QAAQ,GAAGxB,IAAI,CAACQ,CAAhB,GAAoBR,IAAI,CAACS,MAApC,CAAR;AACAuT,UAAAA,SAAS,GAAGA,SAAS,CAACK,MAAV,CAAiB,MAAM,GAAN,GAAa,KAAK/T,cAAL,CAAoBC,CAAjC,GAAsC,GAAtC,GAA4CiT,IAA5C,GACvB,IADuB,IACf,KAAKlT,cAAL,CAAoBC,CAApB,GAAwB,KAAKD,cAAL,CAAoBH,KAD7B,IACsC,GADtC,GAC4CqT,IAD5C,GACmD,GADpE,CAAZ;AAEAA,UAAAA,IAAI,GAAIpL,IAAI,CAACyI,KAAL,CAAWrP,QAAQ,GAAGxB,IAAI,CAACQ,CAAhB,GAAoBR,IAAI,CAACS,MAApC,CAAR;AACAwT,UAAAA,SAAS,GAAGA,SAAS,CAACI,MAAV,CAAiB,MAAM,GAAN,GAAYrU,IAAI,CAACO,CAAjB,GAAqB,GAArB,GAA2BiT,IAA3B,GAAkC,IAAlC,IAA0CO,MAAM,GAAGhR,IAAI,CAACC,eAAxD,IACzB,GADyB,GACnBwQ,IADmB,GACZ,GADL,CAAZ;AAEH;;AACDK,QAAAA,WAAW,IAAID,WAAf;AACH;AACJ;;AACDpH,IAAAA,SAAS,CAAC/G,IAAV,CAAeuO,SAAf;AACAxH,IAAAA,SAAS,CAAC/G,IAAV,CAAewO,SAAf;AACA,WAAOzH,SAAP;AACH,GA1DD;AA2DA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI9M,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCqU,cAAnC,GAAoD,UAAUpR,IAAV,EAAgB8Q,WAAhB,EAA6B7F,KAA7B,EAAoCsF,UAApC,EAAgDC,YAAhD,EAA8D;AAC9G,QAAIE,KAAK,GAAG1Q,IAAI,CAAC2I,YAAjB;AACA,QAAI4I,SAAJ;;AACA,QAAIvR,IAAI,CAAC6D,SAAL,KAAmB,aAAvB,EAAsC;AAClCoH,MAAAA,KAAK,GAAGpP,OAAO,CAACiV,WAAD,EAAc9Q,IAAI,CAACnE,OAAnB,CAAf;AACH,KAFD,MAGK,IAAImE,IAAI,CAAC6D,SAAL,KAAmB,UAAvB,EAAmC;AACpC0N,MAAAA,SAAS,GAAGvR,IAAI,CAACgP,gBAAL,IAAyBhP,IAAI,CAACuL,qBAAL,GAA6B,CAAtD,CAAZ;AACAN,MAAAA,KAAK,GAAGuF,YAAY,GAAIvF,KAAK,GAAGsG,SAAZ,GAA0BtG,KAAK,GAAGsG,SAAtD;AACH,KAHI,MAIA,IAAIvR,IAAI,CAAC6D,SAAL,KAAmB,kBAAvB,EAA2C;AAC5C,UAAI/G,OAAO,GAAGkD,IAAI,CAAC0K,cAAL,KAAwB,cAAxB,GAAyC,GAAzC,GAA+C,CAA7D;AACAO,MAAAA,KAAK,IAAI,CAAC,CAACjL,IAAI,CAAC6K,aAAL,CAAmB0F,UAAU,GAAG,CAAhC,IACPvQ,IAAI,CAAC6K,aAAL,CAAmB0F,UAAU,GAAG,CAAhC,EAAmCtF,KAAnC,GAA2CnO,OADpC,GAC8CkD,IAAI,CAAC2I,YAAL,CAAkBrD,GADjE,KAELtF,IAAI,CAAC6K,aAAL,CAAmB0F,UAAnB,IACGvQ,IAAI,CAAC6K,aAAL,CAAmB0F,UAAnB,EAA+BtF,KAA/B,GAAuCnO,OAD1C,GACoDkD,IAAI,CAAC2I,YAAL,CAAkBpD,GAHjE,CAAD,KAIJvF,IAAI,CAACuL,qBAAL,GAA6B,CAJzB,CAAT;AAKH,KAPI,MAQA;AACDgG,MAAAA,SAAS,GAAGb,KAAK,CAACxF,QAAN,IAAkBlL,IAAI,CAACuL,qBAAL,GAA6B,CAA/C,CAAZ;AACAN,MAAAA,KAAK,GAAGuF,YAAY,GAAIvF,KAAK,GAAGsG,SAAZ,GAA0BtG,KAAK,GAAGsG,SAAtD;AACH;;AACD,WAAOtG,KAAP;AACH,GAvBD;AAwBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACItO,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCoK,eAAnC,GAAqD,UAAUnH,IAAV,EAAgB4I,KAAhB,EAAuBY,MAAvB,EAA+BvM,IAA/B,EAAqC;AACtF,QAAIJ,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAImP,MAAM,GAAG,CAAb;AACA,QAAI9B,MAAM,GAAG,CAAb;AACA,QAAIgC,UAAU,GAAGlM,IAAI,CAACmM,YAAtB;AACA,QAAIe,WAAJ;AACA,QAAIjB,WAAJ;AACA,QAAIE,YAAJ;AACA,QAAIwC,MAAJ;AACA,QAAI9B,KAAK,GAAG,EAAZ;AACA,QAAIJ,YAAY,GAAG5P,KAAK,CAACgJ,QAAN,CAAeC,WAAf,CAA2B;AAAEC,MAAAA,EAAE,EAAElJ,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB,YAAnB,GAAkC6C;AAAxC,KAA3B,CAAnB;AACA,QAAI4I,aAAa,GAAGxR,IAAI,CAACoH,aAAL,KAAuB,QAA3C;AACA,QAAIkD,SAAS,GAAGtK,IAAI,CAAC+B,qBAArB;AACA,QAAIwK,SAAS,GAAGvM,IAAI,CAACoH,aAAL,KAAuBpH,IAAI,CAACkH,YAA5B,GAA2ClH,IAAI,CAACgH,cAAL,CAAoBtJ,MAA/D,GAAwE,CAAxF;AACA,QAAIZ,OAAO,GAAGyP,SAAS,GAAGL,UAAZ,GAAyBlM,IAAI,CAAC4G,SAAL,CAAexJ,KAAf,GAAuB,GAA9D;AACA,QAAIoP,KAAK,GAAGxM,IAAI,CAACwM,KAAL,GAAa,GAAzB;AACA,QAAIiF,iBAAiB,GAAIjF,KAAK,KAAK,CAAV,IAAeA,KAAK,KAAK,CAAC,GAA1B,IAAiCA,KAAK,KAAK,GAApE;AACA,QAAIJ,OAAJ;AACA,QAAIsF,UAAJ;AACA,QAAI5E,SAAS,GAAG9M,IAAI,CAAC+M,aAArB;AACA,QAAIC,WAAW,GAAGF,SAAS,GAAI7P,IAAI,CAACO,CAAL,GAASP,IAAI,CAACG,KAAlB,GAA2BH,IAAI,CAACO,CAA3D;AACA,QAAIJ,KAAK,GAAG,CAAZ;AACA,QAAI2B,MAAM,GAAGiB,IAAI,CAAC6K,aAAL,CAAmB9L,MAAhC;AACA,QAAIkO,cAAJ;AACA,QAAIlB,KAAJ;AACA,QAAIM,gBAAJ;AACA,QAAIpM,eAAe,GAAGD,IAAI,CAACU,iBAAL,CAAuBC,MAAvB,IAAkC,CAAC6Q,aAAD,IAAkBxW,iBAAiB,CAACgF,IAAI,CAACqD,SAAN,CAAnC,KAChDrD,IAAI,CAACQ,UAAL,GAAkB,CAAlB,IAAuBR,IAAI,CAACS,YAAL,GAAoB,CADK,CAAlC,GACmCT,IAAI,CAACC,eADxC,GAC0D,CADhF;AAEA,QAAI0R,SAAS,GAAG,EAAhB;AACA,QAAIC,uBAAuB,GAAG,KAA9B;AACA9U,IAAAA,OAAO,IAAK0P,KAAK,KAAK,EAAV,IAAgBA,KAAK,KAAK,GAA1B,IAAiCA,KAAK,KAAK,CAAC,EAA5C,IAAkDA,KAAK,KAAK,CAAC,GAA9D,GAAsEgF,aAAa,GAAG,CAAH,GAAO,CAAC,CAA3F,GAAgG,CAA3G;AACA,QAAIK,oBAAoB,GAAK,CAACvH,SAAD,IAAc,CAACkH,aAAhB,IAAmClH,SAAS,IAAIkH,aAA5E;AACA,QAAIM,WAAW,GAAGD,oBAAoB,GAChC,OAAOrF,KAAP,IAAgBA,KAAK,IAAI,GAA1B,IAAmC,CAAC,CAAD,IAAMA,KAAN,IAAeA,KAAK,IAAI,CAAC,GAD3B,GAEhC,KAAKA,KAAL,IAAcA,KAAK,IAAI,GAAxB,IAAiC,CAAC,GAAD,IAAQA,KAAR,IAAiBA,KAAK,IAAI,CAAC,GAFjE;;AAGA,SAAK,IAAIrL,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGrC,MAAtB,EAA8BoC,CAAC,GAAGC,GAAlC,EAAuCD,CAAC,EAAxC,EAA4C;AACxC4K,MAAAA,KAAK,GAAG/L,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,CAAR;AACAkL,MAAAA,gBAAgB,GAAG/Q,YAAY,CAACyQ,KAAK,CAAC6B,YAAP,CAA/B;AACA5B,MAAAA,MAAM,GAAI7Q,kBAAkB,CAAC4Q,KAAK,CAACd,KAAP,EAAcjL,IAAd,CAAlB,GAAwC/C,IAAI,CAACG,KAA9C,GAAuDH,IAAI,CAACO,CAArE;AACAyO,MAAAA,WAAW,GAAGF,KAAK,CAAClM,IAApB;AACAoN,MAAAA,cAAc,GAAGhQ,IAAI,CAACG,KAAL,GAAa2B,MAA9B;AACA2S,MAAAA,UAAU,GAAGrF,gBAAgB,GAAGN,KAAK,CAACyB,cAAN,CAAqBpQ,KAAxB,GAAgC6O,WAAW,CAAC7O,KAAzE;AACAA,MAAAA,KAAK,GAAI,CAAC4C,IAAI,CAACgO,oBAAL,KAA8B,MAA9B,IAAwChO,IAAI,CAACgO,oBAAL,KAA8B,MAAvE,KAAkFxB,KAAK,KAAK,CAA5F,IACLkF,UAAU,GAAGzE,cADT,GAC2BA,cAD3B,GAC4CyE,UADpD;AAEAxE,MAAAA,WAAW,GAAGjB,WAAW,CAACvO,MAAZ,GAAqB,CAAnC;AACAsO,MAAAA,MAAM,IAAKK,gBAAgB,IAAIG,KAAK,KAAK,CAA/B,GAAoC,CAApC,GAAyCpP,KAAK,GAAG,CAA3D,CAVwC,CAWxC;;AACA,UAAIoP,KAAK,KAAK,CAAd,EAAiB;AACb,YAAIH,gBAAJ,EAAsB;AAClBL,UAAAA,MAAM,IAAIhM,IAAI,CAAC4O,kBAAL,KAA4B,MAA5B,GAAsC7C,KAAK,CAACyB,cAAN,CAAqBpQ,KAArB,GAA6B,CAAnE,GAAwE4C,IAAI,CAAC4O,kBAAL,KAA4B,OAA5B,GAC9E,EAAE7C,KAAK,CAACyB,cAAN,CAAqBpQ,KAArB,GAA6B,CAA/B,CAD8E,GAC1C,CADxC;AAEH,SAHD,MAIK;AACD4O,UAAAA,MAAM,IAAKQ,KAAK,KAAK,CAAC,EAAX,IAAiBA,KAAK,KAAK,GAA3B,GAAiC,CAACU,WAAlC,GAAiDV,KAAK,KAAK,EAAV,IAAgBA,KAAK,KAAK,CAAC,GAA5B,GAAmCU,WAAnC,GAAiD,CAA5G;AACH;AACJ,OApBuC,CAqBxC;;;AACA,UAAIlN,IAAI,CAACiO,UAAL,CAAgBC,aAAhB,KAAkC,KAAtC,EAA6C;AACzClC,QAAAA,MAAM,GAAGA,MAAM,GAAG5O,KAAT,GAAiByP,KAA1B;AACH,OAFD,MAGK,IAAI7M,IAAI,CAACiO,UAAL,CAAgBC,aAAhB,KAAkC,MAAtC,EAA8C;AAC/ClC,QAAAA,MAAM,GAAGA,MAAM,GAAG5O,KAAT,GAAiByP,KAA1B;AACH,OAFI,MAGA,IAAI7M,IAAI,CAACiO,UAAL,CAAgBC,aAAhB,KAAkC,QAAtC,EAAgD;AACjD;AACAlC,QAAAA,MAAM,GAAGA,MAAT;AACH,OA/BuC,CAgCxC;;;AACA,UAAIK,gBAAgB,IAAIrM,IAAI,CAAC4O,kBAAL,KAA4B,QAAhD,IAA4DpC,KAAK,KAAK,CAA1E,EAA6E;AACzER,QAAAA,MAAM,IAAIhM,IAAI,CAAC4O,kBAAL,KAA4B,MAA5B,GAAqC,EAAExR,KAAK,GAAG,CAAV,CAArC,GAAqDA,KAAK,GAAG,CAAvE;AACH;;AACD,UAAI2U,oBAAoB,GAAG1F,gBAAgB,GACtCoF,iBAAiB,GAAIxF,WAAW,CAACvO,MAAhB,GAA2BqO,KAAK,CAACyB,cAAN,CAAqBpQ,KAArB,GAA6B,CADnC,GACyC,CADpF;AAEAN,MAAAA,OAAO,GAAGuP,gBAAgB,GAAIE,SAAS,GAAGL,UAAZ,GAAyBlM,IAAI,CAAC4G,SAAL,CAAexJ,KAAf,GAAuB,GAApD,GAA2DN,OAArF,CAtCwC,CAuCxC;;AACA,UAAI0U,aAAa,IAAIhF,KAArB,EAA4B;AACxB,YAAIH,gBAAJ,EAAsB;AAClBnC,UAAAA,MAAM,GAAGI,SAAS,GAAIrN,IAAI,CAACQ,CAAL,GAASX,OAAT,GAAoBiV,oBAAxB,GAAkD9U,IAAI,CAACQ,CAAL,GAASX,OAAT,GAAoBiV,oBAAxF;AACH,SAFD,MAGK;AACD7H,UAAAA,MAAM,GAAGI,SAAS,GAAIrN,IAAI,CAACQ,CAAL,GAASX,OAAT,GAAmBoQ,WAAvB,GAAuCjQ,IAAI,CAACQ,CAAL,GAASX,OAAT,GAAmBoQ,WAA5E;AACH;AACJ,OAPD,MAQK;AACD,YAAIb,gBAAJ,EAAsB;AAClBF,UAAAA,YAAY,GAAG,CAAC0F,oBAAD,GAAwB,EAAE/U,OAAO,GAAGmD,eAAV,GAA6B8R,oBAA/B,CAAxB,GACXjV,OAAO,GAAGmD,eAAV,IAA6BuM,KAAK,GAAGuF,oBAAH,GAA2B,IAAI7E,WAAjE,CADJ;AAEH,SAHD,MAIK;AACDf,UAAAA,YAAY,GAAG,CAAC0F,oBAAD,GACX,EAAE/U,OAAO,GAAGmD,eAAV,IAA6BuM,KAAK,GAAGU,WAAH,GAAkBnB,KAAK,CAACnD,KAAN,GAAc,CAAd,GAAmB,IAAIsE,WAAvB,GAAsC,CAA1F,CAAF,CADW,GAEXpQ,OAAO,GAAGmD,eAAV,GAA6B,CAACuM,KAAK,GAAG,CAAH,GAAO,CAAb,IAAkBU,WAFnD;AAGH;;AACDhD,QAAAA,MAAM,GAAIjN,IAAI,CAACQ,CAAL,GAAU0O,YAAY,GAAGJ,KAAK,CAACnD,KAAzC;AACH,OA3DuC,CA4DxC;;;AACA,UAAIyD,gBAAJ,EAAsB;AAClBsC,QAAAA,MAAM,GAAG,KAAKqD,SAAL,CAAehS,IAAf,CAAT,CADkB,CACa;AAClC,OAFD,MAGK;AACD2O,QAAAA,MAAM,GAAI9R,KAAK,CAACmG,SAAP,GAAsB8O,WAAD,GAAgB,EAAhB,GAAqB,KAA1C,GAAoDjV,KAAK,CAACoV,YAAN,IAAsBH,WAAvB,GAAsC,KAAtC,GAA8C,EAA1G;AACH;;AACD1F,MAAAA,OAAO,GAAG,IAAIjQ,UAAJ,CAAeU,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB6C,KAAnB,GAA2B,aAA3B,GAA2CzH,CAA1D,EAA6D6K,MAA7D,EAAqE9B,MAArE,EAA6EyE,MAA7E,CAAV;;AACA,UAAI3O,IAAI,CAACmO,kBAAL,IAA4B3B,KAAK,KAAK,CAA1C,EAA8C;AAC1C,gBAAQxM,IAAI,CAACmO,kBAAb;AACI,eAAK,MAAL;AACI;;AACJ,eAAK,MAAL;AACI,gBAAK,CAAChN,CAAC,KAAK,CAAN,IAAY2L,SAAS,IAAI3L,CAAC,KAAKC,GAAG,GAAG,CAAtC,KAA6CgL,OAAO,CAAC5O,CAAR,GAAYP,IAAI,CAACO,CAA/D,IACC,CAAC2D,CAAC,KAAKC,GAAG,GAAG,CAAZ,IAAkB0L,SAAS,IAAI3L,CAAC,KAAK,CAAtC,KAA8CiL,OAAO,CAAC5O,CAAR,GAAYJ,KAAZ,GAAoBH,IAAI,CAACO,CAAL,GAASP,IAAI,CAACG,KADrF,EAC8F;AAC1F;AACH;;AACD;;AACJ,eAAK,OAAL;AACI,gBAAI,CAAC+D,CAAC,KAAK,CAAN,IAAY2L,SAAS,IAAI3L,CAAC,KAAKC,GAAG,GAAG,CAAtC,KAA6CgL,OAAO,CAAC5O,CAAR,GAAYP,IAAI,CAACO,CAAlE,EAAqE;AACjEyP,cAAAA,cAAc,IAAKhQ,IAAI,CAACO,CAAL,GAAS4O,OAAO,CAAC5O,CAApC;AACA4O,cAAAA,OAAO,CAAC5O,CAAR,GAAYwO,MAAM,GAAG/O,IAAI,CAACO,CAA1B;AACH,aAHD,MAIK,IAAI,CAAC2D,CAAC,KAAKC,GAAG,GAAG,CAAZ,IAAkB0L,SAAS,IAAI3L,CAAC,KAAK,CAAtC,KAA+CiL,OAAO,CAAC5O,CAAR,GAAYJ,KAAb,GAAsBH,IAAI,CAACO,CAAL,GAASP,IAAI,CAACG,KAAtF,EAA8F;AAC/F,kBAAI6O,WAAW,CAAC7O,KAAZ,GAAoB6P,cAApB,IAAsCjN,IAAI,CAACgO,oBAAL,KAA8B,MAAxE,EAAgF;AAC5Ef,gBAAAA,cAAc,IAAKb,OAAO,CAAC5O,CAAR,GAAYJ,KAAZ,IAAqBH,IAAI,CAACO,CAAL,GAASP,IAAI,CAACG,KAAnC,CAAnB;AACH,eAFD,MAGK;AACD6P,gBAAAA,cAAc,GAAG7P,KAAjB;AACH;;AACDgP,cAAAA,OAAO,CAAC5O,CAAR,GAAYwO,MAAM,GAAG/O,IAAI,CAACO,CAAL,GAASP,IAAI,CAACG,KAAd,GAAsB6P,cAA3C;AACH;;AACD;AAvBR;AAyBH;;AACDb,MAAAA,OAAO,CAAC2B,IAAR,GAAe,KAAKmE,YAAL,CAAkBnG,KAAlB,EAAyB/L,IAAzB,EAA+BiN,cAA/B,CAAf,CA/FwC,CAgGxC;AACA;;AACA,UAAIkF,MAAM,GAAG,KAAK,CAAlB;AACA,UAAIC,OAAO,GAAG,KAAK,CAAnB;;AACA,UAAI/F,gBAAgB,IAAIG,KAAK,KAAK,CAAlC,EAAqC;AACjC,YAAIxM,IAAI,CAAC4O,kBAAL,KAA4B,OAAhC,EAAyC;AACrCuD,UAAAA,MAAM,GAAI/F,OAAO,CAAC5O,CAAR,GAAYJ,KAAtB;AACAgV,UAAAA,OAAO,GAAGhG,OAAO,CAAC5O,CAAlB;AACH,SAHD,MAIK,IAAIwC,IAAI,CAAC4O,kBAAL,KAA4B,QAAhC,EAA0C;AAC3CuD,UAAAA,MAAM,GAAI/F,OAAO,CAAC5O,CAAR,GAAaJ,KAAK,GAAG,CAA/B;AACAgV,UAAAA,OAAO,GAAGhG,OAAO,CAAC5O,CAAR,GAAaJ,KAAK,GAAG,CAA/B;AACH,SAHI,MAIA;AACD+U,UAAAA,MAAM,GAAG/F,OAAO,CAAC5O,CAAjB;AACA4U,UAAAA,OAAO,GAAGhG,OAAO,CAAC5O,CAAR,GAAYJ,KAAtB;AACH;AACJ,OAbD,MAcK;AACD+U,QAAAA,MAAM,GAAG/F,OAAO,CAAC5O,CAAjB;AACA4U,QAAAA,OAAO,GAAGhG,OAAO,CAAC5O,CAAR,GAAYJ,KAAtB;AACH,OArHuC,CAsHxC;;;AACA,UAAIoP,KAAK,KAAK,CAAV,IAAexM,IAAI,CAACgO,oBAAL,KAA8B,MAA7C,IAAuD7M,CAAC,KAAK,CAA7D,KACC,CAAC2L,SAAD,GAAaqF,MAAM,IAAInF,WAAvB,GAAqCoF,OAAO,IAAIpF,WADjD,CAAJ,EACmE;AAC/D;AACH,OA1HuC,CA2HxC;;;AACA,UAAIX,gBAAJ,EAAsB;AAClB,YAAIrM,IAAI,CAAC4O,kBAAL,KAA4B,OAAhC,EAAyC;AACrC5B,UAAAA,WAAW,GAAGF,SAAS,GAAIV,OAAO,CAAC5O,CAAR,GAAYJ,KAAhB,GAAyBgP,OAAO,CAAC5O,CAAxD;AACH,SAFD,MAGK,IAAIwC,IAAI,CAAC4O,kBAAL,KAA4B,QAAhC,EAA0C;AAC3C5B,UAAAA,WAAW,GAAGF,SAAS,GAAIV,OAAO,CAAC5O,CAAR,GAAaJ,KAAK,GAAG,CAAzB,GAA+BgP,OAAO,CAAC5O,CAAR,GAAaJ,KAAK,GAAG,CAA3E;AACH,SAFI,MAGA;AACD4P,UAAAA,WAAW,GAAGF,SAAS,GAAGV,OAAO,CAAC5O,CAAX,GAAe4O,OAAO,CAAC5O,CAAR,GAAYJ,KAAlD;AACH;AACJ,OAVD,MAWK;AACD4P,QAAAA,WAAW,GAAGF,SAAS,GAAGV,OAAO,CAAC5O,CAAX,GAAe4O,OAAO,CAAC5O,CAAR,GAAYJ,KAAlD;AACH,OAzIuC,CA0IxC;AACA;AACA;;;AACA,UAAIoP,KAAK,KAAK,CAAd,EAAiB;AACb,YAAI9O,MAAM,GAAG,KAAK,CAAlB;AACA,YAAI2U,MAAM,GAAG,KAAK,CAAlB;;AACA,YAAIhG,gBAAJ,EAAsB;AAClB,cAAIiG,WAAW,GAAG,CAAlB;AACA,cAAIC,WAAW,GAAG,CAAlB;AACA7U,UAAAA,MAAM,GAAIqO,KAAK,CAACyB,cAAN,CAAqB9P,MAA/B;AACA6U,UAAAA,WAAW,GAAIxG,KAAK,CAACyB,cAAN,CAAqB9P,MAAtB,GAAgC,CAA9C,CAJkB,CAI+B;AACjD;;AACA,cAAIsC,IAAI,CAAC4O,kBAAL,KAA4B,QAAhC,EAA0C;AACtC0D,YAAAA,WAAW,GAAG,EAAEvG,KAAK,CAACyB,cAAN,CAAqBpQ,KAArB,GAA6B,CAA/B,CAAd;AACH,WAFD,MAGK,IAAI4C,IAAI,CAAC4O,kBAAL,KAA4B,OAAhC,EAAyC;AAC1C0D,YAAAA,WAAW,GAAG,CAACvG,KAAK,CAACyB,cAAN,CAAqBpQ,KAApC;AACH,WAXiB,CAYlB;;;AACA,cAAIyU,oBAAJ,EAA0B;AACtBU,YAAAA,WAAW,GAAIxG,KAAK,CAACyB,cAAN,CAAqB9P,MAAtB,IAAiC0O,OAAO,CAAC2B,IAAR,CAAahP,MAAb,GAAsB,CAAvD,CAAd;AACH;;AACDsT,UAAAA,MAAM,GAAG,IAAIpW,IAAJ,CAASmQ,OAAO,CAAC5O,CAAR,GAAY8U,WAArB,EAAkClG,OAAO,CAAC3O,CAAR,GAAa8U,WAA/C,EAA6DxG,KAAK,CAACyB,cAAN,CAAqBpQ,KAAlF,EAAyFM,MAAzF,CAAT;AACH,SAjBD,MAkBK;AACDA,UAAAA,MAAM,GAAIwM,MAAD,IAAYkC,OAAO,CAAC3O,CAAR,IAAcsO,KAAK,CAAClM,IAAN,CAAWnC,MAAX,GAAoB,CAArB,GAA0B,EAAvC,CAAZ,CAAT;AACA2U,UAAAA,MAAM,GAAG,IAAIpW,IAAJ,CAASmQ,OAAO,CAAC5O,CAAjB,EAAoB4O,OAAO,CAAC3O,CAAR,IAAcsO,KAAK,CAAClM,IAAN,CAAWnC,MAAX,GAAoB,CAArB,GAA0B,CAAvC,CAApB,EAA+DqO,KAAK,CAAClM,IAAN,CAAWzC,KAA1E,EAAiFM,MAAjF,CAAT;AACH;;AACD,YAAI8U,eAAe,GAAG,KAAKC,kBAAL,CAAwBJ,MAAxB,CAAtB;AACA,YAAIK,WAAW,GAAGrG,gBAAgB,GAAGgG,MAAM,CAAC7U,CAAP,GAAY6U,MAAM,CAACjV,KAAP,GAAe,CAA9B,GAAmC4O,MAArE;AACA,YAAI2G,WAAW,GAAGtG,gBAAgB,GAAGgG,MAAM,CAAC5U,CAAP,GAAY4U,MAAM,CAAC3U,MAAP,GAAgB,CAA/B,GAAqCwM,MAAM,GAAIxM,MAAM,GAAG,CAA1F;;AACA,YAAI2O,gBAAJ,EAAsB;AAClBD,UAAAA,OAAO,CAACkC,SAAR,GAAoB,YAAY9B,KAAZ,GAAoB,GAApB,GAA0BkG,WAA1B,GAAwC,GAAxC,GAA8CC,WAA9C,GAA4D,GAAhF;AACH,SAFD,MAGK;AACDvG,UAAAA,OAAO,CAACkC,SAAR,GAAoB,YAAY9B,KAAZ,GAAoB,GAApB,GAA0BR,MAA1B,GAAmC,GAAnC,GAAyC9B,MAAzC,GAAkD,GAAtE;AACH;;AACDyH,QAAAA,SAAS,CAACjP,IAAV,CAAenG,8BAA8B,CAACiW,eAAD,EAAkBE,WAAlB,EAA+BC,WAA/B,EAA4CnG,KAA5C,CAA7C;AACAoF,QAAAA,uBAAuB,GAAG,KAA1B;;AACA,aAAK,IAAIgB,OAAO,GAAGzR,CAAnB,EAAsByR,OAAO,GAAG,CAAhC,EAAmCA,OAAO,EAA1C,EAA8C;AAC1C,cAAIjB,SAAS,CAACxQ,CAAD,CAAT,IAAgBwQ,SAAS,CAACiB,OAAO,GAAG,CAAX,CAAzB,IAA0CpW,sBAAsB,CAACmV,SAAS,CAACxQ,CAAD,CAAV,EAAewQ,SAAS,CAACiB,OAAO,GAAG,CAAX,CAAxB,CAApE,EAA4G;AACxGhB,YAAAA,uBAAuB,GAAG,IAA1B;AACAD,YAAAA,SAAS,CAACxQ,CAAD,CAAT,GAAe,IAAf;AACA;AACH;AACJ;AACJ,OAxLuC,CAyLxC;;;AACA9E,MAAAA,WAAW,CAACQ,KAAK,CAACgJ,QAAP,EAAiBuG,OAAjB,EAA0BL,KAAK,CAACkC,UAAhC,EAA4ClC,KAAK,CAACkC,UAAN,CAAiBhG,KAAjB,IAA0BpL,KAAK,CAAC+M,UAAN,CAAiB2E,SAAvF,EAAkG9B,YAAlG,EAAiHzM,IAAI,CAAC+B,qBAAL,MAAgC/B,IAAI,CAACoH,aAAL,KAAuB,QAAvD,CAAjH,EAAoLvK,KAAK,CAACuL,MAA1L,EAAkM,IAAlM,EAAwM,IAAxM,EAA8M,IAA9M,EAAoN,IAApN,EAA0N2D,KAAK,CAAClM,IAAhO,EAAsO+R,uBAAtO,EAA+P/U,KAAK,CAAC+K,YAArQ,CAAX;AACH;;AACD,QAAI,CAAC,KAAK/K,KAAL,CAAW+K,YAAhB,EAA8B;AAC1B,UAAI,CAAC/K,KAAK,CAACqB,WAAX,EAAwB;AACpBsL,QAAAA,MAAM,CAAC3B,WAAP,CAAmB4E,YAAnB;AACH,OAFD,MAGK,IAAIzM,IAAI,CAACwG,OAAL,IAAgBxG,IAAI,CAAC2G,kBAAzB,EAA6C;AAC9C,aAAK6H,kBAAL,CAAwB,KAAK3R,KAA7B,EAAoC4P,YAApC,EAAkDzM,IAAlD,EAAwD4I,KAAxD,EAA+D3L,IAA/D;AACH;AACJ;AACJ,GAvOD;AAwOA;AACJ;AACA;AACA;AACA;AACA;;;AACIN,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCiV,SAAnC,GAA+C,UAAUhS,IAAV,EAAgB;AAC3D,WAAQA,IAAI,CAAC4O,kBAAL,KAA4B,QAA5B,GAAuC,QAAvC,GAAmD,KAAK/R,KAAL,CAAWmG,SAAZ,GAA0BhD,IAAI,CAAC4O,kBAAL,KAA4B,MAA5B,GAAqC,KAArC,GAA6C,OAAvE,GAAmF5O,IAAI,CAAC4O,kBAAL,KAA4B,MAA5B,GAAqC,OAArC,GAA+C,KAA5L;AACH,GAFD;AAGA;AACJ;AACA;AACA;AACA;AACA;;;AACIjS,EAAAA,wBAAwB,CAACI,SAAzB,CAAmC0V,kBAAnC,GAAwD,UAAUxV,IAAV,EAAgB;AACpE,QAAI4V,MAAM,GAAG,IAAItX,aAAJ,CAAkB0B,IAAI,CAACO,CAAvB,EAA0BP,IAAI,CAACQ,CAA/B,CAAb;AACA,QAAIqV,MAAM,GAAG,IAAIvX,aAAJ,CAAkB0B,IAAI,CAACO,CAAL,GAASP,IAAI,CAACG,KAAhC,EAAuCH,IAAI,CAACQ,CAA5C,CAAb;AACA,QAAIsV,MAAM,GAAG,IAAIxX,aAAJ,CAAkB0B,IAAI,CAACO,CAAL,GAASP,IAAI,CAACG,KAAhC,EAAuCH,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAArD,CAAb;AACA,QAAIsV,MAAM,GAAG,IAAIzX,aAAJ,CAAkB0B,IAAI,CAACO,CAAvB,EAA0BP,IAAI,CAACQ,CAAL,GAASR,IAAI,CAACS,MAAxC,CAAb;AACA,WAAO,CAACmV,MAAD,EAASC,MAAT,EAAiBC,MAAjB,EAAyBC,MAAzB,CAAP;AACH,GAND;AAOA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIrW,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCmV,YAAnC,GAAkD,UAAUnG,KAAV,EAAiB/L,IAAjB,EAAuBiN,cAAvB,EAAuC;AACrF,QAAI3R,YAAY,CAACyQ,KAAK,CAAC6B,YAAP,CAAhB,EAAsC;AAClC,UAAI3I,MAAM,GAAG,EAAb;AACA,UAAIgO,GAAG,GAAG,KAAK,CAAf;;AACA,WAAK,IAAIrK,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGmD,KAAK,CAACgC,IAAN,CAAWhP,MAAvC,EAA+C6J,KAAK,EAApD,EAAwD;AACpDqK,QAAAA,GAAG,GAAG,KAAKC,aAAL,CAAmBlT,IAAnB,EAAyB+L,KAAK,CAACgC,IAAN,CAAWnF,KAAX,CAAzB,EAA4CqE,cAA5C,CAAN;AACAhI,QAAAA,MAAM,CAACvC,IAAP,CAAYuQ,GAAZ;AACH;;AACD,aAAOhO,MAAP;AACH,KARD,MASK;AACD,aAAO,KAAKiO,aAAL,CAAmBlT,IAAnB,EAAyB+L,KAAK,CAACgC,IAA/B,EAAqCd,cAArC,CAAP;AACH;AACJ,GAbD;AAcA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACItQ,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCuK,eAAnC,GAAqD,UAAUtH,IAAV,EAAgB4I,KAAhB,EAAuBY,MAAvB,EAA+B2J,QAA/B,EAAyC;AAC1F,QAAInT,IAAI,CAACgI,MAAL,CAAY5K,KAAZ,GAAoB,CAAxB,EAA2B;AACvB,UAAI6C,eAAe,GAAGD,IAAI,CAACoH,aAAL,KAAuB,SAAvB,GAAmCpH,IAAI,CAACC,eAAxC,GAA0D,CAAhF;AACA,UAAIqK,SAAS,GAAGtK,IAAI,CAAC+B,qBAArB;AACA,UAAIqR,MAAM,GAAG,KAAK,CAAlB;AACA,UAAIvE,MAAM,GAAGsE,QAAQ,CAAC1V,CAAT,GAAc,CAAC6M,SAAS,GAAG,CAAC,CAAJ,GAAQ,CAAlB,IAAuBrK,eAAlD;AACA,UAAInD,OAAO,GAAG,EAAd;AACA,UAAIkP,MAAM,GAAG,KAAK,CAAlB;AACA,UAAI8C,GAAG,GAAIqE,QAAQ,CAAC/V,KAAT,GAAiB4C,IAAI,CAAC2I,YAAL,CAAkBoG,KAApC,IAA8C/O,IAAI,CAAC6D,SAAL,KAAmB,UAAnB,GAAgC7D,IAAI,CAACgP,gBAArC,GAClDhP,IAAI,CAAC2I,YAAL,CAAkBuC,QADd,CAAV;AAEA,UAAImE,IAAI,GAAG,KAAK,CAAhB;AACA,UAAIgE,QAAQ,GAAGrT,IAAI,CAACmP,YAAL,CAAkBzR,MAAlB,IACTsC,IAAI,CAACkH,YAAL,KAAsBlH,IAAI,CAACoH,aAA5B,GAA6CpH,IAAI,CAACgH,cAAL,CAAoBtJ,MAAjE,GAA0E,CADhE,CAAf;AAEA,UAAI0R,WAAW,GAAG,EAAlB;AACA,UAAI3E,aAAa,GAAIzK,IAAI,CAAC6D,SAAL,KAAmB,UAAnB,IAAiC7D,IAAI,CAAC0K,cAAL,KAAwB,cAA1D,GAA4E,CAAC,GAA7E,GAAmF,CAAvG;AACA,UAAIuE,IAAI,GAAK3E,SAAS,IAAItK,IAAI,CAACoH,aAAL,KAAuB,QAArC,IACP,CAACkD,SAAD,IAActK,IAAI,CAACoH,aAAL,KAAuB,SAD/B,GAEN+L,QAAQ,CAAC1V,CAAT,GAAa4V,QAAb,GAAwBvW,OAAxB,GAAkCmD,eAF5B,GAEgDkT,QAAQ,CAAC1V,CAAT,GAAa4V,QAAb,GAAwBvW,OAAxB,GAAkCmD,eAF7F;;AAGA,WAAK,IAAIkB,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGpB,IAAI,CAAC6K,aAAL,CAAmB9L,MAAzC,EAAiDoC,CAAC,GAAGC,GAArD,EAA0DD,CAAC,EAA3D,EAA+D;AAC3D6K,QAAAA,MAAM,GAAG7Q,kBAAkB,CAAC6E,IAAI,CAAC6K,aAAL,CAAmB1J,CAAnB,EAAsB8J,KAAtB,GAA8BR,aAA/B,EAA8CzK,IAA9C,CAA3B;AACAgM,QAAAA,MAAM,GAAG,CAAChM,IAAI,CAAC+M,aAAL,GAAsB,IAAIf,MAA1B,GAAoCA,MAArC,IAA+CmH,QAAQ,CAAC/V,KAAjE;;AACA,YAAI4C,IAAI,CAAC6D,SAAL,KAAmB,UAAnB,IAAiC7D,IAAI,CAAC0K,cAAL,KAAwB,cAA7D,EAA6E;AACzE0I,UAAAA,MAAM,GAAGpH,MAAM,GAAGmH,QAAQ,CAAC3V,CAA3B;AACA6R,UAAAA,IAAI,GAAGrD,MAAM,GAAI8C,GAAV,GAAiBqE,QAAQ,CAAC3V,CAAjC;AACH,SAHD,MAIK;AACD4V,UAAAA,MAAM,GAAGpH,MAAM,GAAG8C,GAAG,GAAG,GAAf,GAAqBqE,QAAQ,CAAC3V,CAAvC;AACA6R,UAAAA,IAAI,GAAGrD,MAAM,GAAG8C,GAAG,GAAG,GAAf,GAAqBqE,QAAQ,CAAC3V,CAArC;AACH;;AACD,gBAAQwC,IAAI,CAACgI,MAAL,CAAYhE,IAApB;AACI,eAAK,WAAL;AACA,eAAK,kBAAL;AACI,gBAAIoP,MAAM,GAAGD,QAAQ,CAAC3V,CAAtB,EAAyB;AACrB4R,cAAAA,WAAW,IAAK,MAAM,GAAN,GAAY+D,QAAQ,CAAC3V,CAArB,GAAyB,GAAzB,GAA+ByR,IAA/B,GAAsC,GAAtC,GAA4C,GAA5C,GAAkD,GAAlD,GAAwDI,IAAxD,GAA+D,GAA/D,GAAqEJ,IAArE,GAA4E,GAA5F;AACH,aAFD,MAGK,IAAI5J,IAAI,CAACyI,KAAL,CAAWuB,IAAX,IAAmB8D,QAAQ,CAAC/V,KAAT,GAAiB+V,QAAQ,CAAC3V,CAA7C,IAAkD,EAAEwC,IAAI,CAAC6K,aAAL,CAAmB9L,MAAnB,KAA8B,CAAhC,CAAtD,EAA0F;AAC3FqQ,cAAAA,WAAW,IAAK,MAAM,GAAN,GAAYgE,MAAZ,GAAqB,GAArB,GAA2BvE,MAA3B,GAAoC,GAApC,GAA0C,GAA1C,GAAgD,GAAhD,GAAsDuE,MAAtD,GAA+D,GAA/D,GAAqEnE,IAArE,GAA4E,GAA5E,GACZ,GADY,GACN,GADM,IACCkE,QAAQ,CAAC/V,KAAT,GAAiB+V,QAAQ,CAAC3V,CAD3B,IACgC,GADhC,GACsCyR,IADtC,GAC6C,GAD7D;AAEH,aAHI,MAIA;AACDG,cAAAA,WAAW,IAAK,MAAM,GAAN,GAAYgE,MAAZ,GAAqB,GAArB,GAA2BvE,MAA3B,GAAoC,GAApC,GAA0C,GAA1C,GAAgD,GAAhD,GAAsDuE,MAAtD,GAA+D,GAA/D,GACZnE,IADY,GACL,GADK,GACC,GADD,GACO,GADP,GACaI,IADb,GACoB,GADpB,GAC0BJ,IAD1B,GACiC,GADjD;;AAEA,kBAAI9N,CAAC,KAAK,CAAV,EAAa;AACTiO,gBAAAA,WAAW,IAAK,MAAM,GAAN,GAAYgE,MAAZ,GAAqB,GAArB,GAA2BvE,MAA3B,GAAoC,GAApC,GAA0C,GAA1C,GAAgD,GAAhD,GAAsDuE,MAAtD,GAA+D,GAA/D,GAAqEnE,IAArE,GAA4E,GAA5E,GACZ,IADY,GACLmE,MADK,GACI,GADJ,GACUnE,IADV,GACiB,KADjB,GAC0BkE,QAAQ,CAAC3V,CADnC,GACwC,GADxC,GAC8CyR,IAD9D;AAEH;;AACD,kBAAI9N,CAAC,KAAKnB,IAAI,CAAC6K,aAAL,CAAmB9L,MAAnB,GAA4B,CAAtC,EAAyC;AACrCqQ,gBAAAA,WAAW,IAAK,MAAM,GAAN,GAAYC,IAAZ,GAAmB,GAAnB,GAAyBR,MAAzB,GAAkC,GAAlC,GAAwC,GAAxC,GAA8C,GAA9C,GAAoDQ,IAApD,GAA2D,GAA3D,GAAiEJ,IAAjE,GAAwE,GAAxE,GACZ,IADY,GACLI,IADK,GACE,GADF,GACQJ,IADR,GACe,KADf,IACwBkE,QAAQ,CAAC/V,KAAT,GAAiB+V,QAAQ,CAAC3V,CADlD,IACuD,GADvD,GAC6DyR,IAD7E;AAEH;AACJ;;AACD;;AACJ,eAAK,2BAAL;AACI,gBAAI,EAAEmE,MAAM,GAAGD,QAAQ,CAAC3V,CAApB,KAA0B,EAAE6H,IAAI,CAACyI,KAAL,CAAWuB,IAAX,IAAmB8D,QAAQ,CAAC/V,KAAT,GAAiB+V,QAAQ,CAAC3V,CAA/C,CAA9B,EAAiF;AAC7E4R,cAAAA,WAAW,IAAK,MAAM,GAAN,GAAYgE,MAAZ,GAAqB,GAArB,GAA2BvE,MAA3B,GAAoC,GAApC,GAA0C,GAA1C,GAAgD,GAAhD,GAAsDuE,MAAtD,GAA+D,GAA/D,GAAqEnE,IAArE,GAA4E,GAA5E,GACZ,IADY,GACLI,IADK,GACE,GADF,GACQR,MADR,GACiB,KADjB,GACyBQ,IADzB,GACgC,GADhC,GACsCJ,IADtD;AAEH;;AACD;AA5BR;AA8BH;;AACDG,MAAAA,WAAW,IAAKpP,IAAI,CAACgI,MAAL,CAAYhE,IAAZ,KAAqB,WAArB,GAAoC,OAAO,GAAP,GAAamP,QAAQ,CAAC3V,CAAtB,GAA0B,GAA1B,GAAgCqR,MAAhC,GAAyC,GAAzC,GAA+C,GAA/C,IAC/CsE,QAAQ,CAAC3V,CAAT,GAAa2V,QAAQ,CAAC/V,KADyB,IAChB,GADgB,GACVyR,MAD1B,GACoC,EADpD;;AAEA,UAAIO,WAAW,KAAK,EAApB,EAAwB;AACpB,aAAKE,uBAAL,CAA6BtP,IAA7B,EAAmC4I,KAAnC,EAA0CwG,WAA1C,EAAuD5F,MAAvD;AACH;AACJ;;AACD,QAAI,KAAK3M,KAAL,CAAW2S,qBAAX,IAAoCxP,IAAI,CAACuP,gBAAL,CAAsBxQ,MAAtB,GAA+B,CAAvE,EAA0E;AACtE,WAAKlC,KAAL,CAAW2S,qBAAX,CAAiC8D,2BAAjC,CAA6DtT,IAA7D,EAAmE4I,KAAnE,EAA0EY,MAA1E,EAAkF2J,QAAlF;AACH;AACJ,GArED;AAsEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIxW,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCuS,uBAAnC,GAA6D,UAAUtP,IAAV,EAAgB4I,KAAhB,EAAuBwG,WAAvB,EAAoC5F,MAApC,EAA4C;AACrG,QAAIxD,OAAO,GAAGjK,UAAU,CAAC,KAAKc,KAAL,CAAWmJ,OAAX,CAAmBD,EAAnB,GAAwB,cAAxB,GAAyC6C,KAA1C,CAAxB;AACA,QAAIa,SAAS,GAAGzD,OAAO,GAAGA,OAAO,CAAC0D,YAAR,CAAqB,GAArB,CAAH,GAA+B,EAAtD;AACA,QAAI6J,aAAa,GAAG,KAAK1W,KAAL,CAAWgJ,QAAX,CAAoBiE,QAApB,CAA6B,IAAI1N,UAAJ,CAAe,KAAKS,KAAL,CAAWmJ,OAAX,CAAmBD,EAAnB,GAAwB,cAAxB,GAAyC6C,KAAxD,EAA+D,aAA/D,EAA8E5I,IAAI,CAACgI,MAAL,CAAY5K,KAA1F,EAAiG4C,IAAI,CAACgI,MAAL,CAAYC,KAAZ,IAAqB,KAAKpL,KAAL,CAAW+M,UAAX,CAAsBC,QAA5I,EAAsJ,CAAtJ,EAAyJ,EAAzJ,EAA6JuF,WAA7J,CAA7B,CAApB;AACAmE,IAAAA,aAAa,CAACC,KAAd,CAAoBC,aAApB,GAAoC,MAApC;AACA/X,IAAAA,kBAAkB,CAAC,KAAKmB,KAAL,CAAW+K,YAAZ,EAA0B4B,MAA1B,EAAkC+J,aAAlC,EAAiD,KAAK1W,KAAL,CAAWuL,MAA5D,EAAoE,IAApE,EAA0E,GAA1E,EAA+E,GAA/E,EAAoF,IAApF,EAA0FqB,SAA1F,EAAqG,IAArG,CAAlB;AACH,GAND;AAOA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI9M,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCmW,aAAnC,GAAmD,UAAUlT,IAAV,EAAgB+L,KAAhB,EAAuB3O,KAAvB,EAA8B;AAC7E,WAAQ4C,IAAI,CAACgO,oBAAL,KAA8B,MAA9B,GACFhO,IAAI,CAACwM,KAAL,GAAa,GAAb,KAAqB,CAArB,IAA0B,CAACxM,IAAI,CAAC0T,UAAjC,GAA+CpX,QAAQ,CAACc,KAAD,EAAQ2O,KAAR,EAAe/L,IAAI,CAACiO,UAApB,CAAvD,GAAyFlC,KADtF,GAC+FA,KADvG;AAEH,GAHD;AAIA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIpP,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCwK,cAAnC,GAAoD,UAAUvH,IAAV,EAAgB4I,KAAhB,EAAuBY,MAAvB,EAA+BvM,IAA/B,EAAqC;AACrF,QAAI+C,IAAI,CAAC0P,KAAT,EAAgB;AACZ,UAAI7S,KAAK,GAAG,KAAKA,KAAjB;AACA,UAAIoP,WAAW,GAAG/P,WAAW,CAAC8D,IAAI,CAAC0P,KAAN,EAAa1P,IAAI,CAACgQ,UAAlB,CAA7B;AACA,UAAI/P,eAAe,GAAGjF,iBAAiB,CAACgF,IAAI,CAACqD,SAAN,CAAjB,GAAoCrD,IAAI,CAACC,eAAzC,GAA2D,CAAjF;AACA,UAAInD,OAAO,GAAG,CAACkD,IAAI,CAACkH,YAAL,KAAsB,QAAtB,GAAiC,CAAjC,GAAqClH,IAAI,CAACgH,cAAL,CAAoBtJ,MAApB,GAA6BsC,IAAI,CAAC4P,YAAxE,KACT5P,IAAI,CAACoH,aAAL,KAAuB,QAAvB,GAAkC,CAAlC,GACGpH,IAAI,CAACmP,YAAL,CAAkBzR,MAAlB,GAA2BsC,IAAI,CAAC6P,qBAAhC,GAAwD7P,IAAI,CAACmM,YAFvD,CAAd;AAGA,UAAI2D,SAAS,GAAI9P,IAAI,CAAC8P,SAAL,CAAepS,MAAf,IAAyBsC,IAAI,CAAC+P,eAAL,CAAqBhR,MAArB,GAA8B,CAAvD,CAAjB;AACAjC,MAAAA,OAAO,GAAGkD,IAAI,CAAC+B,qBAAL,GAA6B,EAAEjF,OAAO,GAAGmP,WAAW,CAACvO,MAAZ,GAAqB,CAA/B,GAAmCuC,eAAnC,GAAqD6P,SAAvD,CAA7B,GAAkGhT,OAAO,GAAI,IACnHmP,WAAW,CAACvO,MADuG,GAC9F,CADmF,GAC9EuC,eAD9B;AAEA,UAAImM,OAAO,GAAG,IAAIjQ,UAAJ,CAAeU,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB,aAAnB,GAAmC6C,KAAlD,EAAyD3L,IAAI,CAACO,CAAL,GAASP,IAAI,CAACG,KAAL,GAAa,GAA/E,EAAoFH,IAAI,CAACQ,CAAL,GAASX,OAA7F,EAAsG,QAAtG,EAAgHkD,IAAI,CAAC+P,eAArH,CAAd;AACA,UAAI/J,OAAO,GAAG3J,WAAW,CAACQ,KAAK,CAACgJ,QAAP,EAAiBuG,OAAjB,EAA0BpM,IAAI,CAACgQ,UAA/B,EAA2ChQ,IAAI,CAACgQ,UAAL,CAAgB/H,KAAhB,IAAyBpL,KAAK,CAAC+M,UAAN,CAAiBqG,SAArF,EAAgGzG,MAAhG,EAAwG,IAAxG,EAA8G,IAA9G,EAAoH,IAApH,EAA0H,IAA1H,EAAgI,IAAhI,EAAsI,IAAtI,EAA4I,IAA5I,EAAkJ,IAAlJ,EAAwJ3M,KAAK,CAAC+K,YAA9J,CAAzB;AACA5B,MAAAA,OAAO,CAACkK,YAAR,CAAqB,YAArB,EAAmClQ,IAAI,CAACqQ,WAAL,IAAoBrQ,IAAI,CAAC0P,KAA5D;AACA1J,MAAAA,OAAO,CAACkK,YAAR,CAAqB,UAArB,EAAiClQ,IAAI,CAACmQ,QAAL,CAAcC,QAAd,EAAjC;AACH;AACJ,GAhBD;AAiBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIzT,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCqO,cAAnC,GAAoD,UAAUpL,IAAV,EAAgB4I,KAAhB,EAAuB+K,aAAvB,EAAsCC,SAAtC,EAAiDC,MAAjD,EAAyDC,SAAzD,EAAoEtK,MAApE,EAA4EuK,UAA5E,EAAwFpK,SAAxF,EAAmG;AACnJ,QAAIA,SAAS,KAAK,KAAK,CAAvB,EAA0B;AAAEA,MAAAA,SAAS,GAAG,IAAZ;AAAmB;;AAC/C,QAAI9M,KAAK,GAAG,KAAKA,KAAjB;AACA,QAAI4M,SAAJ;AACA,QAAIzD,OAAJ;;AACA,QAAI4N,SAAS,CAACxW,KAAV,GAAkB,CAAlB,IAAuB4C,IAAI,CAACwG,OAA5B,IAAuCxG,IAAI,CAAC2G,kBAA5C,IAAkEgN,aAAtE,EAAqF;AACjF3N,MAAAA,OAAO,GAAGjK,UAAU,CAACc,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB8N,MAAnB,GAA4BjL,KAA5B,GAAoC,GAApC,GAA0CkL,SAA3C,CAApB;AACArK,MAAAA,SAAS,GAAGzD,OAAO,GAAGA,OAAO,CAAC0D,YAAR,CAAqB,GAArB,CAAH,GAA+B,IAAlD;AACA1D,MAAAA,OAAO,GAAG,IAAV;AACA,WAAKoD,UAAL,GAAkBvM,KAAK,CAACgJ,QAAN,CAAeiE,QAAf,CAAwB,IAAI1N,UAAJ,CAAeS,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB8N,MAAnB,GAA4BjL,KAA5B,GAAoC,GAApC,GAA0CkL,SAAzD,EAAoE,aAApE,EAAmFF,SAAS,CAACxW,KAA7F,EAAoGwW,SAAS,CAAC3L,KAAV,IAAmB8L,UAAvH,EAAmI,IAAnI,EAAyIpK,SAAzI,EAAoJgK,aAApJ,CAAxB,CAAlB;AACAjY,MAAAA,kBAAkB,CAACmB,KAAK,CAAC+K,YAAP,EAAqB4B,MAArB,EAA6B,KAAKJ,UAAlC,EAA8CvM,KAAK,CAACuL,MAApD,EAA4D,IAA5D,EAAkE,GAAlE,EAAuE,GAAvE,EAA4E,IAA5E,EAAkFqB,SAAlF,EAA6F,IAA7F,CAAlB;AACH;AACJ,GAZD;AAaA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACI9M,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCiX,cAAnC,GAAoD,UAAUC,SAAV,EAAqBlI,KAArB,EAA4BnD,KAA5B,EAAmC;AACnF,QAAIsL,QAAQ,CAACC,cAAT,CAAwBF,SAAS,GAAG,WAAZ,GAA0BrL,KAA1B,GAAkC,QAA1D,EAAoEwL,QAApE,CAA6EF,QAAQ,CAACC,cAAT,CAAwBpI,KAAK,CAAChG,EAA9B,CAA7E,CAAJ,EAAqH;AACjH,aAAOmO,QAAQ,CAACC,cAAT,CAAwBF,SAAS,GAAG,WAAZ,GAA0BrL,KAA1B,GAAkC,QAA1D,CAAP;AACH,KAFD,MAGK;AACD,aAAOsL,QAAQ,CAACC,cAAT,CAAwBF,SAAS,GAAG,WAAZ,GAA0BrL,KAA1B,GAAkC,SAA1D,CAAP;AACH;AACJ,GAPD;AAQA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIjM,EAAAA,wBAAwB,CAACI,SAAzB,CAAmCyR,kBAAnC,GAAwD,UAAU3R,KAAV,EAAiB4P,YAAjB,EAA+BzM,IAA/B,EAAqC4I,KAArC,EAA4C3L,IAA5C,EAAkD;AACtG,QAAIoX,UAAU,GAAG,KAAKL,cAAL,CAAoBnX,KAAK,CAACmJ,OAAN,CAAcD,EAAlC,EAAsC0G,YAAtC,EAAoD7D,KAApD,CAAjB;AACA6D,IAAAA,YAAY,CAACyD,YAAb,CAA0B,SAA1B,EAAqC,KAArC;AACA,QAAIoE,WAAW,GAAGzX,KAAK,CAACgJ,QAAN,CAAeC,WAAf,CAA2B;AACzCC,MAAAA,EAAE,EAAElJ,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB,iBAAnB,GAAuC6C;AADF,KAA3B,CAAlB;AAGA0L,IAAAA,WAAW,GAAGxY,mBAAmB,CAACe,KAAD,EAAQmD,IAAR,EAAcsU,WAAd,EAA2B1L,KAA3B,EAAkC5I,IAAI,CAACwC,WAAL,KAAqB,UAAvD,EAAmEvF,IAAnE,CAAjC;AACAoX,IAAAA,UAAU,CAACE,YAAX,CAAwB9H,YAAxB,EAAsCyH,QAAQ,CAACC,cAAT,CAAwB1H,YAAY,CAAC1G,EAArC,CAAtC;;AACA,QAAIhK,UAAU,CAACc,KAAK,CAACmJ,OAAN,CAAcD,EAAd,GAAmB,iBAAnB,GAAuC6C,KAAxC,CAAd,EAA8D;AAC1DyL,MAAAA,UAAU,CAACE,YAAX,CAAwBD,WAAxB,EAAqCJ,QAAQ,CAACC,cAAT,CAAwBG,WAAW,CAACvO,EAApC,CAArC;AACH,KAFD,MAGK;AACDsO,MAAAA,UAAU,CAACxM,WAAX,CAAuByM,WAAvB;AACH;AACJ,GAdD;;AAeA,SAAO3X,wBAAP;AACH,CAtjD6C,EAA9C;;AAujDA,SAASA,wBAAT","sourcesContent":["import { createElement, isNullOrUndefined } from '@syncfusion/ej2-base';\r\nimport { DataUtil } from '@syncfusion/ej2-data';\r\nimport { subtractThickness, valueToCoefficient, sum, redrawElement, isBreakLabel, ChartLocation } from '../../common/utils/helper';\r\nimport { subArray, inside, appendChildElement, stringToNumber } from '../../common/utils/helper';\r\nimport { Thickness, logBase, createZoomingLabels, getElement } from '../../common/utils/helper';\r\nimport { Size, Rect, measureText, TextOption, PathOption } from '@syncfusion/ej2-svg-base';\r\nimport { textElement, textTrim, getRotatedRectangleCoordinates, isRotatedRectIntersect, isZoomSet } from '../../common/utils/helper';\r\n/**\r\n * Specifies the Cartesian Axis Layout.\r\n */\r\nvar axisPadding = 10;\r\nvar CartesianAxisLayoutPanel = /** @class */ (function () {\r\n    /** @private */\r\n    function CartesianAxisLayoutPanel(chartModule) {\r\n        this.chart = chartModule;\r\n        this.padding = 5;\r\n    }\r\n    /**\r\n     * Measure the axis size.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.measureAxis = function (rect) {\r\n        var chart = this.chart;\r\n        var chartAreaWidth = chart.chartArea.width ? stringToNumber(chart.chartArea.width, chart.availableSize.width) : null;\r\n        this.crossAt(chart);\r\n        this.seriesClipRect = new Rect(rect.x, rect.y, rect.width, rect.height);\r\n        this.initialClipRect = rect;\r\n        this.leftSize = 0;\r\n        this.rightSize = 0;\r\n        this.topSize = 0;\r\n        this.bottomSize = 0;\r\n        //Measure Axis size with initial Rect\r\n        this.measureRowAxis(chart, this.initialClipRect);\r\n        this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\r\n        this.measureColumnAxis(chart, this.initialClipRect);\r\n        this.initialClipRect = subtractThickness(this.initialClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\r\n        if (!this.chart.delayRedraw) {\r\n            this.calculateAxisSize(this.initialClipRect);\r\n        }\r\n        this.leftSize = 0;\r\n        this.rightSize = 0;\r\n        this.topSize = 0;\r\n        this.bottomSize = 0;\r\n        //Measure Axis size with series Rect\r\n        this.measureRowAxis(chart, this.initialClipRect);\r\n        this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(this.leftSize, this.rightSize, 0, 0));\r\n        this.measureColumnAxis(chart, this.initialClipRect);\r\n        this.seriesClipRect = subtractThickness(this.seriesClipRect, new Thickness(0, 0, this.topSize, this.bottomSize));\r\n        if (chartAreaWidth) {\r\n            this.calculateFixedChartArea(chart, chartAreaWidth);\r\n        }\r\n        if (!this.chart.delayRedraw) {\r\n            chart.refreshAxis();\r\n            this.calculateAxisSize(this.seriesClipRect);\r\n        }\r\n    };\r\n    CartesianAxisLayoutPanel.prototype.calculateFixedChartArea = function (chart, chartAreaWidth) {\r\n        this.seriesClipRect.width = chartAreaWidth;\r\n        this.seriesClipRect.x = chart.availableSize.width - chart.margin.right - chartAreaWidth -\r\n            (chart.legendSettings.position === \"Right\" ? chart.legendModule.legendBounds.width : 0);\r\n        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\r\n            var item = _a[_i];\r\n            this.seriesClipRect.x -= sum(item.farSizes);\r\n        }\r\n    };\r\n    CartesianAxisLayoutPanel.prototype.measureRowAxis = function (chart, rect) {\r\n        var row;\r\n        this.calculateRowSize(rect);\r\n        for (var _i = 0, _a = chart.rows; _i < _a.length; _i++) {\r\n            var item = _a[_i];\r\n            row = item;\r\n            row.nearSizes = [];\r\n            row.farSizes = [];\r\n            this.arrangeAxis(row);\r\n            this.measureDefinition(row, chart, new Size(chart.availableSize.width, row.computedHeight));\r\n            if (this.leftSize < sum(row.nearSizes)) {\r\n                this.leftSize = sum(row.nearSizes);\r\n            }\r\n            if (this.rightSize < sum(row.farSizes)) {\r\n                this.rightSize = sum(row.farSizes);\r\n            }\r\n        }\r\n    };\r\n    CartesianAxisLayoutPanel.prototype.measureColumnAxis = function (chart, rect) {\r\n        var column;\r\n        this.calculateColumnSize(rect);\r\n        for (var _i = 0, _a = chart.columns; _i < _a.length; _i++) {\r\n            var item = _a[_i];\r\n            column = item;\r\n            column.farSizes = [];\r\n            column.nearSizes = [];\r\n            this.arrangeAxis(column);\r\n            this.measureDefinition(column, chart, new Size(column.computedWidth, chart.availableSize.height));\r\n            if (this.bottomSize < sum(column.nearSizes)) {\r\n                this.bottomSize = sum(column.nearSizes);\r\n            }\r\n            if (this.topSize < sum(column.farSizes)) {\r\n                this.topSize = sum(column.farSizes);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Measure the column and row in chart.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.measureDefinition = function (definition, chart, size) {\r\n        var ele = 16; // scrollbar element height is 16.\r\n        for (var _i = 0, _a = definition.axes; _i < _a.length; _i++) {\r\n            var axis = _a[_i];\r\n            axis.scrollBarHeight = chart.scrollBarModule && chart.zoomModule && chart.zoomSettings.enableScrollbar &&\r\n                axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0) ? ele : 0;\r\n            axis.scrollBarHeight = chart.scrollBarModule && (chart.zoomModule && chart.zoomSettings.enableScrollbar &&\r\n                axis.enableScrollbarOnZooming && chart.zoomModule.isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0)\r\n                || axis.scrollbarSettings.enable) ? ele : 0;\r\n            axis.getModule(chart);\r\n            axis.baseModule.calculateRangeAndInterval(size, axis);\r\n            definition.computeSize(axis, axis.scrollBarHeight);\r\n        }\r\n        if (definition.farSizes.length > 0) {\r\n            definition.farSizes[definition.farSizes.length - 1] -= axisPadding;\r\n        }\r\n        if (definition.nearSizes.length > 0) {\r\n            definition.nearSizes[definition.nearSizes.length - 1] -= axisPadding;\r\n        }\r\n    };\r\n    /**\r\n     * Measure the axis.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.calculateAxisSize = function (rect) {\r\n        var chart = this.chart;\r\n        var row;\r\n        var column;\r\n        var definition;\r\n        var axis;\r\n        var nearCount = 0;\r\n        var farCount = 0;\r\n        var size = 0;\r\n        var x;\r\n        var y;\r\n        var axisOffset;\r\n        this.calculateRowSize(rect);\r\n        for (var i = 0, len = chart.rows.length; i < len; i++) {\r\n            row = chart.rows[i];\r\n            nearCount = 0;\r\n            farCount = 0;\r\n            for (var j = 0, len_1 = row.axes.length; j < len_1; j++) {\r\n                axis = row.axes[j];\r\n                axisOffset = axis.plotOffset;\r\n                if (axis.rect.height === 0) {\r\n                    axis.rect.height = row.computedHeight;\r\n                    size = 0;\r\n                    for (var k = i + 1, len_2 = i + axis.span; k < len_2; k++) {\r\n                        definition = chart.rows[k];\r\n                        size += definition.computedHeight;\r\n                    }\r\n                    axis.rect.y = (row.computedTop - size) + (axis.plotOffsetTop ? axis.plotOffsetTop : axisOffset);\r\n                    axis.rect.height = (axis.rect.height + size) -\r\n                        (this.getAxisOffsetValue(axis.plotOffsetTop, axis.plotOffsetBottom, axis.plotOffset));\r\n                    axis.rect.width = 0;\r\n                }\r\n                if (axis.isAxisOpposedPosition) {\r\n                    x = rect.x + rect.width + sum(subArray(row.farSizes, farCount));\r\n                    axis.rect.x = axis.rect.x >= x ? axis.rect.x : x;\r\n                    farCount++;\r\n                }\r\n                else {\r\n                    x = rect.x - sum(subArray(row.nearSizes, nearCount));\r\n                    axis.rect.x = axis.rect.x <= x ? axis.rect.x : x;\r\n                    nearCount++;\r\n                }\r\n            }\r\n        }\r\n        this.calculateColumnSize(rect);\r\n        for (var i = 0, len = chart.columns.length; i < len; i++) {\r\n            column = chart.columns[i];\r\n            nearCount = 0;\r\n            farCount = 0;\r\n            for (var j = 0, len_3 = column.axes.length; j < len_3; j++) {\r\n                axis = column.axes[j];\r\n                axisOffset = axis.plotOffset;\r\n                if (axis.rect.width === 0) {\r\n                    for (var k = i, len_4 = (i + axis.span); k < len_4; k++) {\r\n                        definition = chart.columns[k];\r\n                        axis.rect.width += definition.computedWidth;\r\n                    }\r\n                    axis.rect.x = column.computedLeft + (axis.plotOffsetLeft ? axis.plotOffsetLeft : axisOffset);\r\n                    axis.rect.width -= (this.getAxisOffsetValue(axis.plotOffsetLeft, axis.plotOffsetRight, axis.plotOffset));\r\n                    axis.rect.height = 0;\r\n                }\r\n                if (axis.isAxisOpposedPosition) {\r\n                    y = rect.y - sum(subArray(column.farSizes, farCount));\r\n                    axis.rect.y = axis.rect.y <= y ? axis.rect.y : y;\r\n                    farCount++;\r\n                }\r\n                else {\r\n                    y = rect.y + rect.height + sum(subArray(column.nearSizes, nearCount));\r\n                    axis.rect.y = axis.rect.y >= y ? axis.rect.y : y;\r\n                    nearCount++;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Measure the axis.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.measure = function () {\r\n        var chart = this.chart;\r\n        var row;\r\n        var column;\r\n        var definition;\r\n        var actualIndex;\r\n        var span;\r\n        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\r\n            var axis = _a[_i];\r\n            //definition.Axes = axis;\r\n            if (axis.orientation === 'Vertical') {\r\n                chart.verticalAxes.push(axis);\r\n                actualIndex = this.getActualRow(axis);\r\n                row = chart.rows[actualIndex];\r\n                this.pushAxis(row, axis);\r\n                span = ((actualIndex + axis.span) > chart.rows.length ? chart.rows.length : (actualIndex + axis.span));\r\n                for (var j = actualIndex + 1; j < span; j++) {\r\n                    definition = chart.rows[j];\r\n                    definition.axes[row.axes.length - 1] = axis;\r\n                    chart.rows[j] = definition;\r\n                }\r\n                chart.rows[actualIndex] = row;\r\n            }\r\n            else {\r\n                chart.horizontalAxes.push(axis);\r\n                actualIndex = this.getActualColumn(axis);\r\n                column = chart.columns[actualIndex];\r\n                this.pushAxis(column, axis);\r\n                span = ((actualIndex + axis.span) > chart.columns.length ? chart.columns.length : (actualIndex + axis.span));\r\n                for (var j = actualIndex + 1; j < span; j++) {\r\n                    definition = chart.columns[j];\r\n                    definition.axes[column.axes.length - 1] = axis;\r\n                    chart.columns[j] = definition;\r\n                }\r\n                chart.columns[actualIndex] = column;\r\n            }\r\n            axis.isRTLEnabled = chart.enableRtl;\r\n            axis.setIsInversedAndOpposedPosition();\r\n        }\r\n    };\r\n    CartesianAxisLayoutPanel.prototype.getAxisOffsetValue = function (position1, position2, plotOffset) {\r\n        var rangeOffset = position1 ? (position1 + (position2 ? position2 :\r\n            plotOffset)) : (position2 ? position2 + plotOffset : 2 * plotOffset);\r\n        return rangeOffset;\r\n    };\r\n    CartesianAxisLayoutPanel.prototype.crossAt = function (chart) {\r\n        for (var _i = 0, _a = chart.axisCollections; _i < _a.length; _i++) {\r\n            var axis = _a[_i];\r\n            if (axis.crossesAt === null) {\r\n                continue;\r\n            }\r\n            if (!axis.crossesInAxis) {\r\n                if (chart.requireInvertedAxis) {\r\n                    axis.crossInAxis = ((axis.orientation === 'Horizontal')) ? chart.primaryXAxis : chart.primaryYAxis;\r\n                }\r\n                else {\r\n                    axis.crossInAxis = ((axis.orientation === 'Horizontal')) ? chart.primaryYAxis : chart.primaryXAxis;\r\n                }\r\n                axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\r\n                continue;\r\n            }\r\n            else {\r\n                for (var i = 2, len = chart.axisCollections.length; i < len; i++) {\r\n                    if (axis.crossesInAxis === chart.axisCollections[i].name) {\r\n                        axis.crossInAxis = chart.axisCollections[i];\r\n                        axis.crossAt = this.updateCrossAt(axis.crossInAxis, axis.crossesAt);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    CartesianAxisLayoutPanel.prototype.updateCrossAt = function (axis, crossAt) {\r\n        switch (axis.valueType) {\r\n            case 'DateTime':\r\n                var option = {\r\n                    skeleton: 'full',\r\n                    type: 'dateTime'\r\n                };\r\n                var dateParser = this.chart.intl.getDateParser(option);\r\n                var dateFormatter = this.chart.intl.getDateFormat(option);\r\n                return Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: crossAt }).val))));\r\n            case 'Category':\r\n                return parseFloat(crossAt) ? parseFloat(crossAt) : axis.labels.indexOf(crossAt);\r\n            case 'Logarithmic':\r\n                return logBase(crossAt, axis.logBase);\r\n            default:\r\n                return crossAt;\r\n        }\r\n    };\r\n    CartesianAxisLayoutPanel.prototype.pushAxis = function (definition, axis) {\r\n        for (var i = 0, len = definition.axes.length; i <= len; i++) {\r\n            if (!definition.axes[i]) {\r\n                definition.axes[i] = axis;\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    CartesianAxisLayoutPanel.prototype.arrangeAxis = function (definition) {\r\n        var axisCollection = [];\r\n        for (var i = 0, len = definition.axes.length; i <= len; i++) {\r\n            if (definition.axes[i]) {\r\n                axisCollection.push(definition.axes[i]);\r\n            }\r\n        }\r\n        definition.axes = axisCollection;\r\n    };\r\n    CartesianAxisLayoutPanel.prototype.getActualColumn = function (axis) {\r\n        var actualLength = this.chart.columns.length;\r\n        var pos = axis.columnIndex;\r\n        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);\r\n        return result;\r\n    };\r\n    CartesianAxisLayoutPanel.prototype.getActualRow = function (axis) {\r\n        var actualLength = this.chart.rows.length;\r\n        var pos = axis.rowIndex;\r\n        var result = pos >= actualLength ? actualLength - 1 : (pos < 0 ? 0 : pos);\r\n        return result;\r\n    };\r\n    /**\r\n     * Measure the row size.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.calculateRowSize = function (rect) {\r\n        /*! Calculate row size */\r\n        var chart = this.chart;\r\n        var row;\r\n        var rowTop = rect.y + rect.height;\r\n        var height = 0;\r\n        var remainingHeight = Math.max(0, rect.height);\r\n        for (var i = 0, len = chart.rows.length; i < len; i++) {\r\n            row = chart.rows[i];\r\n            if (row.height.indexOf('%') !== -1) {\r\n                height = Math.min(remainingHeight, (rect.height * parseInt(row.height, 10) / 100));\r\n            }\r\n            else {\r\n                height = Math.min(remainingHeight, parseInt(row.height, 10));\r\n            }\r\n            height = (i !== (len - 1)) ? height : remainingHeight;\r\n            row.computedHeight = height;\r\n            rowTop -= height;\r\n            row.computedTop = rowTop;\r\n            remainingHeight -= height;\r\n        }\r\n    };\r\n    /**\r\n     * Measure the row size.\r\n     *\r\n     * @param {Rect} rect rect\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.calculateColumnSize = function (rect) {\r\n        /*! Calculate column size */\r\n        var chart = this.chart;\r\n        var column;\r\n        var columnLeft = rect.x;\r\n        var width = 0;\r\n        var remainingWidth = Math.max(0, rect.width);\r\n        for (var i = 0, len = chart.columns.length; i < len; i++) {\r\n            column = chart.columns[i];\r\n            if (column.width.indexOf('%') !== -1) {\r\n                width = Math.min(remainingWidth, (rect.width * parseInt(column.width, 10) / 100));\r\n            }\r\n            else {\r\n                width = Math.min(remainingWidth, parseInt(column.width, 10));\r\n            }\r\n            width = (i !== (len - 1)) ? width : remainingWidth;\r\n            column.computedWidth = width;\r\n            column.computedLeft = columnLeft;\r\n            columnLeft += width;\r\n            remainingWidth -= width;\r\n        }\r\n    };\r\n    /**\r\n     * To render the axis element.\r\n     *\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    // tslint:disable-next-line:max-func-body-length\r\n    CartesianAxisLayoutPanel.prototype.renderAxes = function () {\r\n        var chart = this.chart;\r\n        var axis;\r\n        var axisElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisInsideCollection' });\r\n        var axisLineElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisOutsideCollection' });\r\n        var outsideElement;\r\n        var isInside;\r\n        for (var i = 0, len = chart.axisCollections.length; i < len; i++) {\r\n            var axisVisibility = true;\r\n            axis = chart.axisCollections[i];\r\n            this.element = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i + 'Inside' });\r\n            outsideElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisGroup' + i + 'Outside' });\r\n            for (var _i = 0, _a = this.chart.series; _i < _a.length; _i++) {\r\n                var series = _a[_i];\r\n                if (axis.name === series.yAxisName || axis.name === series.xAxisName) {\r\n                    axisVisibility = series.visible;\r\n                    if (axisVisibility) {\r\n                        break;\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n            if (!axisVisibility) {\r\n                break;\r\n            }\r\n            isInside = this.findAxisPosition(axis);\r\n            if (axis.orientation === 'Horizontal') {\r\n                axis.updateCrossValue();\r\n                if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\r\n                    this.drawAxisLine(axis, i, axis.plotOffset, 0, isInside ? outsideElement : this.element, axis.updatedRect);\r\n                }\r\n                if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {\r\n                    this.drawXAxisGridLine(axis, i, (isInside || axis.tickPosition === 'Inside') ? outsideElement : this.element, axis.updatedRect);\r\n                }\r\n                if (axis.visible && axis.internalVisibility) {\r\n                    this.drawXAxisLabels(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\r\n                    this.drawXAxisBorder(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\r\n                    this.drawXAxisTitle(axis, i, isInside ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\r\n                }\r\n            }\r\n            else {\r\n                axis.updateCrossValue();\r\n                if (axis.visible && axis.internalVisibility && axis.lineStyle.width > 0) {\r\n                    this.drawAxisLine(axis, i, 0, axis.plotOffset, isInside ? outsideElement : this.element, axis.updatedRect);\r\n                }\r\n                if (axis.majorGridLines.width > 0 || axis.majorTickLines.width > 0) {\r\n                    this.drawYAxisGridLine(axis, i, (isInside || axis.tickPosition === 'Inside') ? outsideElement : this.element, axis.updatedRect);\r\n                }\r\n                if (axis.visible && axis.internalVisibility) {\r\n                    this.drawYAxisLabels(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\r\n                    this.drawYAxisBorder(axis, i, (isInside || axis.labelPosition === 'Inside') ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\r\n                    this.drawYAxisTitle(axis, i, isInside ? outsideElement : this.element, (axis.placeNextToAxisLine ? axis.updatedRect : axis.rect));\r\n                }\r\n            }\r\n            if (!this.chart.enableCanvas) {\r\n                axisElement.appendChild(this.element);\r\n                if (outsideElement && outsideElement.childNodes.length > 0) {\r\n                    axisLineElement.appendChild(outsideElement);\r\n                }\r\n            }\r\n            if (chart.scrollBarModule && ((chart.zoomSettings.enableScrollbar && axis.enableScrollbarOnZooming) ||\r\n                axis.scrollbarSettings.enable)) {\r\n                this.renderScrollbar(chart, axis);\r\n            }\r\n        }\r\n        this.element = chart.renderer.createGroup({ id: chart.element.id + 'DefinitionLine' });\r\n        for (var j = 0, len = chart.rows.length; j < len; j++) {\r\n            var row = chart.rows[j];\r\n            if (row.border.color) {\r\n                this.drawBottomLine(row, j, true);\r\n            }\r\n        }\r\n        for (var j = 0, len = chart.columns.length; j < len; j++) {\r\n            var column = chart.columns[j];\r\n            if (column.border.color) {\r\n                this.drawBottomLine(column, j, false);\r\n            }\r\n        }\r\n        if (!this.chart.enableCanvas) {\r\n            axisElement.appendChild(this.element);\r\n        }\r\n        appendChildElement(chart.enableCanvas, chart.svgObject, axisElement, chart.redraw);\r\n        return axisLineElement;\r\n    };\r\n    /**\r\n     * To render the axis scrollbar\r\n     *\r\n     * @param {Chart} chart chart\r\n     * @param {Axis} axis axis\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.renderScrollbar = function (chart, axis) {\r\n        var isZoomed = isNullOrUndefined(chart.zoomModule) ? false : chart.zoomModule.isZoomed;\r\n        if (((isZoomed && (axis.zoomFactor < 1 || axis.zoomPosition > 0)) || (axis.scrollbarSettings.enable &&\r\n            (axis.zoomFactor <= 1 || axis.zoomPosition >= 0))) &&\r\n            (!axis.zoomingScrollBar.isScrollUI || chart.visibleSeries[0].type.indexOf('Bar') >= 0)) {\r\n            if (!chart.scrollElement) {\r\n                chart.scrollElement = redrawElement(chart.redraw, chart.element.id + '_scrollElement') || createElement('div', { id: chart.element.id + '_scrollElement' });\r\n            }\r\n            appendChildElement(false, chart.scrollElement, axis.zoomingScrollBar.render(true), true);\r\n        }\r\n        else if (axis.zoomFactor === 1 && axis.zoomPosition === 0 && axis.zoomingScrollBar.svgObject && !axis.scrollbarSettings.enable) {\r\n            axis.zoomingScrollBar.destroy();\r\n        }\r\n        if (axis.zoomingScrollBar.isScrollUI) {\r\n            axis.zoomingScrollBar.isScrollUI = false;\r\n        }\r\n    };\r\n    /**\r\n     * To find the axis position\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @returns {boolean} axis position\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.findAxisPosition = function (axis) {\r\n        return axis.crossAt !== null && axis.isInside(axis.crossInAxis.visibleRange);\r\n    };\r\n    /**\r\n     * To render the bootom line of the columns and rows\r\n     *\r\n     * @param {Row | Column} definition definition\r\n     * @param {number} index index\r\n     * @param {boolean} isRow isRow\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.drawBottomLine = function (definition, index, isRow) {\r\n        var chart = this.chart;\r\n        var optionsLine = {};\r\n        var x1;\r\n        var x2;\r\n        var y1;\r\n        var y2;\r\n        var definitionName;\r\n        if (isRow) {\r\n            definition = definition;\r\n            y1 = y2 = definition.computedTop + definition.computedHeight;\r\n            x1 = this.seriesClipRect.x;\r\n            x2 = x1 + this.seriesClipRect.width;\r\n            definitionName = 'Row';\r\n        }\r\n        else {\r\n            definition = definition;\r\n            x1 = x2 = definition.computedLeft;\r\n            y1 = this.seriesClipRect.y;\r\n            y2 = y1 + this.seriesClipRect.height;\r\n            definitionName = 'Column';\r\n        }\r\n        optionsLine = {\r\n            'id': chart.element.id + '_AxisBottom_' + definitionName + index,\r\n            x1: x1,\r\n            y1: y1,\r\n            x2: x2,\r\n            y2: y2,\r\n            'stroke-width': definition.border.width,\r\n            'stroke': definition.border.color\r\n        };\r\n        this.htmlObject = chart.renderer.drawLine(optionsLine);\r\n        this.element.appendChild(this.htmlObject);\r\n    };\r\n    /**\r\n     * To render the axis line\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {number} plotX plotX\r\n     * @param {number} plotY plotY\r\n     * @param {Element} parent parent\r\n     * @param {Rect} rect rect\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.drawAxisLine = function (axis, index, plotX, plotY, parent, rect) {\r\n        var chart = this.chart;\r\n        var optionsLine = {};\r\n        var element = getElement(chart.element.id + 'AxisLine_' + index);\r\n        var direction = element ? element.getAttribute('d') : '';\r\n        element = null;\r\n        optionsLine = {\r\n            'id': chart.element.id + 'AxisLine_' + index,\r\n            'd': 'M ' + (rect.x - plotX) + ' ' + (rect.y - plotY) +\r\n                ' L ' + (rect.x + rect.width + plotX) + ' ' + (rect.y + rect.height + plotY),\r\n            'stroke-dasharray': axis.lineStyle.dashArray,\r\n            'stroke-width': axis.lineStyle.width,\r\n            'stroke': axis.lineStyle.color || chart.themeStyle.axisLine\r\n        };\r\n        this.htmlObject = chart.renderer.drawPath(optionsLine);\r\n        appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction);\r\n    };\r\n    /**\r\n     * To render the yAxis grid line\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {Element} parent parent\r\n     * @param {Rect} rect rect\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.drawYAxisGridLine = function (axis, index, parent, rect) {\r\n        var isLogAxis = axis.valueType === 'Logarithmic';\r\n        var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\r\n        var tempInterval;\r\n        var pointY = 0;\r\n        var majorGrid = '';\r\n        var majorTick = '';\r\n        var minorGridDirection;\r\n        var isOpposed = axis.isAxisOpposedPosition;\r\n        var tickSize = isOpposed ? axis.majorTickLines.height : -axis.majorTickLines.height;\r\n        var axisLineSize = (isOpposed) ? axis.lineStyle.width * 0.5 : -axis.lineStyle.width * 0.5;\r\n        var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ?\r\n            0.5 : 0;\r\n        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? isOpposed ? axis.scrollBarHeight :\r\n            -axis.scrollBarHeight : 0;\r\n        var isTickInside = axis.tickPosition === 'Inside';\r\n        var ticks = isTickInside ? (rect.x - tickSize - axisLineSize) : (rect.x + tickSize + axisLineSize + scrollBarHeight);\r\n        var length = axis.visibleLabels.length;\r\n        var chartThemeStyle = this.chart.themeStyle;\r\n        if (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks' && length > 0) {\r\n            length += 1;\r\n        }\r\n        var minorGridLines = axis.minorGridLines;\r\n        var minorTickLines = axis.minorTickLines;\r\n        //Gridlines\r\n        for (var i = 0; i < length; i++) {\r\n            tempInterval = !axis.visibleLabels[i] ? (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel\r\n                : axis.visibleLabels[i].value - ticksbwtLabel;\r\n            pointY = valueToCoefficient(tempInterval, axis) * rect.height;\r\n            pointY = (pointY * -1) + (rect.y + rect.height);\r\n            if (pointY >= rect.y && (rect.y + rect.height) >= pointY) {\r\n                if ((inside(tempInterval, axis.visibleRange)) || this.isBorder(axis, i, pointY)) {\r\n                    majorGrid = 'M ' + this.seriesClipRect.x + ' ' + (pointY) +\r\n                        ' L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + pointY;\r\n                    this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\r\n                }\r\n                majorTick = 'M ' + (rect.x + axisLineSize + (isTickInside ? scrollBarHeight : 0)) + ' ' + pointY +\r\n                    ' L ' + (ticks) + ' ' + pointY;\r\n                this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\r\n                if ((minorGridLines.width > 0 || minorTickLines.width > 0) && axis.minorTicksPerInterval > 0) {\r\n                    if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {\r\n                        this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\r\n                    }\r\n                    minorGridDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\r\n                    this.renderGridLine(axis, index, minorGridDirection[0], minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, minorGridLines.dashArray);\r\n                    this.renderGridLine(axis, index, minorGridDirection[1], minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\r\n                    if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {\r\n                        this.renderMinorGridOnZooming(axis, (tempInterval + axis.visibleRange.interval), rect, i, index, chartThemeStyle, parent);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * To check the border of the axis\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {number} value value\r\n     * @returns {boolean} check the border of the axis\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.isBorder = function (axis, index, value) {\r\n        var border = this.chart.chartArea.border;\r\n        var rect = this.seriesClipRect;\r\n        var orientation = axis.orientation;\r\n        var start = (orientation === 'Horizontal') ? rect.x : rect.y;\r\n        var size = (orientation === 'Horizontal') ? rect.width : rect.height;\r\n        var startIndex = (orientation === 'Horizontal') ? 0 : axis.visibleLabels.length - 1;\r\n        var endIndex = (orientation === 'Horizontal') ? axis.visibleLabels.length - 1 : 0;\r\n        if (axis.plotOffset > 0) {\r\n            return true;\r\n        }\r\n        else if ((value === start || value === (start + size)) && (border.width <= 0 || border.color === 'transparent')) {\r\n            return true;\r\n        }\r\n        else if ((value !== start && index === startIndex) || (value !== (start + size) && index === endIndex)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * To render the yAxis label\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {Element} parent parent\r\n     * @param {Rect} rect rect\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.drawYAxisLabels = function (axis, index, parent, rect) {\r\n        var chart = this.chart;\r\n        var label;\r\n        var pointX = 0;\r\n        var pointY = 0;\r\n        var elementSize;\r\n        var labelSpace = axis.labelPadding;\r\n        var options;\r\n        var isAxisBreakLabel;\r\n        var isLabelInside = axis.labelPosition === 'Inside';\r\n        var isOpposed = axis.isAxisOpposedPosition;\r\n        var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\r\n        var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\r\n        var angle = axis.angle % 360;\r\n        padding = (isOpposed) ? padding : -padding;\r\n        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });\r\n        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight * (isOpposed ? 1 : -1) : 0;\r\n        var textHeight;\r\n        var textPadding;\r\n        var maxLineWidth;\r\n        var pixel = 10;\r\n        var isInverse = axis.isAxisInverse;\r\n        var previousEnd = isInverse ? rect.y : (rect.y + rect.height);\r\n        var labelPadding;\r\n        var intervalLength;\r\n        var labelHeight;\r\n        var yAxisLabelX;\r\n        var isLabelOnAxisLineLeft = ((!isOpposed && !isLabelInside) || (isOpposed && isLabelInside));\r\n        if (isLabelInside) {\r\n            labelPadding = !isLabelOnAxisLineLeft ? -padding : padding;\r\n        }\r\n        else {\r\n            labelPadding = !isLabelOnAxisLineLeft ? -padding + scrollBarHeight : padding + scrollBarHeight;\r\n        }\r\n        var sizeWidth = [];\r\n        var breakLabelSizeWidth = [];\r\n        axis.visibleLabels.map(function (item) {\r\n            sizeWidth.push(item.size['width']);\r\n            breakLabelSizeWidth.push(item.breakLabelSize['width']);\r\n        });\r\n        var LabelMaxWidth = Math.max.apply(Math, sizeWidth);\r\n        var breakLabelMaxWidth = Math.max.apply(Math, breakLabelSizeWidth);\r\n        for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\r\n            label = axis.visibleLabels[i];\r\n            isAxisBreakLabel = isBreakLabel(axis.visibleLabels[i].originalText);\r\n            elementSize = isAxisBreakLabel ? axis.visibleLabels[i].breakLabelSize : axis.visibleLabels[i].size;\r\n            pointY = (valueToCoefficient(axis.visibleLabels[i].value, axis) * rect.height) + (chart.stockChart ? 7 : 0);\r\n            pointY = Math.floor((pointY * -1) + (rect.y + rect.height));\r\n            textHeight = ((elementSize.height / 8) * axis.visibleLabels[i].text.length / 2);\r\n            textPadding = ((elementSize.height / 4) * 3) + 3;\r\n            intervalLength = rect.height / axis.visibleLabels.length;\r\n            labelHeight = ((axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle !== 0 &&\r\n                elementSize.width > intervalLength) ? intervalLength : elementSize.width;\r\n            pointY = (isAxisBreakLabel ? (axis.labelPosition === 'Inside' ? (pointY - (elementSize.height / 2) - textHeight + textPadding)\r\n                : (pointY - textHeight)) : (axis.labelPosition === 'Inside' ? pointY + textPadding : pointY));\r\n            if (axis.majorGridLines.width > axis.majorTickLines.width) {\r\n                maxLineWidth = axis.majorGridLines.width;\r\n            }\r\n            else {\r\n                maxLineWidth = axis.majorTickLines.width;\r\n            }\r\n            if (axis.labelStyle.textAlignment === 'Far') {\r\n                pointY = pointY - maxLineWidth - pixel;\r\n            }\r\n            else if (axis.labelStyle.textAlignment === 'Near') {\r\n                pointY = pointY + maxLineWidth + pixel;\r\n            }\r\n            else if (axis.labelStyle.textAlignment === 'Center') {\r\n                // eslint-disable-next-line no-self-assign\r\n                pointY = pointY;\r\n            }\r\n            // label X value adjustment (Start)\r\n            if (isLabelInside) {\r\n                yAxisLabelX = labelPadding + ((angle === 0 ? elementSize.width : (isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth)) / 2);\r\n            }\r\n            else {\r\n                yAxisLabelX = labelPadding - ((angle === 0 ? elementSize.width : (isAxisBreakLabel ? breakLabelMaxWidth : LabelMaxWidth)) / 2);\r\n            }\r\n            pointX = isOpposed ? (rect.x - yAxisLabelX) : (rect.x + yAxisLabelX);\r\n            yAxisLabelX = labelPadding;\r\n            options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, 'middle', label.text, '', 'middle');\r\n            switch (axis.edgeLabelPlacement) {\r\n                case 'None':\r\n                    break;\r\n                case 'Hide':\r\n                    if (((i === 0 || (isInverse && i === len - 1)) && options.y > rect.y) ||\r\n                        (((i === len - 1) || (isInverse && i === 0)) && options.y - elementSize.height * 0.5 < rect.y)) {\r\n                        options.text = '';\r\n                    }\r\n                    break;\r\n                case 'Shift':\r\n                    if ((i === 0 || (isInverse && i === len - 1)) && options.y > rect.y) {\r\n                        options.y = pointY = rect.y + rect.height;\r\n                    }\r\n                    else if (((i === len - 1) || (isInverse && i === 0)) && (options.y - elementSize.height * 0.5 < rect.y)) {\r\n                        options.y = pointY = rect.y + elementSize.height * 0.5;\r\n                    }\r\n                    break;\r\n            }\r\n            // ------- Hide Calculation (Start) -------------\r\n            var previousYValue = options.y;\r\n            var currentYValue = options.y - labelHeight;\r\n            if (isAxisBreakLabel) {\r\n                previousYValue = (options.y - (labelHeight / 2));\r\n                currentYValue = options.y + (labelHeight / 2);\r\n            }\r\n            if ((angle === 90 || angle === 270) && axis.labelIntersectAction === 'Hide' && i !== 0 &&\r\n                (!isInverse ? previousYValue >= previousEnd : currentYValue <= previousEnd)) {\r\n                continue;\r\n            }\r\n            previousEnd = isInverse ? previousYValue : currentYValue;\r\n            // ------- Hide Calculation (End) -------------\r\n            options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\r\n            textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabel, labelElement, false, chart.redraw, true, true, null, null, null, null, chart.enableCanvas);\r\n        }\r\n        if (!this.chart.enableCanvas) {\r\n            if (!chart.delayRedraw) {\r\n                appendChildElement(chart.enableCanvas, parent, labelElement, chart.redraw);\r\n            }\r\n            else if (axis.visible && axis.internalVisibility) {\r\n                this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * To get X value based on lineBreakAlignment for Y axis line break labels only.\r\n     *\r\n     * @param {number} x text x position\r\n     * @param {Axis} axis y axis values\r\n     * @param {number} textWidth axis label width\r\n     * @returns {number} returns suitable axis label x position\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.getAxisLabelXvalue = function (x, axis, textWidth) {\r\n        var anchor = axis.lineBreakAlignment;\r\n        var isLabelInside = axis.labelPosition === 'Inside';\r\n        var isOpposed = axis.isAxisOpposedPosition;\r\n        if ((isOpposed && isLabelInside) || (!isOpposed && !isLabelInside)) {\r\n            return (anchor === 'Right' ? x : (anchor === 'Center' ? (x - textWidth / 2) : (x - textWidth)));\r\n        }\r\n        else {\r\n            return (anchor === 'Left' ? x : (anchor === 'Center' ? (x + textWidth / 2) : (x + textWidth)));\r\n        }\r\n    };\r\n    /**\r\n     * To render the yAxis label border.\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {Element} parent parent\r\n     * @param {Rect} rect rect\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.drawYAxisBorder = function (axis, index, parent, rect) {\r\n        if (axis.border.width > 0) {\r\n            var startY = void 0;\r\n            var pointY = void 0;\r\n            var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;\r\n            var isOpposed = axis.isAxisOpposedPosition;\r\n            scrollBarHeight = (isOpposed ? 1 : -1) * scrollBarHeight;\r\n            var gap = (rect.height / axis.visibleRange.delta) * (axis.valueType === 'DateTime' ? axis.dateTimeInterval\r\n                : axis.visibleRange.interval);\r\n            var endY = void 0;\r\n            var length_1 = axis.maxLabelSize.width + 10 + ((axis.tickPosition === axis.labelPosition) ?\r\n                axis.majorTickLines.height : 0);\r\n            var labelBorder = '';\r\n            var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? -0.5 : 0;\r\n            var endX = ((isOpposed && axis.labelPosition === 'Inside') || (!isOpposed\r\n                && axis.labelPosition === 'Outside')) ? rect.x - length_1 + scrollBarHeight : rect.x + length_1 + scrollBarHeight;\r\n            for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\r\n                pointY = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\r\n                pointY = (axis.isAxisInverse ? (1 - pointY) : pointY) * rect.height;\r\n                if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\r\n                    startY = (pointY * -1) + (rect.y + rect.height);\r\n                    endY = (pointY * -1) - (gap) + (rect.y + rect.height);\r\n                }\r\n                else {\r\n                    startY = (pointY * -1) + gap / 2 + (rect.y + rect.height);\r\n                    endY = (pointY * -1) - gap / 2 + (rect.y + rect.height);\r\n                }\r\n                switch (axis.border.type) {\r\n                    case 'Rectangle':\r\n                    case 'WithoutTopBorder':\r\n                        if (startY > (rect.y + rect.height)) {\r\n                            labelBorder += ('M' + ' ' + endX + ' ' + (rect.y + rect.height) + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\r\n                        }\r\n                        else if (Math.floor(rect.y) > (endY)) {\r\n                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX\r\n                                + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + (rect.y) + ' ');\r\n                        }\r\n                        else {\r\n                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX +\r\n                                ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\r\n                            if (i === axis.visibleLabels.length - 1) {\r\n                                labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY + ' ' + 'L' + ' ' +\r\n                                    endX + ' ' + endY + ' ');\r\n                            }\r\n                        }\r\n                        break;\r\n                    case 'WithoutTopandBottomBorder':\r\n                        if (!(startY > rect.y + rect.height) && !((endY) < Math.floor(rect.y))) {\r\n                            labelBorder += ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + startY + ' ' + 'L' + ' ' + endX +\r\n                                ' ' + startY + ' ' + 'M' + ' ' + endX + ' ' + endY + ' ' +\r\n                                'L' + ' ' + (rect.x + scrollBarHeight) + ' ' + endY);\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            labelBorder += (axis.border.type === 'Rectangle') ? ('M' + ' ' + (rect.x + scrollBarHeight) + ' ' + rect.y + ' ' + 'L' + ' ' +\r\n                (rect.x + scrollBarHeight) + ' ' + (rect.y + rect.height) + ' ') : '';\r\n            if (labelBorder !== '') {\r\n                this.createAxisBorderElement(axis, index, labelBorder, parent);\r\n            }\r\n        }\r\n        if (axis.multiLevelLabels.length > 0 && this.chart.multiLevelLabelModule) {\r\n            this.chart.multiLevelLabelModule.renderYAxisMultiLevelLabels(axis, index, parent, rect);\r\n        }\r\n    };\r\n    /**\r\n     * To render the yAxis title\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {Element} parent parent\r\n     * @param {Rect} rect rect\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.drawYAxisTitle = function (axis, index, parent, rect) {\r\n        if (axis.title) {\r\n            var chart = this.chart;\r\n            var isOpposed = axis.isAxisOpposedPosition;\r\n            var labelRotation = isOpposed ? 90 : -90;\r\n            var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) +\r\n                (axis.labelPosition === 'Inside' ? 0 :\r\n                    (axis.maxLabelSize.width + axis.multiLevelLabelHeight + this.padding));\r\n            padding = isOpposed ? padding + axis.scrollBarHeight : -padding - axis.scrollBarHeight;\r\n            var x = rect.x + padding;\r\n            var y = rect.y + rect.height * 0.5;\r\n            var titleSize = (axis.titleSize.height * (axis.titleCollection.length - 1));\r\n            var options = new TextOption(chart.element.id + '_AxisTitle_' + index, x, y - axis.labelPadding - titleSize, 'middle', axis.titleCollection, 'rotate(' + labelRotation + ',' + (x) + ',' + (y) + ')', null, labelRotation);\r\n            var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitle, parent, null, null, null, null, null, null, null, null, chart.enableCanvas);\r\n            element.setAttribute('tabindex', axis.tabIndex.toString());\r\n            element.setAttribute('aria-label', axis.description || axis.title);\r\n        }\r\n    };\r\n    /**\r\n     * xAxis grid line calculation performed here\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {Element} parent parent\r\n     * @param {Rect} rect rect\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.drawXAxisGridLine = function (axis, index, parent, rect) {\r\n        var isLogAxis = axis.valueType === 'Logarithmic';\r\n        var isCategoryAxis = axis.valueType.indexOf('Category') > -1;\r\n        var tempInterval;\r\n        var pointX = 0;\r\n        var majorGrid = '';\r\n        var majorTick = '';\r\n        var minorDirection;\r\n        var isOpposed = axis.isAxisOpposedPosition;\r\n        var tickSize = (isOpposed) ? -axis.majorTickLines.height : axis.majorTickLines.height;\r\n        var axisLineSize = (isOpposed) ? -axis.lineStyle.width * 0.5 : axis.lineStyle.width * 0.5;\r\n        var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? isOpposed ? -axis.scrollBarHeight :\r\n            axis.scrollBarHeight : 0;\r\n        var ticksbwtLabel = (axis.valueType.indexOf('Category') > -1 && axis.labelPlacement === 'BetweenTicks') ?\r\n            0.5 : 0;\r\n        var length = axis.visibleLabels.length;\r\n        var isTickInside = axis.tickPosition === 'Inside';\r\n        var ticks = isTickInside ? (rect.y - tickSize - axisLineSize) : (rect.y + tickSize + axisLineSize + scrollBarHeight);\r\n        var chartThemeStyle = this.chart.themeStyle;\r\n        if (axis.valueType.indexOf('Category') > -1 && length > 0 && axis.labelPlacement === 'BetweenTicks') {\r\n            length += 1;\r\n        }\r\n        //Gridlines\r\n        for (var i = 0; i < length; i++) {\r\n            if (axis.valueType !== 'DateTimeCategory') {\r\n                tempInterval = axis.visibleLabels[i] ? axis.visibleLabels[i].value - ticksbwtLabel\r\n                    : (axis.visibleLabels[i - 1].value + axis.visibleRange.interval) - ticksbwtLabel;\r\n            }\r\n            else {\r\n                tempInterval = axis.visibleLabels[i] ?\r\n                    axis.visibleLabels[i].value - ticksbwtLabel : axis.visibleRange.max;\r\n            }\r\n            pointX = (valueToCoefficient(tempInterval, axis) * rect.width) + rect.x;\r\n            if (pointX >= rect.x && (rect.x + rect.width) >= pointX) {\r\n                if (inside(tempInterval, axis.visibleRange) || this.isBorder(axis, i, pointX)) {\r\n                    majorGrid = 'M ' + pointX + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height) +\r\n                        ' L ' + pointX + ' ' + this.seriesClipRect.y;\r\n                    this.renderGridLine(axis, index, majorGrid, axis.majorGridLines, '_MajorGridLine_', i, this.element, chartThemeStyle.majorGridLine, axis.majorGridLines.dashArray);\r\n                }\r\n                majorTick = 'M ' + (pointX) + ' ' + (rect.y + axisLineSize + (isTickInside ? scrollBarHeight : 0))\r\n                    + ' L ' + (pointX) + ' ' + ticks;\r\n                this.renderGridLine(axis, index, majorTick, axis.majorTickLines, '_MajorTickLine_', i, parent, chartThemeStyle.majorTickLine);\r\n                if (axis.minorTicksPerInterval > 0 && (axis.minorGridLines.width > 0 || axis.minorTickLines.width > 0)) {\r\n                    if (i === 0 && isZoomSet(axis) && !isLogAxis && !isCategoryAxis) {\r\n                        this.renderMinorGridOnZooming(axis, tempInterval, rect, i, index, chartThemeStyle, parent);\r\n                    }\r\n                    minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i);\r\n                    this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', i, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);\r\n                    this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', i, parent, chartThemeStyle.minorTickLine);\r\n                    if (i === length - 1 && isZoomSet(axis) && isLogAxis && !isCategoryAxis) {\r\n                        this.renderMinorGridOnZooming(axis, (tempInterval + axis.visibleRange.interval), rect, i, index, chartThemeStyle, parent);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * To render missing minor grid lines while zooming\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} tempInterval tempInterval\r\n     * @param {Rect} rect rect\r\n     * @param {number} i i\r\n     * @param {number} index index\r\n     * @param {IThemeStyle} chartThemeStyle chartThemeStyle\r\n     * @param {Element} parent parent\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.renderMinorGridOnZooming = function (axis, tempInterval, rect, i, index, chartThemeStyle, parent) {\r\n        var minorDirection = this.drawAxisMinorLine(axis, tempInterval, rect, i, true);\r\n        this.renderGridLine(axis, index, minorDirection[0], axis.minorGridLines, '_MinorGridLine_', -1, this.element, chartThemeStyle.minorGridLine, axis.minorGridLines.dashArray);\r\n        this.renderGridLine(axis, index, minorDirection[1], axis.minorTickLines, '_MinorTickLine_', -1, parent, chartThemeStyle.minorTickLine);\r\n    };\r\n    /**\r\n     * To calcualte the axis minor line\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} tempInterval tempInterval\r\n     * @param {Rect} rect rect\r\n     * @param {number} labelIndex labelIndex\r\n     * @param {boolean} isFirstLabel isFirstLabel\r\n     * @returns {string[]} axis minor line path\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.drawAxisMinorLine = function (axis, tempInterval, rect, labelIndex, isFirstLabel) {\r\n        var value = tempInterval;\r\n        var coor = 0;\r\n        var position = 0;\r\n        var range = axis.visibleRange;\r\n        var isTickInside = axis.tickPosition === 'Inside';\r\n        var direction = [];\r\n        var tickSize = axis.isAxisOpposedPosition ? -axis.minorTickLines.height : axis.minorTickLines.height;\r\n        var logStart;\r\n        var logEnd;\r\n        var logInterval = 1;\r\n        var logPosition = 1;\r\n        var ticksX = isTickInside ? (rect.y - tickSize) : (rect.y + tickSize);\r\n        var ticksY = isTickInside ? (rect.x + tickSize) : (rect.x - tickSize);\r\n        var minorGird = '';\r\n        var minorTick = '';\r\n        var isInverse = axis.isAxisInverse;\r\n        if (axis.valueType === 'Logarithmic') {\r\n            logStart = Math.pow(axis.logBase, value - range.interval);\r\n            logEnd = Math.pow(axis.logBase, value);\r\n            logInterval = (logEnd - logStart) / (axis.minorTicksPerInterval + 1);\r\n            logPosition = logStart + logInterval;\r\n        }\r\n        if (axis.orientation === 'Horizontal') {\r\n            for (var j = 0; j < axis.minorTicksPerInterval; j++) {\r\n                value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\r\n                logPosition += logInterval;\r\n                if (inside(value, range)) {\r\n                    position = ((value - range.min) / (range.max - range.min));\r\n                    position = Math.ceil((isInverse ? (1 - position) : position) * rect.width);\r\n                    coor = (Math.floor(position + rect.x));\r\n                    minorGird = minorGird.concat('M' + ' ' + coor + ' ' + (this.seriesClipRect.y)\r\n                        + 'L ' + coor + ' ' + (this.seriesClipRect.y + this.seriesClipRect.height));\r\n                    coor = (Math.floor(position + rect.x));\r\n                    minorTick = minorTick.concat('M' + ' ' + coor + ' ' + (rect.y)\r\n                        + 'L ' + coor + ' ' + (ticksX + axis.scrollBarHeight));\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (var j = 0; j < axis.minorTicksPerInterval; j++) {\r\n                value = this.findLogNumeric(axis, logPosition, value, labelIndex, isFirstLabel);\r\n                if (inside(value, range)) {\r\n                    position = ((value - range.min) / (range.max - range.min));\r\n                    position = Math.ceil(((isInverse ? (1 - position) : position)) * rect.height) * -1; // For inversed axis\r\n                    coor = (Math.floor(position + rect.y + rect.height));\r\n                    minorGird = minorGird.concat('M' + ' ' + (this.seriesClipRect.x) + ' ' + coor\r\n                        + 'L ' + (this.seriesClipRect.x + this.seriesClipRect.width) + ' ' + coor + ' ');\r\n                    coor = (Math.floor(position + rect.y + rect.height));\r\n                    minorTick = minorTick.concat('M' + ' ' + rect.x + ' ' + coor + 'L ' + (ticksY - axis.scrollBarHeight) +\r\n                        ' ' + coor + ' ');\r\n                }\r\n                logPosition += logInterval;\r\n            }\r\n        }\r\n        direction.push(minorGird);\r\n        direction.push(minorTick);\r\n        return direction;\r\n    };\r\n    /**\r\n     * To find the numeric value of the log\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} logPosition logPosition\r\n     * @param {number} value value\r\n     * @param {number} labelIndex labelIndex\r\n     * @param {boolean} isFirstLabel isFirstLabel\r\n     * @returns {number} value\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.findLogNumeric = function (axis, logPosition, value, labelIndex, isFirstLabel) {\r\n        var range = axis.visibleRange;\r\n        var tempValue;\r\n        if (axis.valueType === 'Logarithmic') {\r\n            value = logBase(logPosition, axis.logBase);\r\n        }\r\n        else if (axis.valueType === 'DateTime') {\r\n            tempValue = axis.dateTimeInterval / (axis.minorTicksPerInterval + 1);\r\n            value = isFirstLabel ? (value - tempValue) : (value + tempValue);\r\n        }\r\n        else if (axis.valueType === 'DateTimeCategory') {\r\n            var padding = axis.labelPlacement === 'BetweenTicks' ? 0.5 : 0;\r\n            value += ((axis.visibleLabels[labelIndex + 1] ?\r\n                axis.visibleLabels[labelIndex + 1].value - padding : axis.visibleRange.max) -\r\n                (axis.visibleLabels[labelIndex] ?\r\n                    axis.visibleLabels[labelIndex].value - padding : axis.visibleRange.min)) /\r\n                (axis.minorTicksPerInterval + 1);\r\n        }\r\n        else {\r\n            tempValue = range.interval / (axis.minorTicksPerInterval + 1);\r\n            value = isFirstLabel ? (value - tempValue) : (value + tempValue);\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * To render the xAxis Labels\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {Element} parent parent\r\n     * @param {Rect} rect rect\r\n     * @returns {void}\r\n     * @private\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.drawXAxisLabels = function (axis, index, parent, rect) {\r\n        var chart = this.chart;\r\n        var pointX = 0;\r\n        var pointY = 0;\r\n        var labelSpace = axis.labelPadding;\r\n        var labelHeight;\r\n        var elementSize;\r\n        var labelPadding;\r\n        var anchor;\r\n        var pixel = 10;\r\n        var labelElement = chart.renderer.createGroup({ id: chart.element.id + 'AxisLabels' + index });\r\n        var islabelInside = axis.labelPosition === 'Inside';\r\n        var isOpposed = axis.isAxisOpposedPosition;\r\n        var tickSpace = axis.labelPosition === axis.tickPosition ? axis.majorTickLines.height : 0;\r\n        var padding = tickSpace + labelSpace + axis.lineStyle.width * 0.5;\r\n        var angle = axis.angle % 360;\r\n        var isHorizontalAngle = (angle === 0 || angle === -180 || angle === 180);\r\n        var options;\r\n        var labelWidth;\r\n        var isInverse = axis.isAxisInverse;\r\n        var previousEnd = isInverse ? (rect.x + rect.width) : rect.x;\r\n        var width = 0;\r\n        var length = axis.visibleLabels.length;\r\n        var intervalLength;\r\n        var label;\r\n        var isAxisBreakLabel;\r\n        var scrollBarHeight = axis.scrollbarSettings.enable || (!islabelInside && isNullOrUndefined(axis.crossesAt)\r\n            && (axis.zoomFactor < 1 || axis.zoomPosition > 0)) ? axis.scrollBarHeight : 0;\r\n        var newPoints = [];\r\n        var isRotatedLabelIntersect = false;\r\n        padding += (angle === 90 || angle === 270 || angle === -90 || angle === -270) ? (islabelInside ? 5 : -5) : 0;\r\n        var isLabelUnderAxisLine = ((!isOpposed && !islabelInside) || (isOpposed && islabelInside));\r\n        var isEndAnchor = isLabelUnderAxisLine ?\r\n            ((360 >= angle && angle >= 180) || (-1 >= angle && angle >= -180)) :\r\n            ((1 <= angle && angle <= 180) || (-181 >= angle && angle >= -360));\r\n        for (var i = 0, len = length; i < len; i++) {\r\n            label = axis.visibleLabels[i];\r\n            isAxisBreakLabel = isBreakLabel(label.originalText);\r\n            pointX = (valueToCoefficient(label.value, axis) * rect.width) + rect.x;\r\n            elementSize = label.size;\r\n            intervalLength = rect.width / length;\r\n            labelWidth = isAxisBreakLabel ? label.breakLabelSize.width : elementSize.width;\r\n            width = ((axis.labelIntersectAction === 'Trim' || axis.labelIntersectAction === 'Wrap') && angle === 0 &&\r\n                labelWidth > intervalLength) ? intervalLength : labelWidth;\r\n            labelHeight = elementSize.height / 4;\r\n            pointX -= (isAxisBreakLabel || angle !== 0) ? 0 : (width / 2);\r\n            // label X value adjustment for label rotation (Start)\r\n            if (angle !== 0) {\r\n                if (isAxisBreakLabel) {\r\n                    pointX -= axis.lineBreakAlignment === 'Left' ? (label.breakLabelSize.width / 2) : axis.lineBreakAlignment === 'Right' ?\r\n                        -(label.breakLabelSize.width / 2) : 0;\r\n                }\r\n                else {\r\n                    pointX -= (angle === -90 || angle === 270 ? -labelHeight : (angle === 90 || angle === -270) ? labelHeight : 0);\r\n                }\r\n            }\r\n            // label X value adjustment for label rotation (End)\r\n            if (axis.labelStyle.textAlignment === 'Far') {\r\n                pointX = pointX + width - pixel;\r\n            }\r\n            else if (axis.labelStyle.textAlignment === 'Near') {\r\n                pointX = pointX - width + pixel;\r\n            }\r\n            else if (axis.labelStyle.textAlignment === 'Center') {\r\n                // eslint-disable-next-line no-self-assign\r\n                pointX = pointX;\r\n            }\r\n            // For line break label alignment like left, right & center in angle 0\r\n            if (isAxisBreakLabel && axis.lineBreakAlignment !== 'Center' && angle === 0) {\r\n                pointX += axis.lineBreakAlignment === 'Left' ? -(width / 2) : (width / 2);\r\n            }\r\n            var paddingForBreakLabel = isAxisBreakLabel ?\r\n                (isHorizontalAngle ? (elementSize.height) : (label.breakLabelSize.width / 2)) : 0;\r\n            padding = isAxisBreakLabel ? (tickSpace + labelSpace + axis.lineStyle.width * 0.5) : padding;\r\n            // label Y value adjustment (Start)\r\n            if (islabelInside && angle) {\r\n                if (isAxisBreakLabel) {\r\n                    pointY = isOpposed ? (rect.y + padding + (paddingForBreakLabel)) : (rect.y - padding - (paddingForBreakLabel));\r\n                }\r\n                else {\r\n                    pointY = isOpposed ? (rect.y + padding + labelHeight) : (rect.y - padding - labelHeight);\r\n                }\r\n            }\r\n            else {\r\n                if (isAxisBreakLabel) {\r\n                    labelPadding = !isLabelUnderAxisLine ? -(padding + scrollBarHeight + (paddingForBreakLabel)) :\r\n                        padding + scrollBarHeight + (angle ? paddingForBreakLabel : (3 * labelHeight));\r\n                }\r\n                else {\r\n                    labelPadding = !isLabelUnderAxisLine ?\r\n                        -(padding + scrollBarHeight + (angle ? labelHeight : (label.index > 1 ? (2 * labelHeight) : 0))) :\r\n                        padding + scrollBarHeight + ((angle ? 1 : 3) * labelHeight);\r\n                }\r\n                pointY = (rect.y + (labelPadding * label.index));\r\n            }\r\n            // label Y value adjustment (End)\r\n            if (isAxisBreakLabel) {\r\n                anchor = this.getAnchor(axis); // for break label self alignment\r\n            }\r\n            else {\r\n                anchor = (chart.enableRtl) ? ((isEndAnchor) ? '' : 'end') : (chart.isRtlEnabled || isEndAnchor) ? 'end' : '';\r\n            }\r\n            options = new TextOption(chart.element.id + index + '_AxisLabel_' + i, pointX, pointY, anchor);\r\n            if (axis.edgeLabelPlacement && (angle === 0)) {\r\n                switch (axis.edgeLabelPlacement) {\r\n                    case 'None':\r\n                        break;\r\n                    case 'Hide':\r\n                        if (((i === 0 || (isInverse && i === len - 1)) && options.x < rect.x) ||\r\n                            ((i === len - 1 || (isInverse && i === 0)) && (options.x + width > rect.x + rect.width))) {\r\n                            continue;\r\n                        }\r\n                        break;\r\n                    case 'Shift':\r\n                        if ((i === 0 || (isInverse && i === len - 1)) && options.x < rect.x) {\r\n                            intervalLength -= (rect.x - options.x);\r\n                            options.x = pointX = rect.x;\r\n                        }\r\n                        else if ((i === len - 1 || (isInverse && i === 0)) && ((options.x + width) > rect.x + rect.width)) {\r\n                            if (elementSize.width > intervalLength && axis.labelIntersectAction === 'Trim') {\r\n                                intervalLength -= (options.x + width - (rect.x + rect.width));\r\n                            }\r\n                            else {\r\n                                intervalLength = width;\r\n                            }\r\n                            options.x = pointX = rect.x + rect.width - intervalLength;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            options.text = this.getLabelText(label, axis, intervalLength);\r\n            // ------- Hide Calculation (Start) -------------\r\n            // Currect label actual start value (Start)\r\n            var xValue = void 0;\r\n            var xValue2 = void 0;\r\n            if (isAxisBreakLabel && angle === 0) {\r\n                if (axis.lineBreakAlignment === 'Right') {\r\n                    xValue = (options.x - width);\r\n                    xValue2 = options.x;\r\n                }\r\n                else if (axis.lineBreakAlignment === 'Center') {\r\n                    xValue = (options.x - (width / 2));\r\n                    xValue2 = options.x + (width / 2);\r\n                }\r\n                else {\r\n                    xValue = options.x;\r\n                    xValue2 = options.x + width;\r\n                }\r\n            }\r\n            else {\r\n                xValue = options.x;\r\n                xValue2 = options.x + width;\r\n            }\r\n            // Currect label actual start value (End)\r\n            if (angle === 0 && axis.labelIntersectAction === 'Hide' && i !== 0 &&\r\n                (!isInverse ? xValue <= previousEnd : xValue2 >= previousEnd)) {\r\n                continue;\r\n            }\r\n            // Previous label actual end value (Start)\r\n            if (isAxisBreakLabel) {\r\n                if (axis.lineBreakAlignment === 'Right') {\r\n                    previousEnd = isInverse ? (options.x - width) : options.x;\r\n                }\r\n                else if (axis.lineBreakAlignment === 'Center') {\r\n                    previousEnd = isInverse ? (options.x - (width / 2)) : options.x + (width / 2);\r\n                }\r\n                else {\r\n                    previousEnd = isInverse ? options.x : options.x + width;\r\n                }\r\n            }\r\n            else {\r\n                previousEnd = isInverse ? options.x : options.x + width;\r\n            }\r\n            // Previous label actual end value (End)\r\n            // ------- Hide Calculation (End) -------------\r\n            // label Rotataion calculation (Start)\r\n            if (angle !== 0) {\r\n                var height = void 0;\r\n                var rect_1 = void 0;\r\n                if (isAxisBreakLabel) {\r\n                    var xAdjustment = 0;\r\n                    var yAdjustment = 0;\r\n                    height = (label.breakLabelSize.height);\r\n                    yAdjustment = (label.breakLabelSize.height) - 4; // 4 for label bound correction\r\n                    // xAdjustment (Start)\r\n                    if (axis.lineBreakAlignment === 'Center') {\r\n                        xAdjustment = -(label.breakLabelSize.width / 2);\r\n                    }\r\n                    else if (axis.lineBreakAlignment === 'Right') {\r\n                        xAdjustment = -label.breakLabelSize.width;\r\n                    }\r\n                    // xAdjustment (End)\r\n                    if (isLabelUnderAxisLine) {\r\n                        yAdjustment = (label.breakLabelSize.height) / (options.text.length + 1);\r\n                    }\r\n                    rect_1 = new Rect(options.x + xAdjustment, options.y - (yAdjustment), label.breakLabelSize.width, height);\r\n                }\r\n                else {\r\n                    height = (pointY) - (options.y - ((label.size.height / 2) + 10));\r\n                    rect_1 = new Rect(options.x, options.y - ((label.size.height / 2) - 5), label.size.width, height);\r\n                }\r\n                var rectCoordinates = this.getRectanglePoints(rect_1);\r\n                var rectCenterX = isAxisBreakLabel ? rect_1.x + (rect_1.width / 2) : pointX;\r\n                var rectCenterY = isAxisBreakLabel ? rect_1.y + (rect_1.height / 2) : (pointY - (height / 2));\r\n                if (isAxisBreakLabel) {\r\n                    options.transform = 'rotate(' + angle + ',' + rectCenterX + ',' + rectCenterY + ')';\r\n                }\r\n                else {\r\n                    options.transform = 'rotate(' + angle + ',' + pointX + ',' + pointY + ')';\r\n                }\r\n                newPoints.push(getRotatedRectangleCoordinates(rectCoordinates, rectCenterX, rectCenterY, angle));\r\n                isRotatedLabelIntersect = false;\r\n                for (var index_1 = i; index_1 > 0; index_1--) {\r\n                    if (newPoints[i] && newPoints[index_1 - 1] && isRotatedRectIntersect(newPoints[i], newPoints[index_1 - 1])) {\r\n                        isRotatedLabelIntersect = true;\r\n                        newPoints[i] = null;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            // label Rotataion calculation (End)\r\n            textElement(chart.renderer, options, label.labelStyle, label.labelStyle.color || chart.themeStyle.axisLabel, labelElement, (axis.isAxisOpposedPosition !== (axis.labelPosition === 'Inside')), chart.redraw, true, null, null, null, label.size, isRotatedLabelIntersect, chart.enableCanvas);\r\n        }\r\n        if (!this.chart.enableCanvas) {\r\n            if (!chart.delayRedraw) {\r\n                parent.appendChild(labelElement);\r\n            }\r\n            else if (axis.visible && axis.internalVisibility) {\r\n                this.createZoomingLabel(this.chart, labelElement, axis, index, rect);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * To get text anchor value for line break labels.\r\n     *\r\n     * @param {Axis} axis axis model\r\n     * @returns {string} returns text anchor\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.getAnchor = function (axis) {\r\n        return (axis.lineBreakAlignment === 'Center' ? 'middle' : (this.chart.enableRtl) ? (axis.lineBreakAlignment === 'Left' ? 'end' : 'start') : (axis.lineBreakAlignment === 'Left' ? 'start' : 'end'));\r\n    };\r\n    /**\r\n     * Get rect coordinates\r\n     *\r\n     * @param {Rect} rect rect\r\n     * @returns {ChartLocation[]} rectangle points\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.getRectanglePoints = function (rect) {\r\n        var point1 = new ChartLocation(rect.x, rect.y);\r\n        var point2 = new ChartLocation(rect.x + rect.width, rect.y);\r\n        var point3 = new ChartLocation(rect.x + rect.width, rect.y + rect.height);\r\n        var point4 = new ChartLocation(rect.x, rect.y + rect.height);\r\n        return [point1, point2, point3, point4];\r\n    };\r\n    /**\r\n     * To get axis label text\r\n     *\r\n     * @param {VisibleLabels} label label\r\n     * @param {Axis} axis axis\r\n     * @param {number} intervalLength intervalLength\r\n     * @returns {string | string[]} label or label collection\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.getLabelText = function (label, axis, intervalLength) {\r\n        if (isBreakLabel(label.originalText)) {\r\n            var result = [];\r\n            var str = void 0;\r\n            for (var index = 0; index < label.text.length; index++) {\r\n                str = this.findAxisLabel(axis, label.text[index], intervalLength);\r\n                result.push(str);\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            return this.findAxisLabel(axis, label.text, intervalLength);\r\n        }\r\n    };\r\n    /**\r\n     * To render the x-axis label border.\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {Element} parent parent\r\n     * @param {Rect} axisRect axisRect\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.drawXAxisBorder = function (axis, index, parent, axisRect) {\r\n        if (axis.border.width > 0) {\r\n            var scrollBarHeight = axis.labelPosition === 'Outside' ? axis.scrollBarHeight : 0;\r\n            var isOpposed = axis.isAxisOpposedPosition;\r\n            var startX = void 0;\r\n            var startY = axisRect.y + ((isOpposed ? -1 : 1) * scrollBarHeight);\r\n            var padding = 10;\r\n            var pointX = void 0;\r\n            var gap = (axisRect.width / axis.visibleRange.delta) * (axis.valueType === 'DateTime' ? axis.dateTimeInterval\r\n                : axis.visibleRange.interval);\r\n            var endX = void 0;\r\n            var length_2 = axis.maxLabelSize.height +\r\n                ((axis.tickPosition === axis.labelPosition) ? axis.majorTickLines.height : 0);\r\n            var labelBorder = '';\r\n            var ticksbwtLabel = (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') ? -0.5 : 0;\r\n            var endY = ((isOpposed && axis.labelPosition === 'Inside') ||\r\n                (!isOpposed && axis.labelPosition === 'Outside')) ?\r\n                (axisRect.y + length_2 + padding + scrollBarHeight) : (axisRect.y - length_2 - padding - scrollBarHeight);\r\n            for (var i = 0, len = axis.visibleLabels.length; i < len; i++) {\r\n                pointX = valueToCoefficient(axis.visibleLabels[i].value + ticksbwtLabel, axis);\r\n                pointX = (axis.isAxisInverse ? (1 - pointX) : pointX) * axisRect.width;\r\n                if (axis.valueType === 'Category' && axis.labelPlacement === 'BetweenTicks') {\r\n                    startX = pointX + axisRect.x;\r\n                    endX = pointX + (gap) + axisRect.x;\r\n                }\r\n                else {\r\n                    startX = pointX - gap * 0.5 + axisRect.x;\r\n                    endX = pointX + gap * 0.5 + axisRect.x;\r\n                }\r\n                switch (axis.border.type) {\r\n                    case 'Rectangle':\r\n                    case 'WithoutTopBorder':\r\n                        if (startX < axisRect.x) {\r\n                            labelBorder += ('M' + ' ' + axisRect.x + ' ' + endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\r\n                        }\r\n                        else if (Math.floor(endX) > axisRect.width + axisRect.x && !(axis.visibleLabels.length === 1)) {\r\n                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +\r\n                                'L' + ' ' + (axisRect.width + axisRect.x) + ' ' + endY + ' ');\r\n                        }\r\n                        else {\r\n                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' +\r\n                                endY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ');\r\n                            if (i === 0) {\r\n                                labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +\r\n                                    'M ' + startX + ' ' + endY + ' L ' + (axisRect.x) + ' ' + endY);\r\n                            }\r\n                            if (i === axis.visibleLabels.length - 1) {\r\n                                labelBorder += ('M' + ' ' + endX + ' ' + startY + ' ' + 'L' + ' ' + endX + ' ' + endY + ' ' +\r\n                                    'M ' + endX + ' ' + endY + ' L ' + (axisRect.width + axisRect.x) + ' ' + endY);\r\n                            }\r\n                        }\r\n                        break;\r\n                    case 'WithoutTopandBottomBorder':\r\n                        if (!(startX < axisRect.x) && !(Math.floor(endX) > axisRect.width + axisRect.x)) {\r\n                            labelBorder += ('M' + ' ' + startX + ' ' + startY + ' ' + 'L' + ' ' + startX + ' ' + endY + ' ' +\r\n                                'M ' + endX + ' ' + startY + ' L ' + endX + ' ' + endY);\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            labelBorder += (axis.border.type === 'Rectangle' ? ('M ' + ' ' + axisRect.x + ' ' + startY + 'L' + ' ' +\r\n                (axisRect.x + axisRect.width) + ' ' + startY) : '');\r\n            if (labelBorder !== '') {\r\n                this.createAxisBorderElement(axis, index, labelBorder, parent);\r\n            }\r\n        }\r\n        if (this.chart.multiLevelLabelModule && axis.multiLevelLabels.length > 0) {\r\n            this.chart.multiLevelLabelModule.renderXAxisMultiLevelLabels(axis, index, parent, axisRect);\r\n        }\r\n    };\r\n    /**\r\n     * To create border element of the axis\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {string} labelBorder labelBorder\r\n     * @param {Element} parent parent\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.createAxisBorderElement = function (axis, index, labelBorder, parent) {\r\n        var element = getElement(this.chart.element.id + '_BorderLine_' + index);\r\n        var direction = element ? element.getAttribute('d') : '';\r\n        var borderElement = this.chart.renderer.drawPath(new PathOption(this.chart.element.id + '_BorderLine_' + index, 'transparent', axis.border.width, axis.border.color || this.chart.themeStyle.axisLine, 1, '', labelBorder));\r\n        borderElement.style.pointerEvents = 'none';\r\n        appendChildElement(this.chart.enableCanvas, parent, borderElement, this.chart.redraw, true, 'x', 'y', null, direction, true);\r\n    };\r\n    /**\r\n     * To find the axis label of the intersect action\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {string} label label\r\n     * @param {number} width width\r\n     * @returns {string} label\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.findAxisLabel = function (axis, label, width) {\r\n        return (axis.labelIntersectAction === 'Trim' ?\r\n            ((axis.angle % 360 === 0 && !axis.enableTrim) ? textTrim(width, label, axis.labelStyle) : label) : label);\r\n    };\r\n    /**\r\n     * X-Axis Title function performed\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {Element} parent parent\r\n     * @param {Rect} rect rect\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.drawXAxisTitle = function (axis, index, parent, rect) {\r\n        if (axis.title) {\r\n            var chart = this.chart;\r\n            var elementSize = measureText(axis.title, axis.titleStyle);\r\n            var scrollBarHeight = isNullOrUndefined(axis.crossesAt) ? axis.scrollBarHeight : 0;\r\n            var padding = (axis.tickPosition === 'Inside' ? 0 : axis.majorTickLines.height + axis.titlePadding) +\r\n                (axis.labelPosition === 'Inside' ? 0 :\r\n                    axis.maxLabelSize.height + axis.multiLevelLabelHeight + axis.labelPadding);\r\n            var titleSize = (axis.titleSize.height * (axis.titleCollection.length - 1));\r\n            padding = axis.isAxisOpposedPosition ? -(padding + elementSize.height / 4 + scrollBarHeight + titleSize) : (padding + (3 *\r\n                elementSize.height / 4) + scrollBarHeight);\r\n            var options = new TextOption(chart.element.id + '_AxisTitle_' + index, rect.x + rect.width * 0.5, rect.y + padding, 'middle', axis.titleCollection);\r\n            var element = textElement(chart.renderer, options, axis.titleStyle, axis.titleStyle.color || chart.themeStyle.axisTitle, parent, null, null, null, null, null, null, null, null, chart.enableCanvas);\r\n            element.setAttribute('aria-label', axis.description || axis.title);\r\n            element.setAttribute('tabindex', axis.tabIndex.toString());\r\n        }\r\n    };\r\n    /**\r\n     * To render the axis grid and tick lines(Both Major and Minor)\r\n     *\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {string} gridDirection gridDirection\r\n     * @param {MajorTickLinesModel | MinorTickLinesModel | MajorGridLinesModel | MinorGridLinesModel} gridModel gridModel\r\n     * @param {string} gridId gridId\r\n     * @param {number} gridIndex gridIndex\r\n     * @param {Element} parent parent\r\n     * @param {string} themeColor themeColor\r\n     * @param {string} dashArray dashArray\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.renderGridLine = function (axis, index, gridDirection, gridModel, gridId, gridIndex, parent, themeColor, dashArray) {\r\n        if (dashArray === void 0) { dashArray = null; }\r\n        var chart = this.chart;\r\n        var direction;\r\n        var element;\r\n        if (gridModel.width > 0 && axis.visible && axis.internalVisibility && gridDirection) {\r\n            element = getElement(chart.element.id + gridId + index + '_' + gridIndex);\r\n            direction = element ? element.getAttribute('d') : null;\r\n            element = null;\r\n            this.htmlObject = chart.renderer.drawPath(new PathOption(chart.element.id + gridId + index + '_' + gridIndex, 'transparent', gridModel.width, gridModel.color || themeColor, null, dashArray, gridDirection));\r\n            appendChildElement(chart.enableCanvas, parent, this.htmlObject, chart.redraw, true, 'x', 'y', null, direction, true);\r\n        }\r\n    };\r\n    /**\r\n     * To Find the parent node of the axis\r\n     *\r\n     * @param {string} elementId elementId\r\n     * @param {Element} label label\r\n     * @param {number} index index\r\n     * @returns {Element} parent node of the axis\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.findParentNode = function (elementId, label, index) {\r\n        if (document.getElementById(elementId + 'AxisGroup' + index + 'Inside').contains(document.getElementById(label.id))) {\r\n            return document.getElementById(elementId + 'AxisGroup' + index + 'Inside');\r\n        }\r\n        else {\r\n            return document.getElementById(elementId + 'AxisGroup' + index + 'Outside');\r\n        }\r\n    };\r\n    /**\r\n     * Create Zooming Labels Function Called here\r\n     *\r\n     * @param {Chart} chart chart\r\n     * @param {Element} labelElement labelElement\r\n     * @param {Axis} axis axis\r\n     * @param {number} index index\r\n     * @param {Rect} rect rect\r\n     * @returns {void}\r\n     */\r\n    CartesianAxisLayoutPanel.prototype.createZoomingLabel = function (chart, labelElement, axis, index, rect) {\r\n        var parentNode = this.findParentNode(chart.element.id, labelElement, index);\r\n        labelElement.setAttribute('opacity', '0.3');\r\n        var zoomElement = chart.renderer.createGroup({\r\n            id: chart.element.id + 'AxisLabels_Zoom' + index\r\n        });\r\n        zoomElement = createZoomingLabels(chart, axis, zoomElement, index, axis.orientation === 'Vertical', rect);\r\n        parentNode.replaceChild(labelElement, document.getElementById(labelElement.id));\r\n        if (getElement(chart.element.id + 'AxisLabels_Zoom' + index)) {\r\n            parentNode.replaceChild(zoomElement, document.getElementById(zoomElement.id));\r\n        }\r\n        else {\r\n            parentNode.appendChild(zoomElement);\r\n        }\r\n    };\r\n    return CartesianAxisLayoutPanel;\r\n}());\r\nexport { CartesianAxisLayoutPanel };\r\n"]},"metadata":{},"sourceType":"module"}