{"ast":null,"code":"import { arraySize } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'fft';\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'divideScalar', 'exp', 'tau', 'i', 'dotDivide', 'conj', 'pow', 'ceil', 'log2'];\nexport var createFft = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    addScalar,\n    multiplyScalar,\n    divideScalar,\n    exp,\n    tau,\n    i: I,\n    dotDivide,\n    conj,\n    pow,\n    ceil,\n    log2\n  } = _ref;\n  /**\r\n   * Calculate N-dimensional fourier transform\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.fft(arr)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.fft([[1, 0], [1, 0]]) // returns [[{re:2, im:0}, {re:2, im:0}], [{re:0, im:0}, {re:0, im:0}]]\r\n   *\r\n   *\r\n   * See Also:\r\n   *\r\n   *      ifft\r\n   *\r\n   * @param {Array | Matrix} arr    An array or matrix\r\n   * @return {Array | Matrix}       N-dimensional fourier transformation of the array\r\n   */\n\n  return typed(name, {\n    Array: _ndFft,\n    Matrix: function Matrix(matrix) {\n      return matrix.create(_ndFft(matrix.toArray()));\n    }\n  });\n  /**\r\n   * Perform an N-dimensional Fourier transform\r\n   *\r\n   * @param {Array} arr      The array\r\n   * @return {Array}         resulting array\r\n   */\n\n  function _ndFft(arr) {\n    var size = arraySize(arr);\n    if (size.length === 1) return _fft(arr, size[0]); // ndFft along dimension 1,...,N-1 then 1dFft along dimension 0\n\n    return _1dFft(arr.map(slice => _ndFft(slice, size.slice(1))), 0);\n  }\n  /**\r\n   * Perform an 1-dimensional Fourier transform\r\n   *\r\n   * @param {Array} arr      The array\r\n   * @param {number} dim     dimension of the array to perform on\r\n   * @return {Array}         resulting array\r\n   */\n\n\n  function _1dFft(arr, dim) {\n    var size = arraySize(arr);\n    if (dim !== 0) return new Array(size[0]).fill(0).map((_, i) => _1dFft(arr[i], dim - 1));\n    if (size.length === 1) return _fft(arr);\n\n    function _transpose(arr) {\n      // Swap first 2 dimensions\n      var size = arraySize(arr);\n      return new Array(size[1]).fill(0).map((_, j) => new Array(size[0]).fill(0).map((_, i) => arr[i][j]));\n    }\n\n    return _transpose(_1dFft(_transpose(arr), 1));\n  }\n  /**\r\n   * Perform an 1-dimensional non-power-of-2 Fourier transform using Chirp-Z Transform\r\n   *\r\n   * @param {Array} arr      The array\r\n   * @return {Array}         resulting array\r\n   */\n\n\n  function _czt(arr) {\n    var n = arr.length;\n    var w = exp(divideScalar(multiplyScalar(-1, multiplyScalar(I, tau)), n));\n    var chirp = [];\n\n    for (var i = 1 - n; i < n; i++) {\n      chirp.push(pow(w, divideScalar(pow(i, 2), 2)));\n    }\n\n    var N2 = pow(2, ceil(log2(n + n - 1)));\n    var xp = [...new Array(n).fill(0).map((_, i) => multiplyScalar(arr[i], chirp[n - 1 + i])), ...new Array(N2 - n).fill(0)];\n    var ichirp = [...new Array(n + n - 1).fill(0).map((_, i) => divideScalar(1, chirp[i])), ...new Array(N2 - (n + n - 1)).fill(0)];\n\n    var fftXp = _fft(xp);\n\n    var fftIchirp = _fft(ichirp);\n\n    var fftProduct = new Array(N2).fill(0).map((_, i) => multiplyScalar(fftXp[i], fftIchirp[i]));\n    var ifftProduct = dotDivide(conj(_ndFft(conj(fftProduct))), N2);\n    var ret = [];\n\n    for (var _i = n - 1; _i < n + n - 1; _i++) {\n      ret.push(multiplyScalar(ifftProduct[_i], chirp[_i]));\n    }\n\n    return ret;\n  }\n  /**\r\n   * Perform an 1-dimensional Fourier transform\r\n   *\r\n   * @param {Array} arr      The array\r\n   * @return {Array}         resulting array\r\n   */\n\n\n  function _fft(arr) {\n    var len = arr.length;\n    if (len === 1) return [arr[0]];\n\n    if (len % 2 === 0) {\n      var ret = [..._fft(arr.filter((_, i) => i % 2 === 0), len / 2), ..._fft(arr.filter((_, i) => i % 2 === 1), len / 2)];\n\n      for (var k = 0; k < len / 2; k++) {\n        var p = ret[k];\n        var q = multiplyScalar(ret[k + len / 2], exp(multiplyScalar(multiplyScalar(tau, I), divideScalar(-k, len))));\n        ret[k] = addScalar(p, q);\n        ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));\n      }\n\n      return ret;\n    } else {\n      // use chirp-z transform for non-power-of-2 FFT\n      return _czt(arr);\n    } // throw new Error('Can only calculate FFT of power-of-two size')\n\n  }\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/matrix/fft.js"],"names":["arraySize","factory","name","dependencies","createFft","_ref","typed","matrix","addScalar","multiplyScalar","divideScalar","exp","tau","i","I","dotDivide","conj","pow","ceil","log2","Array","_ndFft","Matrix","create","toArray","arr","size","length","_fft","_1dFft","map","slice","dim","fill","_","_transpose","j","_czt","n","w","chirp","push","N2","xp","ichirp","fftXp","fftIchirp","fftProduct","ifftProduct","ret","_i","len","filter","k","p","q"],"mappings":"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","sourcesContent":["import { arraySize } from '../../utils/array.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'fft';\r\nvar dependencies = ['typed', 'matrix', 'addScalar', 'multiplyScalar', 'divideScalar', 'exp', 'tau', 'i', 'dotDivide', 'conj', 'pow', 'ceil', 'log2'];\r\nexport var createFft = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    addScalar,\r\n    multiplyScalar,\r\n    divideScalar,\r\n    exp,\r\n    tau,\r\n    i: I,\r\n    dotDivide,\r\n    conj,\r\n    pow,\r\n    ceil,\r\n    log2\r\n  } = _ref;\r\n  /**\r\n   * Calculate N-dimensional fourier transform\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     math.fft(arr)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.fft([[1, 0], [1, 0]]) // returns [[{re:2, im:0}, {re:2, im:0}], [{re:0, im:0}, {re:0, im:0}]]\r\n   *\r\n   *\r\n   * See Also:\r\n   *\r\n   *      ifft\r\n   *\r\n   * @param {Array | Matrix} arr    An array or matrix\r\n   * @return {Array | Matrix}       N-dimensional fourier transformation of the array\r\n   */\r\n  return typed(name, {\r\n    Array: _ndFft,\r\n    Matrix: function Matrix(matrix) {\r\n      return matrix.create(_ndFft(matrix.toArray()));\r\n    }\r\n  });\r\n\r\n  /**\r\n   * Perform an N-dimensional Fourier transform\r\n   *\r\n   * @param {Array} arr      The array\r\n   * @return {Array}         resulting array\r\n   */\r\n  function _ndFft(arr) {\r\n    var size = arraySize(arr);\r\n    if (size.length === 1) return _fft(arr, size[0]);\r\n    // ndFft along dimension 1,...,N-1 then 1dFft along dimension 0\r\n    return _1dFft(arr.map(slice => _ndFft(slice, size.slice(1))), 0);\r\n  }\r\n\r\n  /**\r\n   * Perform an 1-dimensional Fourier transform\r\n   *\r\n   * @param {Array} arr      The array\r\n   * @param {number} dim     dimension of the array to perform on\r\n   * @return {Array}         resulting array\r\n   */\r\n  function _1dFft(arr, dim) {\r\n    var size = arraySize(arr);\r\n    if (dim !== 0) return new Array(size[0]).fill(0).map((_, i) => _1dFft(arr[i], dim - 1));\r\n    if (size.length === 1) return _fft(arr);\r\n    function _transpose(arr) {\r\n      // Swap first 2 dimensions\r\n      var size = arraySize(arr);\r\n      return new Array(size[1]).fill(0).map((_, j) => new Array(size[0]).fill(0).map((_, i) => arr[i][j]));\r\n    }\r\n    return _transpose(_1dFft(_transpose(arr), 1));\r\n  }\r\n  /**\r\n   * Perform an 1-dimensional non-power-of-2 Fourier transform using Chirp-Z Transform\r\n   *\r\n   * @param {Array} arr      The array\r\n   * @return {Array}         resulting array\r\n   */\r\n  function _czt(arr) {\r\n    var n = arr.length;\r\n    var w = exp(divideScalar(multiplyScalar(-1, multiplyScalar(I, tau)), n));\r\n    var chirp = [];\r\n    for (var i = 1 - n; i < n; i++) {\r\n      chirp.push(pow(w, divideScalar(pow(i, 2), 2)));\r\n    }\r\n    var N2 = pow(2, ceil(log2(n + n - 1)));\r\n    var xp = [...new Array(n).fill(0).map((_, i) => multiplyScalar(arr[i], chirp[n - 1 + i])), ...new Array(N2 - n).fill(0)];\r\n    var ichirp = [...new Array(n + n - 1).fill(0).map((_, i) => divideScalar(1, chirp[i])), ...new Array(N2 - (n + n - 1)).fill(0)];\r\n    var fftXp = _fft(xp);\r\n    var fftIchirp = _fft(ichirp);\r\n    var fftProduct = new Array(N2).fill(0).map((_, i) => multiplyScalar(fftXp[i], fftIchirp[i]));\r\n    var ifftProduct = dotDivide(conj(_ndFft(conj(fftProduct))), N2);\r\n    var ret = [];\r\n    for (var _i = n - 1; _i < n + n - 1; _i++) {\r\n      ret.push(multiplyScalar(ifftProduct[_i], chirp[_i]));\r\n    }\r\n    return ret;\r\n  }\r\n  /**\r\n   * Perform an 1-dimensional Fourier transform\r\n   *\r\n   * @param {Array} arr      The array\r\n   * @return {Array}         resulting array\r\n   */\r\n  function _fft(arr) {\r\n    var len = arr.length;\r\n    if (len === 1) return [arr[0]];\r\n    if (len % 2 === 0) {\r\n      var ret = [..._fft(arr.filter((_, i) => i % 2 === 0), len / 2), ..._fft(arr.filter((_, i) => i % 2 === 1), len / 2)];\r\n      for (var k = 0; k < len / 2; k++) {\r\n        var p = ret[k];\r\n        var q = multiplyScalar(ret[k + len / 2], exp(multiplyScalar(multiplyScalar(tau, I), divideScalar(-k, len))));\r\n        ret[k] = addScalar(p, q);\r\n        ret[k + len / 2] = addScalar(p, multiplyScalar(-1, q));\r\n      }\r\n      return ret;\r\n    } else {\r\n      // use chirp-z transform for non-power-of-2 FFT\r\n      return _czt(arr);\r\n    }\r\n    // throw new Error('Can only calculate FFT of power-of-two size')\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}