{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { isNumber } from '../../utils/is.js';\nvar name = 'stirlingS2';\nvar dependencies = ['typed', 'addScalar', 'subtract', 'multiplyScalar', 'divideScalar', 'pow', 'factorial', 'combinations', 'isNegative', 'isInteger', 'number', '?bignumber', 'larger'];\nexport var createStirlingS2 = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    addScalar,\n    subtract,\n    multiplyScalar,\n    divideScalar,\n    pow,\n    factorial,\n    combinations,\n    isNegative,\n    isInteger,\n    number,\n    bignumber,\n    larger\n  } = _ref;\n  var smallCache = [];\n  var bigCache = [];\n  /**\r\n   * The Stirling numbers of the second kind, counts the number of ways to partition\r\n   * a set of n labelled objects into k nonempty unlabelled subsets.\r\n   * stirlingS2 only takes integer arguments.\r\n   * The following condition must be enforced: k <= n.\r\n   *\r\n   *  If n = k or k = 1 <= n, then s(n,k) = 1\r\n   *  If k = 0 < n, then s(n,k) = 0\r\n   *\r\n   * Note that if either n or k is supplied as a BigNumber, the result will be\r\n   * as well.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *   math.stirlingS2(n, k)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.stirlingS2(5, 3) //returns 25\r\n   *\r\n   * See also:\r\n   *\r\n   *    bellNumbers\r\n   *\r\n   * @param {Number | BigNumber} n    Total number of objects in the set\r\n   * @param {Number | BigNumber} k    Number of objects in the subset\r\n   * @return {Number | BigNumber}     S(n,k)\r\n   */\n\n  return typed(name, {\n    'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(n, k) {\n      if (!isInteger(n) || isNegative(n) || !isInteger(k) || isNegative(k)) {\n        throw new TypeError('Non-negative integer value expected in function stirlingS2');\n      } else if (larger(k, n)) {\n        throw new TypeError('k must be less than or equal to n in function stirlingS2');\n      }\n\n      var big = !(isNumber(n) && isNumber(k));\n      var cache = big ? bigCache : smallCache;\n      var make = big ? bignumber : number;\n      var nn = number(n);\n      var nk = number(k);\n      /* See if we already have the value: */\n\n      if (cache[nn] && cache[nn].length > nk) {\n        return cache[nn][nk];\n      }\n      /* Fill the cache */\n\n\n      for (var m = 0; m <= nn; ++m) {\n        if (!cache[m]) {\n          cache[m] = [m === 0 ? make(1) : make(0)];\n        }\n\n        if (m === 0) continue;\n        var row = cache[m];\n        var prev = cache[m - 1];\n\n        for (var i = row.length; i <= m && i <= nk; ++i) {\n          if (i === m) {\n            row[i] = 1;\n          } else {\n            row[i] = addScalar(multiplyScalar(make(i), prev[i]), prev[i - 1]);\n          }\n        }\n      }\n\n      return cache[nn][nk];\n    }\n  });\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js"],"names":["factory","isNumber","name","dependencies","createStirlingS2","_ref","typed","addScalar","subtract","multiplyScalar","divideScalar","pow","factorial","combinations","isNegative","isInteger","number","bignumber","larger","smallCache","bigCache","numberBigNumberNumberBigNumber","n","k","TypeError","big","cache","make","nn","nk","length","m","row","prev","i"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory.js';\r\nimport { isNumber } from '../../utils/is.js';\r\nvar name = 'stirlingS2';\r\nvar dependencies = ['typed', 'addScalar', 'subtract', 'multiplyScalar', 'divideScalar', 'pow', 'factorial', 'combinations', 'isNegative', 'isInteger', 'number', '?bignumber', 'larger'];\r\nexport var createStirlingS2 = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    addScalar,\r\n    subtract,\r\n    multiplyScalar,\r\n    divideScalar,\r\n    pow,\r\n    factorial,\r\n    combinations,\r\n    isNegative,\r\n    isInteger,\r\n    number,\r\n    bignumber,\r\n    larger\r\n  } = _ref;\r\n  var smallCache = [];\r\n  var bigCache = [];\r\n  /**\r\n   * The Stirling numbers of the second kind, counts the number of ways to partition\r\n   * a set of n labelled objects into k nonempty unlabelled subsets.\r\n   * stirlingS2 only takes integer arguments.\r\n   * The following condition must be enforced: k <= n.\r\n   *\r\n   *  If n = k or k = 1 <= n, then s(n,k) = 1\r\n   *  If k = 0 < n, then s(n,k) = 0\r\n   *\r\n   * Note that if either n or k is supplied as a BigNumber, the result will be\r\n   * as well.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *   math.stirlingS2(n, k)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.stirlingS2(5, 3) //returns 25\r\n   *\r\n   * See also:\r\n   *\r\n   *    bellNumbers\r\n   *\r\n   * @param {Number | BigNumber} n    Total number of objects in the set\r\n   * @param {Number | BigNumber} k    Number of objects in the subset\r\n   * @return {Number | BigNumber}     S(n,k)\r\n   */\r\n  return typed(name, {\r\n    'number | BigNumber, number | BigNumber': function numberBigNumberNumberBigNumber(n, k) {\r\n      if (!isInteger(n) || isNegative(n) || !isInteger(k) || isNegative(k)) {\r\n        throw new TypeError('Non-negative integer value expected in function stirlingS2');\r\n      } else if (larger(k, n)) {\r\n        throw new TypeError('k must be less than or equal to n in function stirlingS2');\r\n      }\r\n      var big = !(isNumber(n) && isNumber(k));\r\n      var cache = big ? bigCache : smallCache;\r\n      var make = big ? bignumber : number;\r\n      var nn = number(n);\r\n      var nk = number(k);\r\n      /* See if we already have the value: */\r\n      if (cache[nn] && cache[nn].length > nk) {\r\n        return cache[nn][nk];\r\n      }\r\n      /* Fill the cache */\r\n      for (var m = 0; m <= nn; ++m) {\r\n        if (!cache[m]) {\r\n          cache[m] = [m === 0 ? make(1) : make(0)];\r\n        }\r\n        if (m === 0) continue;\r\n        var row = cache[m];\r\n        var prev = cache[m - 1];\r\n        for (var i = row.length; i <= m && i <= nk; ++i) {\r\n          if (i === m) {\r\n            row[i] = 1;\r\n          } else {\r\n            row[i] = addScalar(multiplyScalar(make(i), prev[i]), prev[i - 1]);\r\n          }\r\n        }\r\n      }\r\n      return cache[nn][nk];\r\n    }\r\n  });\r\n});"]},"metadata":{},"sourceType":"module"}