{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nvar name = 'nthRoots';\nvar dependencies = ['config', 'typed', 'divideScalar', 'Complex'];\nexport var createNthRoots = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    divideScalar,\n    Complex\n  } = _ref;\n  /**\r\n   * Each function here returns a real multiple of i as a Complex value.\r\n   * @param  {number} val\r\n   * @return {Complex} val, i*val, -val or -i*val for index 0, 1, 2, 3\r\n   */\n  // This is used to fix float artifacts for zero-valued components.\n\n  var _calculateExactResult = [function realPos(val) {\n    return new Complex(val, 0);\n  }, function imagPos(val) {\n    return new Complex(0, val);\n  }, function realNeg(val) {\n    return new Complex(-val, 0);\n  }, function imagNeg(val) {\n    return new Complex(0, -val);\n  }];\n  /**\r\n   * Calculate the nth root of a Complex Number a using De Movire's Theorem.\r\n   * @param  {Complex} a\r\n   * @param  {number} root\r\n   * @return {Array} array of n Complex Roots\r\n   */\n\n  function _nthComplexRoots(a, root) {\n    if (root < 0) throw new Error('Root must be greater than zero');\n    if (root === 0) throw new Error('Root must be non-zero');\n    if (root % 1 !== 0) throw new Error('Root must be an integer');\n    if (a === 0 || a.abs() === 0) return [new Complex(0, 0)];\n    var aIsNumeric = typeof a === 'number';\n    var offset; // determine the offset (argument of a)/(pi/2)\n\n    if (aIsNumeric || a.re === 0 || a.im === 0) {\n      if (aIsNumeric) {\n        offset = 2 * +(a < 0); // numeric value on the real axis\n      } else if (a.im === 0) {\n        offset = 2 * +(a.re < 0); // complex value on the real axis\n      } else {\n        offset = 2 * +(a.im < 0) + 1; // complex value on the imaginary axis\n      }\n    }\n\n    var arg = a.arg();\n    var abs = a.abs();\n    var roots = [];\n    var r = Math.pow(abs, 1 / root);\n\n    for (var k = 0; k < root; k++) {\n      var halfPiFactor = (offset + 4 * k) / root;\n      /**\r\n       * If (offset + 4*k)/root is an integral multiple of pi/2\r\n       * then we can produce a more exact result.\r\n       */\n\n      if (halfPiFactor === Math.round(halfPiFactor)) {\n        roots.push(_calculateExactResult[halfPiFactor % 4](r));\n        continue;\n      }\n\n      roots.push(new Complex({\n        r,\n        phi: (arg + 2 * Math.PI * k) / root\n      }));\n    }\n\n    return roots;\n  }\n  /**\r\n   * Calculate the nth roots of a value.\r\n   * An nth root of a positive real number A,\r\n   * is a positive real solution of the equation \"x^root = A\".\r\n   * This function returns an array of complex values.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.nthRoots(x)\r\n   *    math.nthRoots(x, root)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.nthRoots(1)\r\n   *    // returns [\r\n   *    //   {re: 1, im: 0},\r\n   *    //   {re: -1, im: 0}\r\n   *    // ]\r\n   *    math.nthRoots(1, 3)\r\n   *    // returns [\r\n   *    //   { re: 1, im: 0 },\r\n   *    //   { re: -0.4999999999999998, im: 0.8660254037844387 },\r\n   *    //   { re: -0.5000000000000004, im: -0.8660254037844385 }\r\n   *    // ]\r\n   *\r\n   * See also:\r\n   *\r\n   *    nthRoot, pow, sqrt\r\n   *\r\n   * @param {number | BigNumber | Fraction | Complex} x Number to be rounded\r\n   * @return {number | BigNumber | Fraction | Complex}            Rounded value\r\n   */\n\n\n  return typed(name, {\n    Complex: function Complex(x) {\n      return _nthComplexRoots(x, 2);\n    },\n    'Complex, number': _nthComplexRoots\n  });\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js"],"names":["factory","name","dependencies","createNthRoots","_ref","typed","config","divideScalar","Complex","_calculateExactResult","realPos","val","imagPos","realNeg","imagNeg","_nthComplexRoots","a","root","Error","abs","aIsNumeric","offset","re","im","arg","roots","r","Math","pow","k","halfPiFactor","round","push","phi","PI","x"],"mappings":"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","sourcesContent":["import { factory } from '../../utils/factory.js';\r\nvar name = 'nthRoots';\r\nvar dependencies = ['config', 'typed', 'divideScalar', 'Complex'];\r\nexport var createNthRoots = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    config,\r\n    divideScalar,\r\n    Complex\r\n  } = _ref;\r\n  /**\r\n   * Each function here returns a real multiple of i as a Complex value.\r\n   * @param  {number} val\r\n   * @return {Complex} val, i*val, -val or -i*val for index 0, 1, 2, 3\r\n   */\r\n  // This is used to fix float artifacts for zero-valued components.\r\n  var _calculateExactResult = [function realPos(val) {\r\n    return new Complex(val, 0);\r\n  }, function imagPos(val) {\r\n    return new Complex(0, val);\r\n  }, function realNeg(val) {\r\n    return new Complex(-val, 0);\r\n  }, function imagNeg(val) {\r\n    return new Complex(0, -val);\r\n  }];\r\n\r\n  /**\r\n   * Calculate the nth root of a Complex Number a using De Movire's Theorem.\r\n   * @param  {Complex} a\r\n   * @param  {number} root\r\n   * @return {Array} array of n Complex Roots\r\n   */\r\n  function _nthComplexRoots(a, root) {\r\n    if (root < 0) throw new Error('Root must be greater than zero');\r\n    if (root === 0) throw new Error('Root must be non-zero');\r\n    if (root % 1 !== 0) throw new Error('Root must be an integer');\r\n    if (a === 0 || a.abs() === 0) return [new Complex(0, 0)];\r\n    var aIsNumeric = typeof a === 'number';\r\n    var offset;\r\n    // determine the offset (argument of a)/(pi/2)\r\n    if (aIsNumeric || a.re === 0 || a.im === 0) {\r\n      if (aIsNumeric) {\r\n        offset = 2 * +(a < 0); // numeric value on the real axis\r\n      } else if (a.im === 0) {\r\n        offset = 2 * +(a.re < 0); // complex value on the real axis\r\n      } else {\r\n        offset = 2 * +(a.im < 0) + 1; // complex value on the imaginary axis\r\n      }\r\n    }\r\n\r\n    var arg = a.arg();\r\n    var abs = a.abs();\r\n    var roots = [];\r\n    var r = Math.pow(abs, 1 / root);\r\n    for (var k = 0; k < root; k++) {\r\n      var halfPiFactor = (offset + 4 * k) / root;\r\n      /**\r\n       * If (offset + 4*k)/root is an integral multiple of pi/2\r\n       * then we can produce a more exact result.\r\n       */\r\n      if (halfPiFactor === Math.round(halfPiFactor)) {\r\n        roots.push(_calculateExactResult[halfPiFactor % 4](r));\r\n        continue;\r\n      }\r\n      roots.push(new Complex({\r\n        r,\r\n        phi: (arg + 2 * Math.PI * k) / root\r\n      }));\r\n    }\r\n    return roots;\r\n  }\r\n\r\n  /**\r\n   * Calculate the nth roots of a value.\r\n   * An nth root of a positive real number A,\r\n   * is a positive real solution of the equation \"x^root = A\".\r\n   * This function returns an array of complex values.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *    math.nthRoots(x)\r\n   *    math.nthRoots(x, root)\r\n   *\r\n   * Examples:\r\n   *\r\n   *    math.nthRoots(1)\r\n   *    // returns [\r\n   *    //   {re: 1, im: 0},\r\n   *    //   {re: -1, im: 0}\r\n   *    // ]\r\n   *    math.nthRoots(1, 3)\r\n   *    // returns [\r\n   *    //   { re: 1, im: 0 },\r\n   *    //   { re: -0.4999999999999998, im: 0.8660254037844387 },\r\n   *    //   { re: -0.5000000000000004, im: -0.8660254037844385 }\r\n   *    // ]\r\n   *\r\n   * See also:\r\n   *\r\n   *    nthRoot, pow, sqrt\r\n   *\r\n   * @param {number | BigNumber | Fraction | Complex} x Number to be rounded\r\n   * @return {number | BigNumber | Fraction | Complex}            Rounded value\r\n   */\r\n  return typed(name, {\r\n    Complex: function Complex(x) {\r\n      return _nthComplexRoots(x, 2);\r\n    },\r\n    'Complex, number': _nthComplexRoots\r\n  });\r\n});"]},"metadata":{},"sourceType":"module"}