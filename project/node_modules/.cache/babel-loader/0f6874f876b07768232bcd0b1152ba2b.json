{"ast":null,"code":"import Complex from 'complex.js';\nimport { format } from '../../utils/number.js';\nimport { isNumber, isUnit } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'Complex';\nvar dependencies = [];\nexport var createComplexClass = /* #__PURE__ */factory(name, dependencies, () => {\n  /**\r\n   * Attach type information\r\n   */\n  Object.defineProperty(Complex, 'name', {\n    value: 'Complex'\n  });\n  Complex.prototype.constructor = Complex;\n  Complex.prototype.type = 'Complex';\n  Complex.prototype.isComplex = true;\n  /**\r\n   * Get a JSON representation of the complex number\r\n   * @returns {Object} Returns a JSON object structured as:\r\n   *                   `{\"mathjs\": \"Complex\", \"re\": 2, \"im\": 3}`\r\n   */\n\n  Complex.prototype.toJSON = function () {\n    return {\n      mathjs: 'Complex',\n      re: this.re,\n      im: this.im\n    };\n  };\n  /*\r\n   * Return the value of the complex number in polar notation\r\n   * The angle phi will be set in the interval of [-pi, pi].\r\n   * @return {{r: number, phi: number}} Returns and object with properties r and phi.\r\n   */\n\n\n  Complex.prototype.toPolar = function () {\n    return {\n      r: this.abs(),\n      phi: this.arg()\n    };\n  };\n  /**\r\n   * Get a string representation of the complex number,\r\n   * with optional formatting options.\r\n   * @param {Object | number | Function} [options]  Formatting options. See\r\n   *                                                lib/utils/number:format for a\r\n   *                                                description of the available\r\n   *                                                options.\r\n   * @return {string} str\r\n   */\n\n\n  Complex.prototype.format = function (options) {\n    var str = '';\n    var im = this.im;\n    var re = this.re;\n    var strRe = format(this.re, options);\n    var strIm = format(this.im, options); // round either re or im when smaller than the configured precision\n\n    var precision = isNumber(options) ? options : options ? options.precision : null;\n\n    if (precision !== null) {\n      var epsilon = Math.pow(10, -precision);\n\n      if (Math.abs(re / im) < epsilon) {\n        re = 0;\n      }\n\n      if (Math.abs(im / re) < epsilon) {\n        im = 0;\n      }\n    }\n\n    if (im === 0) {\n      // real value\n      str = strRe;\n    } else if (re === 0) {\n      // purely complex value\n      if (im === 1) {\n        str = 'i';\n      } else if (im === -1) {\n        str = '-i';\n      } else {\n        str = strIm + 'i';\n      }\n    } else {\n      // complex value\n      if (im < 0) {\n        if (im === -1) {\n          str = strRe + ' - i';\n        } else {\n          str = strRe + ' - ' + strIm.substring(1) + 'i';\n        }\n      } else {\n        if (im === 1) {\n          str = strRe + ' + i';\n        } else {\n          str = strRe + ' + ' + strIm + 'i';\n        }\n      }\n    }\n\n    return str;\n  };\n  /**\r\n   * Create a complex number from polar coordinates\r\n   *\r\n   * Usage:\r\n   *\r\n   *     Complex.fromPolar(r: number, phi: number) : Complex\r\n   *     Complex.fromPolar({r: number, phi: number}) : Complex\r\n   *\r\n   * @param {*} args...\r\n   * @return {Complex}\r\n   */\n\n\n  Complex.fromPolar = function (args) {\n    switch (arguments.length) {\n      case 1:\n        {\n          var arg = arguments[0];\n\n          if (typeof arg === 'object') {\n            return Complex(arg);\n          } else {\n            throw new TypeError('Input has to be an object with r and phi keys.');\n          }\n        }\n\n      case 2:\n        {\n          var r = arguments[0];\n          var phi = arguments[1];\n\n          if (isNumber(r)) {\n            if (isUnit(phi) && phi.hasBase('ANGLE')) {\n              // convert unit to a number in radians\n              phi = phi.toNumber('rad');\n            }\n\n            if (isNumber(phi)) {\n              return new Complex({\n                r,\n                phi\n              });\n            }\n\n            throw new TypeError('Phi is not a number nor an angle unit.');\n          } else {\n            throw new TypeError('Radius r is not a number.');\n          }\n        }\n\n      default:\n        throw new SyntaxError('Wrong number of arguments in function fromPolar');\n    }\n  };\n\n  Complex.prototype.valueOf = Complex.prototype.toString;\n  /**\r\n   * Create a Complex number from a JSON object\r\n   * @param {Object} json  A JSON Object structured as\r\n   *                       {\"mathjs\": \"Complex\", \"re\": 2, \"im\": 3}\r\n   *                       All properties are optional, default values\r\n   *                       for `re` and `im` are 0.\r\n   * @return {Complex} Returns a new Complex number\r\n   */\n\n  Complex.fromJSON = function (json) {\n    return new Complex(json);\n  };\n  /**\r\n   * Compare two complex numbers, `a` and `b`:\r\n   *\r\n   * - Returns 1 when the real part of `a` is larger than the real part of `b`\r\n   * - Returns -1 when the real part of `a` is smaller than the real part of `b`\r\n   * - Returns 1 when the real parts are equal\r\n   *   and the imaginary part of `a` is larger than the imaginary part of `b`\r\n   * - Returns -1 when the real parts are equal\r\n   *   and the imaginary part of `a` is smaller than the imaginary part of `b`\r\n   * - Returns 0 when both real and imaginary parts are equal.\r\n   *\r\n   * @params {Complex} a\r\n   * @params {Complex} b\r\n   * @returns {number} Returns the comparison result: -1, 0, or 1\r\n   */\n\n\n  Complex.compare = function (a, b) {\n    if (a.re > b.re) {\n      return 1;\n    }\n\n    if (a.re < b.re) {\n      return -1;\n    }\n\n    if (a.im > b.im) {\n      return 1;\n    }\n\n    if (a.im < b.im) {\n      return -1;\n    }\n\n    return 0;\n  };\n\n  return Complex;\n}, {\n  isClass: true\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/type/complex/Complex.js"],"names":["Complex","format","isNumber","isUnit","factory","name","dependencies","createComplexClass","Object","defineProperty","value","prototype","constructor","type","isComplex","toJSON","mathjs","re","im","toPolar","r","abs","phi","arg","options","str","strRe","strIm","precision","epsilon","Math","pow","substring","fromPolar","args","arguments","length","TypeError","hasBase","toNumber","SyntaxError","valueOf","toString","fromJSON","json","compare","a","b","isClass"],"mappings":"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","sourcesContent":["import Complex from 'complex.js';\r\nimport { format } from '../../utils/number.js';\r\nimport { isNumber, isUnit } from '../../utils/is.js';\r\nimport { factory } from '../../utils/factory.js';\r\nvar name = 'Complex';\r\nvar dependencies = [];\r\nexport var createComplexClass = /* #__PURE__ */factory(name, dependencies, () => {\r\n  /**\r\n   * Attach type information\r\n   */\r\n  Object.defineProperty(Complex, 'name', {\r\n    value: 'Complex'\r\n  });\r\n  Complex.prototype.constructor = Complex;\r\n  Complex.prototype.type = 'Complex';\r\n  Complex.prototype.isComplex = true;\r\n\r\n  /**\r\n   * Get a JSON representation of the complex number\r\n   * @returns {Object} Returns a JSON object structured as:\r\n   *                   `{\"mathjs\": \"Complex\", \"re\": 2, \"im\": 3}`\r\n   */\r\n  Complex.prototype.toJSON = function () {\r\n    return {\r\n      mathjs: 'Complex',\r\n      re: this.re,\r\n      im: this.im\r\n    };\r\n  };\r\n\r\n  /*\r\n   * Return the value of the complex number in polar notation\r\n   * The angle phi will be set in the interval of [-pi, pi].\r\n   * @return {{r: number, phi: number}} Returns and object with properties r and phi.\r\n   */\r\n  Complex.prototype.toPolar = function () {\r\n    return {\r\n      r: this.abs(),\r\n      phi: this.arg()\r\n    };\r\n  };\r\n\r\n  /**\r\n   * Get a string representation of the complex number,\r\n   * with optional formatting options.\r\n   * @param {Object | number | Function} [options]  Formatting options. See\r\n   *                                                lib/utils/number:format for a\r\n   *                                                description of the available\r\n   *                                                options.\r\n   * @return {string} str\r\n   */\r\n  Complex.prototype.format = function (options) {\r\n    var str = '';\r\n    var im = this.im;\r\n    var re = this.re;\r\n    var strRe = format(this.re, options);\r\n    var strIm = format(this.im, options);\r\n\r\n    // round either re or im when smaller than the configured precision\r\n    var precision = isNumber(options) ? options : options ? options.precision : null;\r\n    if (precision !== null) {\r\n      var epsilon = Math.pow(10, -precision);\r\n      if (Math.abs(re / im) < epsilon) {\r\n        re = 0;\r\n      }\r\n      if (Math.abs(im / re) < epsilon) {\r\n        im = 0;\r\n      }\r\n    }\r\n    if (im === 0) {\r\n      // real value\r\n      str = strRe;\r\n    } else if (re === 0) {\r\n      // purely complex value\r\n      if (im === 1) {\r\n        str = 'i';\r\n      } else if (im === -1) {\r\n        str = '-i';\r\n      } else {\r\n        str = strIm + 'i';\r\n      }\r\n    } else {\r\n      // complex value\r\n      if (im < 0) {\r\n        if (im === -1) {\r\n          str = strRe + ' - i';\r\n        } else {\r\n          str = strRe + ' - ' + strIm.substring(1) + 'i';\r\n        }\r\n      } else {\r\n        if (im === 1) {\r\n          str = strRe + ' + i';\r\n        } else {\r\n          str = strRe + ' + ' + strIm + 'i';\r\n        }\r\n      }\r\n    }\r\n    return str;\r\n  };\r\n\r\n  /**\r\n   * Create a complex number from polar coordinates\r\n   *\r\n   * Usage:\r\n   *\r\n   *     Complex.fromPolar(r: number, phi: number) : Complex\r\n   *     Complex.fromPolar({r: number, phi: number}) : Complex\r\n   *\r\n   * @param {*} args...\r\n   * @return {Complex}\r\n   */\r\n  Complex.fromPolar = function (args) {\r\n    switch (arguments.length) {\r\n      case 1:\r\n        {\r\n          var arg = arguments[0];\r\n          if (typeof arg === 'object') {\r\n            return Complex(arg);\r\n          } else {\r\n            throw new TypeError('Input has to be an object with r and phi keys.');\r\n          }\r\n        }\r\n      case 2:\r\n        {\r\n          var r = arguments[0];\r\n          var phi = arguments[1];\r\n          if (isNumber(r)) {\r\n            if (isUnit(phi) && phi.hasBase('ANGLE')) {\r\n              // convert unit to a number in radians\r\n              phi = phi.toNumber('rad');\r\n            }\r\n            if (isNumber(phi)) {\r\n              return new Complex({\r\n                r,\r\n                phi\r\n              });\r\n            }\r\n            throw new TypeError('Phi is not a number nor an angle unit.');\r\n          } else {\r\n            throw new TypeError('Radius r is not a number.');\r\n          }\r\n        }\r\n      default:\r\n        throw new SyntaxError('Wrong number of arguments in function fromPolar');\r\n    }\r\n  };\r\n  Complex.prototype.valueOf = Complex.prototype.toString;\r\n\r\n  /**\r\n   * Create a Complex number from a JSON object\r\n   * @param {Object} json  A JSON Object structured as\r\n   *                       {\"mathjs\": \"Complex\", \"re\": 2, \"im\": 3}\r\n   *                       All properties are optional, default values\r\n   *                       for `re` and `im` are 0.\r\n   * @return {Complex} Returns a new Complex number\r\n   */\r\n  Complex.fromJSON = function (json) {\r\n    return new Complex(json);\r\n  };\r\n\r\n  /**\r\n   * Compare two complex numbers, `a` and `b`:\r\n   *\r\n   * - Returns 1 when the real part of `a` is larger than the real part of `b`\r\n   * - Returns -1 when the real part of `a` is smaller than the real part of `b`\r\n   * - Returns 1 when the real parts are equal\r\n   *   and the imaginary part of `a` is larger than the imaginary part of `b`\r\n   * - Returns -1 when the real parts are equal\r\n   *   and the imaginary part of `a` is smaller than the imaginary part of `b`\r\n   * - Returns 0 when both real and imaginary parts are equal.\r\n   *\r\n   * @params {Complex} a\r\n   * @params {Complex} b\r\n   * @returns {number} Returns the comparison result: -1, 0, or 1\r\n   */\r\n  Complex.compare = function (a, b) {\r\n    if (a.re > b.re) {\r\n      return 1;\r\n    }\r\n    if (a.re < b.re) {\r\n      return -1;\r\n    }\r\n    if (a.im > b.im) {\r\n      return 1;\r\n    }\r\n    if (a.im < b.im) {\r\n      return -1;\r\n    }\r\n    return 0;\r\n  };\r\n  return Complex;\r\n}, {\r\n  isClass: true\r\n});"]},"metadata":{},"sourceType":"module"}