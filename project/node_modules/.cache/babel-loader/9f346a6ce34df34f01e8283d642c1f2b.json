{"ast":null,"code":"import { isFraction, isMatrix, isNode, isArrayNode, isConstantNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\nimport { factory } from '../../utils/factory.js';\nimport { createUtil } from './simplify/util.js';\nimport { noBignumber, noFraction } from '../../utils/noop.js';\nvar name = 'simplifyConstant';\nvar dependencies = ['typed', 'config', 'mathWithTransform', 'matrix', '?fraction', '?bignumber', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode'];\nexport var createSimplifyConstant = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    config,\n    mathWithTransform,\n    matrix,\n    fraction,\n    bignumber,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    SymbolNode\n  } = _ref;\n  var {\n    isCommutative,\n    isAssociative,\n    allChildren,\n    createMakeNodeFunction\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n  /**\r\n   * simplifyConstant() takes a mathjs expression (either a Node representing\r\n   * a parse tree or a string which it parses to produce a node), and replaces\r\n   * any subexpression of it consisting entirely of constants with the computed\r\n   * value of that subexpression.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     simplifyConstant(expr)\r\n   *     simplifyConstant(expr, options)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.simplifyConstant('x + 4*3/6')  // Node \"x + 2\"\r\n   *     math.simplifyConstant('z cos(0)')   // Node \"z 1\"\r\n   *     math.simplifyConstant('(5.2 + 1.08)t', {exactFractions: false})  // Node \"6.28 t\"\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplify, simplifyCore, resolve, derivative\r\n   *\r\n   * @param {Node | string} node\r\n   *     The expression to be simplified\r\n   * @param {Object} options\r\n   *     Simplification options, as per simplify()\r\n   * @return {Node} Returns expression with constant subexpressions evaluated\r\n   */\n\n  var simplifyConstant = typed('simplifyConstant', {\n    Node: node => _ensureNode(foldFraction(node, {})),\n    'Node, Object': function NodeObject(expr, options) {\n      return _ensureNode(foldFraction(expr, options));\n    }\n  });\n\n  function _removeFractions(thing) {\n    if (isFraction(thing)) {\n      return thing.valueOf();\n    }\n\n    if (thing instanceof Array) {\n      return thing.map(_removeFractions);\n    }\n\n    if (isMatrix(thing)) {\n      return matrix(_removeFractions(thing.valueOf()));\n    }\n\n    return thing;\n  }\n\n  function _eval(fnname, args, options) {\n    try {\n      return mathWithTransform[fnname].apply(null, args);\n    } catch (ignore) {\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\n      args = args.map(_removeFractions);\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\n    }\n  }\n\n  var _toNode = typed({\n    Fraction: _fractionToNode,\n    number: function number(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n);\n    },\n    BigNumber: function BigNumber(n) {\n      if (n < 0) {\n        return unaryMinusNode(new ConstantNode(-n));\n      }\n\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\n    },\n    Complex: function Complex(s) {\n      throw new Error('Cannot convert Complex number to Node');\n    },\n    string: function string(s) {\n      return new ConstantNode(s);\n    },\n    Matrix: function Matrix(m) {\n      return new ArrayNode(m.valueOf().map(e => _toNode(e)));\n    }\n  });\n\n  function _ensureNode(thing) {\n    if (isNode(thing)) {\n      return thing;\n    }\n\n    return _toNode(thing);\n  } // convert a number to a fraction only if it can be expressed exactly,\n  // and when both numerator and denominator are small enough\n\n\n  function _exactFraction(n, options) {\n    var exactFractions = options && options.exactFractions !== false;\n\n    if (exactFractions && isFinite(n) && fraction) {\n      var f = fraction(n);\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\n\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\n        return f;\n      }\n    }\n\n    return n;\n  } // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\n  // BigNumbers are left alone\n\n\n  var _toNumber = typed({\n    'string, Object': function stringObject(s, options) {\n      if (config.number === 'BigNumber') {\n        if (bignumber === undefined) {\n          noBignumber();\n        }\n\n        return bignumber(s);\n      } else if (config.number === 'Fraction') {\n        if (fraction === undefined) {\n          noFraction();\n        }\n\n        return fraction(s);\n      } else {\n        var n = parseFloat(s);\n        return _exactFraction(n, options);\n      }\n    },\n    'Fraction, Object': function FractionObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'BigNumber, Object': function BigNumberObject(s, options) {\n      return s;\n    },\n    // we don't need options here\n    'number, Object': function numberObject(s, options) {\n      return _exactFraction(s, options);\n    },\n    'Complex, Object': function ComplexObject(s, options) {\n      if (s.im !== 0) {\n        return s;\n      }\n\n      return _exactFraction(s.re, options);\n    },\n    'Matrix, Object': function MatrixObject(s, options) {\n      return matrix(_exactFraction(s.valueOf()));\n    },\n    'Array, Object': function ArrayObject(s, options) {\n      return s.map(_exactFraction);\n    }\n  });\n\n  function unaryMinusNode(n) {\n    return new OperatorNode('-', 'unaryMinus', [n]);\n  }\n\n  function _fractionToNode(f) {\n    var n;\n    var vn = f.s * f.n;\n\n    if (vn < 0) {\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\n    } else {\n      n = new ConstantNode(vn);\n    }\n\n    if (f.d === 1) {\n      return n;\n    }\n\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\n  }\n  /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */\n\n\n  function _foldAccessor(obj, index, options) {\n    if (!isIndexNode(index)) {\n      // don't know what to do with that...\n      return new AccessorNode(_ensureNode(obj), _ensureNode(index));\n    }\n\n    if (isArrayNode(obj) || isMatrix(obj)) {\n      var remainingDims = Array.from(index.dimensions);\n      /* We will resolve constant indices one at a time, looking\r\n       * just in the first or second dimensions because (a) arrays\r\n       * of more than two dimensions are likely rare, and (b) pulling\r\n       * out the third or higher dimension would be pretty intricate.\r\n       * The price is that we miss simplifying [..3d array][x,y,1]\r\n       */\n\n      while (remainingDims.length > 0) {\n        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {\n          var first = _toNumber(remainingDims.shift().value, options);\n\n          if (isArrayNode(obj)) {\n            obj = obj.items[first - 1];\n          } else {\n            // matrix\n            obj = obj.valueOf()[first - 1];\n\n            if (obj instanceof Array) {\n              obj = matrix(obj);\n            }\n          }\n        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {\n          var second = _toNumber(remainingDims[1].value, options);\n\n          var tryItems = [];\n          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();\n\n          for (var item of fromItems) {\n            if (isArrayNode(item)) {\n              tryItems.push(item.items[second - 1]);\n            } else if (isMatrix(obj)) {\n              tryItems.push(item[second - 1]);\n            } else {\n              break;\n            }\n          }\n\n          if (tryItems.length === fromItems.length) {\n            if (isArrayNode(obj)) {\n              obj = new ArrayNode(tryItems);\n            } else {\n              // matrix\n              obj = matrix(tryItems);\n            }\n\n            remainingDims.splice(1, 1);\n          } else {\n            // extracting slice along 2nd dimension failed, give up\n            break;\n          }\n        } else {\n          // neither 1st or 2nd dimension is constant, give up\n          break;\n        }\n      }\n\n      if (remainingDims.length === index.dimensions.length) {\n        /* No successful constant indexing */\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n\n      if (remainingDims.length > 0) {\n        /* Indexed some but not all dimensions */\n        index = new IndexNode(remainingDims);\n        return new AccessorNode(_ensureNode(obj), index);\n      }\n      /* All dimensions were constant, access completely resolved */\n\n\n      return obj;\n    }\n\n    if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {\n      var key = index.dimensions[0].value;\n\n      if (key in obj.properties) {\n        return obj.properties[key];\n      }\n\n      return new ConstantNode(); // undefined\n    }\n    /* Don't know how to index this sort of obj, at least not with this index */\n\n\n    return new AccessorNode(_ensureNode(obj), index);\n  }\n  /*\r\n   * Create a binary tree from a list of Fractions and Nodes.\r\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\r\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\r\n   * @param args - list of Fractions and Nodes\r\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\r\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\r\n   * if args.length is 1, returns args[0]\r\n   * @return - Either a Node representing a binary expression or Fraction\r\n   */\n\n\n  function foldOp(fn, args, makeNode, options) {\n    var first = args.shift(); // In the following reduction, sofar always has one of the three following\n    // forms: [NODE], [CONSTANT], or [NODE, CONSTANT]\n\n    var reduction = args.reduce((sofar, next) => {\n      if (!isNode(next)) {\n        var last = sofar.pop();\n\n        if (isNode(last)) {\n          return [last, next];\n        } // Two constants in a row, try to fold them into one\n\n\n        try {\n          sofar.push(_eval(fn, [last, next], options));\n          return sofar;\n        } catch (ignoreandcontinue) {\n          sofar.push(last); // fall through to Node case\n        }\n      } // Encountered a Node, or failed folding --\n      // collapse everything so far into a single tree:\n\n\n      sofar.push(_ensureNode(sofar.pop()));\n      var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);\n      return [makeNode([newtree, _ensureNode(next)])];\n    }, [first]);\n\n    if (reduction.length === 1) {\n      return reduction[0];\n    } // Might end up with a tree and a constant at the end:\n\n\n    return makeNode([reduction[0], _toNode(reduction[1])]);\n  } // destroys the original node and returns a folded one\n\n\n  function foldFraction(node, options) {\n    switch (node.type) {\n      case 'SymbolNode':\n        return node;\n\n      case 'ConstantNode':\n        switch (typeof node.value) {\n          case 'number':\n            return _toNumber(node.value, options);\n\n          case 'string':\n            return node.value;\n\n          default:\n            if (!isNaN(node.value)) return _toNumber(node.value, options);\n        }\n\n        return node;\n\n      case 'FunctionNode':\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\n          return node;\n        }\n\n        {\n          // Process operators as OperatorNode\n          var operatorFunctions = ['add', 'multiply'];\n\n          if (operatorFunctions.indexOf(node.name) === -1) {\n            var args = node.args.map(arg => foldFraction(arg, options)); // If all args are numbers\n\n            if (!args.some(isNode)) {\n              try {\n                return _eval(node.name, args, options);\n              } catch (ignoreandcontinue) {}\n            } // Size of a matrix does not depend on entries\n\n\n            if (node.name === 'size' && args.length === 1 && isArrayNode(args[0])) {\n              var sz = [];\n              var section = args[0];\n\n              while (isArrayNode(section)) {\n                sz.push(section.items.length);\n                section = section.items[0];\n              }\n\n              return matrix(sz);\n            } // Convert all args to nodes and construct a symbolic function call\n\n\n            return new FunctionNode(node.name, args.map(_ensureNode));\n          } else {// treat as operator\n          }\n        }\n\n      /* falls through */\n\n      case 'OperatorNode':\n        {\n          var fn = node.fn.toString();\n\n          var _args;\n\n          var res;\n          var makeNode = createMakeNodeFunction(node);\n\n          if (isOperatorNode(node) && node.isUnary()) {\n            _args = [foldFraction(node.args[0], options)];\n\n            if (!isNode(_args[0])) {\n              res = _eval(fn, _args, options);\n            } else {\n              res = makeNode(_args);\n            }\n          } else if (isAssociative(node, options.context)) {\n            _args = allChildren(node, options.context);\n            _args = _args.map(arg => foldFraction(arg, options));\n\n            if (isCommutative(fn, options.context)) {\n              // commutative binary operator\n              var consts = [];\n              var vars = [];\n\n              for (var i = 0; i < _args.length; i++) {\n                if (!isNode(_args[i])) {\n                  consts.push(_args[i]);\n                } else {\n                  vars.push(_args[i]);\n                }\n              }\n\n              if (consts.length > 1) {\n                res = foldOp(fn, consts, makeNode, options);\n                vars.unshift(res);\n                res = foldOp(fn, vars, makeNode, options);\n              } else {\n                // we won't change the children order since it's not neccessary\n                res = foldOp(fn, _args, makeNode, options);\n              }\n            } else {\n              // non-commutative binary operator\n              res = foldOp(fn, _args, makeNode, options);\n            }\n          } else {\n            // non-associative binary operator\n            _args = node.args.map(arg => foldFraction(arg, options));\n            res = foldOp(fn, _args, makeNode, options);\n          }\n\n          return res;\n        }\n\n      case 'ParenthesisNode':\n        // remove the uneccessary parenthesis\n        return foldFraction(node.content, options);\n\n      case 'AccessorNode':\n        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);\n\n      case 'ArrayNode':\n        {\n          var foldItems = node.items.map(item => foldFraction(item, options));\n\n          if (foldItems.some(isNode)) {\n            return new ArrayNode(foldItems.map(_ensureNode));\n          }\n          /* All literals -- return a Matrix so we can operate on it */\n\n\n          return matrix(foldItems);\n        }\n\n      case 'IndexNode':\n        {\n          return new IndexNode(node.dimensions.map(n => simplifyConstant(n, options)));\n        }\n\n      case 'ObjectNode':\n        {\n          var foldProps = {};\n\n          for (var prop in node.properties) {\n            foldProps[prop] = simplifyConstant(node.properties[prop], options);\n          }\n\n          return new ObjectNode(foldProps);\n        }\n\n      case 'AssignmentNode':\n      /* falls through */\n\n      case 'BlockNode':\n      /* falls through */\n\n      case 'FunctionAssignmentNode':\n      /* falls through */\n\n      case 'RangeNode':\n      /* falls through */\n\n      case 'ConditionalNode':\n      /* falls through */\n\n      default:\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\n    }\n  }\n\n  return simplifyConstant;\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/simplifyConstant.js"],"names":["isFraction","isMatrix","isNode","isArrayNode","isConstantNode","isIndexNode","isObjectNode","isOperatorNode","factory","createUtil","noBignumber","noFraction","name","dependencies","createSimplifyConstant","_ref","typed","config","mathWithTransform","matrix","fraction","bignumber","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","SymbolNode","isCommutative","isAssociative","allChildren","createMakeNodeFunction","simplifyConstant","Node","node","_ensureNode","foldFraction","NodeObject","expr","options","_removeFractions","thing","valueOf","Array","map","_eval","fnname","args","apply","ignore","_toNumber","_toNode","Fraction","_fractionToNode","number","n","unaryMinusNode","BigNumber","Complex","s","Error","string","Matrix","m","e","_exactFraction","exactFractions","isFinite","f","fractionsLimit","Infinity","d","stringObject","undefined","parseFloat","FractionObject","BigNumberObject","numberObject","ComplexObject","im","re","MatrixObject","ArrayObject","vn","_foldAccessor","obj","index","remainingDims","from","dimensions","length","value","first","shift","items","second","tryItems","fromItems","item","push","splice","key","properties","foldOp","fn","makeNode","reduction","reduce","sofar","next","last","pop","ignoreandcontinue","newtree","type","isNaN","rawArgs","operatorFunctions","indexOf","arg","some","sz","section","toString","_args","res","isUnary","context","consts","vars","i","unshift","content","object","foldItems","foldProps","prop","concat"],"mappings":"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","sourcesContent":["import { isFraction, isMatrix, isNode, isArrayNode, isConstantNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\r\nimport { factory } from '../../utils/factory.js';\r\nimport { createUtil } from './simplify/util.js';\r\nimport { noBignumber, noFraction } from '../../utils/noop.js';\r\nvar name = 'simplifyConstant';\r\nvar dependencies = ['typed', 'config', 'mathWithTransform', 'matrix', '?fraction', '?bignumber', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'SymbolNode'];\r\nexport var createSimplifyConstant = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    config,\r\n    mathWithTransform,\r\n    matrix,\r\n    fraction,\r\n    bignumber,\r\n    AccessorNode,\r\n    ArrayNode,\r\n    ConstantNode,\r\n    FunctionNode,\r\n    IndexNode,\r\n    ObjectNode,\r\n    OperatorNode,\r\n    SymbolNode\r\n  } = _ref;\r\n  var {\r\n    isCommutative,\r\n    isAssociative,\r\n    allChildren,\r\n    createMakeNodeFunction\r\n  } = createUtil({\r\n    FunctionNode,\r\n    OperatorNode,\r\n    SymbolNode\r\n  });\r\n\r\n  /**\r\n   * simplifyConstant() takes a mathjs expression (either a Node representing\r\n   * a parse tree or a string which it parses to produce a node), and replaces\r\n   * any subexpression of it consisting entirely of constants with the computed\r\n   * value of that subexpression.\r\n   *\r\n   * Syntax:\r\n   *\r\n   *     simplifyConstant(expr)\r\n   *     simplifyConstant(expr, options)\r\n   *\r\n   * Examples:\r\n   *\r\n   *     math.simplifyConstant('x + 4*3/6')  // Node \"x + 2\"\r\n   *     math.simplifyConstant('z cos(0)')   // Node \"z 1\"\r\n   *     math.simplifyConstant('(5.2 + 1.08)t', {exactFractions: false})  // Node \"6.28 t\"\r\n   *\r\n   * See also:\r\n   *\r\n   *     simplify, simplifyCore, resolve, derivative\r\n   *\r\n   * @param {Node | string} node\r\n   *     The expression to be simplified\r\n   * @param {Object} options\r\n   *     Simplification options, as per simplify()\r\n   * @return {Node} Returns expression with constant subexpressions evaluated\r\n   */\r\n  var simplifyConstant = typed('simplifyConstant', {\r\n    Node: node => _ensureNode(foldFraction(node, {})),\r\n    'Node, Object': function NodeObject(expr, options) {\r\n      return _ensureNode(foldFraction(expr, options));\r\n    }\r\n  });\r\n  function _removeFractions(thing) {\r\n    if (isFraction(thing)) {\r\n      return thing.valueOf();\r\n    }\r\n    if (thing instanceof Array) {\r\n      return thing.map(_removeFractions);\r\n    }\r\n    if (isMatrix(thing)) {\r\n      return matrix(_removeFractions(thing.valueOf()));\r\n    }\r\n    return thing;\r\n  }\r\n  function _eval(fnname, args, options) {\r\n    try {\r\n      return mathWithTransform[fnname].apply(null, args);\r\n    } catch (ignore) {\r\n      // sometimes the implicit type conversion causes the evaluation to fail, so we'll try again after removing Fractions\r\n      args = args.map(_removeFractions);\r\n      return _toNumber(mathWithTransform[fnname].apply(null, args), options);\r\n    }\r\n  }\r\n  var _toNode = typed({\r\n    Fraction: _fractionToNode,\r\n    number: function number(n) {\r\n      if (n < 0) {\r\n        return unaryMinusNode(new ConstantNode(-n));\r\n      }\r\n      return new ConstantNode(n);\r\n    },\r\n    BigNumber: function BigNumber(n) {\r\n      if (n < 0) {\r\n        return unaryMinusNode(new ConstantNode(-n));\r\n      }\r\n      return new ConstantNode(n); // old parameters: (n.toString(), 'number')\r\n    },\r\n\r\n    Complex: function Complex(s) {\r\n      throw new Error('Cannot convert Complex number to Node');\r\n    },\r\n    string: function string(s) {\r\n      return new ConstantNode(s);\r\n    },\r\n    Matrix: function Matrix(m) {\r\n      return new ArrayNode(m.valueOf().map(e => _toNode(e)));\r\n    }\r\n  });\r\n  function _ensureNode(thing) {\r\n    if (isNode(thing)) {\r\n      return thing;\r\n    }\r\n    return _toNode(thing);\r\n  }\r\n\r\n  // convert a number to a fraction only if it can be expressed exactly,\r\n  // and when both numerator and denominator are small enough\r\n  function _exactFraction(n, options) {\r\n    var exactFractions = options && options.exactFractions !== false;\r\n    if (exactFractions && isFinite(n) && fraction) {\r\n      var f = fraction(n);\r\n      var fractionsLimit = options && typeof options.fractionsLimit === 'number' ? options.fractionsLimit : Infinity; // no limit by default\r\n\r\n      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {\r\n        return f;\r\n      }\r\n    }\r\n    return n;\r\n  }\r\n\r\n  // Convert numbers to a preferred number type in preference order: Fraction, number, Complex\r\n  // BigNumbers are left alone\r\n  var _toNumber = typed({\r\n    'string, Object': function stringObject(s, options) {\r\n      if (config.number === 'BigNumber') {\r\n        if (bignumber === undefined) {\r\n          noBignumber();\r\n        }\r\n        return bignumber(s);\r\n      } else if (config.number === 'Fraction') {\r\n        if (fraction === undefined) {\r\n          noFraction();\r\n        }\r\n        return fraction(s);\r\n      } else {\r\n        var n = parseFloat(s);\r\n        return _exactFraction(n, options);\r\n      }\r\n    },\r\n    'Fraction, Object': function FractionObject(s, options) {\r\n      return s;\r\n    },\r\n    // we don't need options here\r\n\r\n    'BigNumber, Object': function BigNumberObject(s, options) {\r\n      return s;\r\n    },\r\n    // we don't need options here\r\n\r\n    'number, Object': function numberObject(s, options) {\r\n      return _exactFraction(s, options);\r\n    },\r\n    'Complex, Object': function ComplexObject(s, options) {\r\n      if (s.im !== 0) {\r\n        return s;\r\n      }\r\n      return _exactFraction(s.re, options);\r\n    },\r\n    'Matrix, Object': function MatrixObject(s, options) {\r\n      return matrix(_exactFraction(s.valueOf()));\r\n    },\r\n    'Array, Object': function ArrayObject(s, options) {\r\n      return s.map(_exactFraction);\r\n    }\r\n  });\r\n  function unaryMinusNode(n) {\r\n    return new OperatorNode('-', 'unaryMinus', [n]);\r\n  }\r\n  function _fractionToNode(f) {\r\n    var n;\r\n    var vn = f.s * f.n;\r\n    if (vn < 0) {\r\n      n = new OperatorNode('-', 'unaryMinus', [new ConstantNode(-vn)]);\r\n    } else {\r\n      n = new ConstantNode(vn);\r\n    }\r\n    if (f.d === 1) {\r\n      return n;\r\n    }\r\n    return new OperatorNode('/', 'divide', [n, new ConstantNode(f.d)]);\r\n  }\r\n\r\n  /* Handles constant indexing of ArrayNodes, matrices, and ObjectNodes */\r\n  function _foldAccessor(obj, index, options) {\r\n    if (!isIndexNode(index)) {\r\n      // don't know what to do with that...\r\n      return new AccessorNode(_ensureNode(obj), _ensureNode(index));\r\n    }\r\n    if (isArrayNode(obj) || isMatrix(obj)) {\r\n      var remainingDims = Array.from(index.dimensions);\r\n      /* We will resolve constant indices one at a time, looking\r\n       * just in the first or second dimensions because (a) arrays\r\n       * of more than two dimensions are likely rare, and (b) pulling\r\n       * out the third or higher dimension would be pretty intricate.\r\n       * The price is that we miss simplifying [..3d array][x,y,1]\r\n       */\r\n      while (remainingDims.length > 0) {\r\n        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== 'string') {\r\n          var first = _toNumber(remainingDims.shift().value, options);\r\n          if (isArrayNode(obj)) {\r\n            obj = obj.items[first - 1];\r\n          } else {\r\n            // matrix\r\n            obj = obj.valueOf()[first - 1];\r\n            if (obj instanceof Array) {\r\n              obj = matrix(obj);\r\n            }\r\n          }\r\n        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== 'string') {\r\n          var second = _toNumber(remainingDims[1].value, options);\r\n          var tryItems = [];\r\n          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();\r\n          for (var item of fromItems) {\r\n            if (isArrayNode(item)) {\r\n              tryItems.push(item.items[second - 1]);\r\n            } else if (isMatrix(obj)) {\r\n              tryItems.push(item[second - 1]);\r\n            } else {\r\n              break;\r\n            }\r\n          }\r\n          if (tryItems.length === fromItems.length) {\r\n            if (isArrayNode(obj)) {\r\n              obj = new ArrayNode(tryItems);\r\n            } else {\r\n              // matrix\r\n              obj = matrix(tryItems);\r\n            }\r\n            remainingDims.splice(1, 1);\r\n          } else {\r\n            // extracting slice along 2nd dimension failed, give up\r\n            break;\r\n          }\r\n        } else {\r\n          // neither 1st or 2nd dimension is constant, give up\r\n          break;\r\n        }\r\n      }\r\n      if (remainingDims.length === index.dimensions.length) {\r\n        /* No successful constant indexing */\r\n        return new AccessorNode(_ensureNode(obj), index);\r\n      }\r\n      if (remainingDims.length > 0) {\r\n        /* Indexed some but not all dimensions */\r\n        index = new IndexNode(remainingDims);\r\n        return new AccessorNode(_ensureNode(obj), index);\r\n      }\r\n      /* All dimensions were constant, access completely resolved */\r\n      return obj;\r\n    }\r\n    if (isObjectNode(obj) && index.dimensions.length === 1 && isConstantNode(index.dimensions[0])) {\r\n      var key = index.dimensions[0].value;\r\n      if (key in obj.properties) {\r\n        return obj.properties[key];\r\n      }\r\n      return new ConstantNode(); // undefined\r\n    }\r\n    /* Don't know how to index this sort of obj, at least not with this index */\r\n    return new AccessorNode(_ensureNode(obj), index);\r\n  }\r\n\r\n  /*\r\n   * Create a binary tree from a list of Fractions and Nodes.\r\n   * Tries to fold Fractions by evaluating them until the first Node in the list is hit, so\r\n   * `args` should be sorted to have the Fractions at the start (if the operator is commutative).\r\n   * @param args - list of Fractions and Nodes\r\n   * @param fn - evaluator for the binary operation evaluator that accepts two Fractions\r\n   * @param makeNode - creates a binary OperatorNode/FunctionNode from a list of child Nodes\r\n   * if args.length is 1, returns args[0]\r\n   * @return - Either a Node representing a binary expression or Fraction\r\n   */\r\n  function foldOp(fn, args, makeNode, options) {\r\n    var first = args.shift();\r\n\r\n    // In the following reduction, sofar always has one of the three following\r\n    // forms: [NODE], [CONSTANT], or [NODE, CONSTANT]\r\n    var reduction = args.reduce((sofar, next) => {\r\n      if (!isNode(next)) {\r\n        var last = sofar.pop();\r\n        if (isNode(last)) {\r\n          return [last, next];\r\n        }\r\n        // Two constants in a row, try to fold them into one\r\n        try {\r\n          sofar.push(_eval(fn, [last, next], options));\r\n          return sofar;\r\n        } catch (ignoreandcontinue) {\r\n          sofar.push(last);\r\n          // fall through to Node case\r\n        }\r\n      }\r\n\r\n      // Encountered a Node, or failed folding --\r\n      // collapse everything so far into a single tree:\r\n      sofar.push(_ensureNode(sofar.pop()));\r\n      var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);\r\n      return [makeNode([newtree, _ensureNode(next)])];\r\n    }, [first]);\r\n    if (reduction.length === 1) {\r\n      return reduction[0];\r\n    }\r\n    // Might end up with a tree and a constant at the end:\r\n    return makeNode([reduction[0], _toNode(reduction[1])]);\r\n  }\r\n\r\n  // destroys the original node and returns a folded one\r\n  function foldFraction(node, options) {\r\n    switch (node.type) {\r\n      case 'SymbolNode':\r\n        return node;\r\n      case 'ConstantNode':\r\n        switch (typeof node.value) {\r\n          case 'number':\r\n            return _toNumber(node.value, options);\r\n          case 'string':\r\n            return node.value;\r\n          default:\r\n            if (!isNaN(node.value)) return _toNumber(node.value, options);\r\n        }\r\n        return node;\r\n      case 'FunctionNode':\r\n        if (mathWithTransform[node.name] && mathWithTransform[node.name].rawArgs) {\r\n          return node;\r\n        }\r\n        {\r\n          // Process operators as OperatorNode\r\n          var operatorFunctions = ['add', 'multiply'];\r\n          if (operatorFunctions.indexOf(node.name) === -1) {\r\n            var args = node.args.map(arg => foldFraction(arg, options));\r\n\r\n            // If all args are numbers\r\n            if (!args.some(isNode)) {\r\n              try {\r\n                return _eval(node.name, args, options);\r\n              } catch (ignoreandcontinue) {}\r\n            }\r\n\r\n            // Size of a matrix does not depend on entries\r\n            if (node.name === 'size' && args.length === 1 && isArrayNode(args[0])) {\r\n              var sz = [];\r\n              var section = args[0];\r\n              while (isArrayNode(section)) {\r\n                sz.push(section.items.length);\r\n                section = section.items[0];\r\n              }\r\n              return matrix(sz);\r\n            }\r\n\r\n            // Convert all args to nodes and construct a symbolic function call\r\n            return new FunctionNode(node.name, args.map(_ensureNode));\r\n          } else {\r\n            // treat as operator\r\n          }\r\n        }\r\n      /* falls through */\r\n      case 'OperatorNode':\r\n        {\r\n          var fn = node.fn.toString();\r\n          var _args;\r\n          var res;\r\n          var makeNode = createMakeNodeFunction(node);\r\n          if (isOperatorNode(node) && node.isUnary()) {\r\n            _args = [foldFraction(node.args[0], options)];\r\n            if (!isNode(_args[0])) {\r\n              res = _eval(fn, _args, options);\r\n            } else {\r\n              res = makeNode(_args);\r\n            }\r\n          } else if (isAssociative(node, options.context)) {\r\n            _args = allChildren(node, options.context);\r\n            _args = _args.map(arg => foldFraction(arg, options));\r\n            if (isCommutative(fn, options.context)) {\r\n              // commutative binary operator\r\n              var consts = [];\r\n              var vars = [];\r\n              for (var i = 0; i < _args.length; i++) {\r\n                if (!isNode(_args[i])) {\r\n                  consts.push(_args[i]);\r\n                } else {\r\n                  vars.push(_args[i]);\r\n                }\r\n              }\r\n              if (consts.length > 1) {\r\n                res = foldOp(fn, consts, makeNode, options);\r\n                vars.unshift(res);\r\n                res = foldOp(fn, vars, makeNode, options);\r\n              } else {\r\n                // we won't change the children order since it's not neccessary\r\n                res = foldOp(fn, _args, makeNode, options);\r\n              }\r\n            } else {\r\n              // non-commutative binary operator\r\n              res = foldOp(fn, _args, makeNode, options);\r\n            }\r\n          } else {\r\n            // non-associative binary operator\r\n            _args = node.args.map(arg => foldFraction(arg, options));\r\n            res = foldOp(fn, _args, makeNode, options);\r\n          }\r\n          return res;\r\n        }\r\n      case 'ParenthesisNode':\r\n        // remove the uneccessary parenthesis\r\n        return foldFraction(node.content, options);\r\n      case 'AccessorNode':\r\n        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);\r\n      case 'ArrayNode':\r\n        {\r\n          var foldItems = node.items.map(item => foldFraction(item, options));\r\n          if (foldItems.some(isNode)) {\r\n            return new ArrayNode(foldItems.map(_ensureNode));\r\n          }\r\n          /* All literals -- return a Matrix so we can operate on it */\r\n          return matrix(foldItems);\r\n        }\r\n      case 'IndexNode':\r\n        {\r\n          return new IndexNode(node.dimensions.map(n => simplifyConstant(n, options)));\r\n        }\r\n      case 'ObjectNode':\r\n        {\r\n          var foldProps = {};\r\n          for (var prop in node.properties) {\r\n            foldProps[prop] = simplifyConstant(node.properties[prop], options);\r\n          }\r\n          return new ObjectNode(foldProps);\r\n        }\r\n      case 'AssignmentNode':\r\n      /* falls through */\r\n      case 'BlockNode':\r\n      /* falls through */\r\n      case 'FunctionAssignmentNode':\r\n      /* falls through */\r\n      case 'RangeNode':\r\n      /* falls through */\r\n      case 'ConditionalNode':\r\n      /* falls through */\r\n      default:\r\n        throw new Error(\"Unimplemented node type in simplifyConstant: \".concat(node.type));\r\n    }\r\n  }\r\n  return simplifyConstant;\r\n});"]},"metadata":{},"sourceType":"module"}