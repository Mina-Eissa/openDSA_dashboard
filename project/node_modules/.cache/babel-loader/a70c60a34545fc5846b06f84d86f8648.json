{"ast":null,"code":"import { isInteger } from './number.js';\nimport { isNumber } from './is.js';\nimport { format } from './string.js';\nimport { DimensionError } from '../error/DimensionError.js';\nimport { IndexError } from '../error/IndexError.js';\n/**\r\n * Calculate the size of a multi dimensional array.\r\n * This function checks the size of the first entry, it does not validate\r\n * whether all dimensions match. (use function `validate` for that)\r\n * @param {Array} x\r\n * @Return {Number[]} size\r\n */\n\nexport function arraySize(x) {\n  var s = [];\n\n  while (Array.isArray(x)) {\n    s.push(x.length);\n    x = x[0];\n  }\n\n  return s;\n}\n/**\r\n * Recursively validate whether each element in a multi dimensional array\r\n * has a size corresponding to the provided size array.\r\n * @param {Array} array    Array to be validated\r\n * @param {number[]} size  Array with the size of each dimension\r\n * @param {number} dim   Current dimension\r\n * @throws DimensionError\r\n * @private\r\n */\n\nfunction _validate(array, size, dim) {\n  var i;\n  var len = array.length;\n\n  if (len !== size[dim]) {\n    throw new DimensionError(len, size[dim]);\n  }\n\n  if (dim < size.length - 1) {\n    // recursively validate each child array\n    var dimNext = dim + 1;\n\n    for (i = 0; i < len; i++) {\n      var child = array[i];\n\n      if (!Array.isArray(child)) {\n        throw new DimensionError(size.length - 1, size.length, '<');\n      }\n\n      _validate(array[i], size, dimNext);\n    }\n  } else {\n    // last dimension. none of the childs may be an array\n    for (i = 0; i < len; i++) {\n      if (Array.isArray(array[i])) {\n        throw new DimensionError(size.length + 1, size.length, '>');\n      }\n    }\n  }\n}\n/**\r\n * Validate whether each element in a multi dimensional array has\r\n * a size corresponding to the provided size array.\r\n * @param {Array} array    Array to be validated\r\n * @param {number[]} size  Array with the size of each dimension\r\n * @throws DimensionError\r\n */\n\n\nexport function validate(array, size) {\n  var isScalar = size.length === 0;\n\n  if (isScalar) {\n    // scalar\n    if (Array.isArray(array)) {\n      throw new DimensionError(array.length, 0);\n    }\n  } else {\n    // array\n    _validate(array, size, 0);\n  }\n}\n/**\r\n * Test whether index is an integer number with index >= 0 and index < length\r\n * when length is provided\r\n * @param {number} index    Zero-based index\r\n * @param {number} [length] Length of the array\r\n */\n\nexport function validateIndex(index, length) {\n  if (!isNumber(index) || !isInteger(index)) {\n    throw new TypeError('Index must be an integer (value: ' + index + ')');\n  }\n\n  if (index < 0 || typeof length === 'number' && index >= length) {\n    throw new IndexError(index, length);\n  }\n}\n/**\r\n * Resize a multi dimensional array. The resized array is returned.\r\n * @param {Array} array         Array to be resized\r\n * @param {Array.<number>} size Array with the size of each dimension\r\n * @param {*} [defaultValue=0]  Value to be filled in in new entries,\r\n *                              zero by default. Specify for example `null`,\r\n *                              to clearly see entries that are not explicitly\r\n *                              set.\r\n * @return {Array} array         The resized array\r\n */\n\nexport function resize(array, size, defaultValue) {\n  // TODO: add support for scalars, having size=[] ?\n  // check the type of the arguments\n  if (!Array.isArray(array) || !Array.isArray(size)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (size.length === 0) {\n    throw new Error('Resizing to scalar is not supported');\n  } // check whether size contains positive integers\n\n\n  size.forEach(function (value) {\n    if (!isNumber(value) || !isInteger(value) || value < 0) {\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\n    }\n  }); // recursively resize the array\n\n  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;\n\n  _resize(array, size, 0, _defaultValue);\n\n  return array;\n}\n/**\r\n * Recursively resize a multi dimensional array\r\n * @param {Array} array         Array to be resized\r\n * @param {number[]} size       Array with the size of each dimension\r\n * @param {number} dim          Current dimension\r\n * @param {*} [defaultValue]    Value to be filled in in new entries,\r\n *                              undefined by default.\r\n * @private\r\n */\n\nfunction _resize(array, size, dim, defaultValue) {\n  var i;\n  var elem;\n  var oldLen = array.length;\n  var newLen = size[dim];\n  var minLen = Math.min(oldLen, newLen); // apply new length\n\n  array.length = newLen;\n\n  if (dim < size.length - 1) {\n    // non-last dimension\n    var dimNext = dim + 1; // resize existing child arrays\n\n    for (i = 0; i < minLen; i++) {\n      // resize child array\n      elem = array[i];\n\n      if (!Array.isArray(elem)) {\n        elem = [elem]; // add a dimension\n\n        array[i] = elem;\n      }\n\n      _resize(elem, size, dimNext, defaultValue);\n    } // create new child arrays\n\n\n    for (i = minLen; i < newLen; i++) {\n      // get child array\n      elem = [];\n      array[i] = elem; // resize new child array\n\n      _resize(elem, size, dimNext, defaultValue);\n    }\n  } else {\n    // last dimension\n    // remove dimensions of existing values\n    for (i = 0; i < minLen; i++) {\n      while (Array.isArray(array[i])) {\n        array[i] = array[i][0];\n      }\n    } // fill new elements with the default value\n\n\n    for (i = minLen; i < newLen; i++) {\n      array[i] = defaultValue;\n    }\n  }\n}\n/**\r\n * Re-shape a multi dimensional array to fit the specified dimensions\r\n * @param {Array} array           Array to be reshaped\r\n * @param {Array.<number>} sizes  List of sizes for each dimension\r\n * @returns {Array}               Array whose data has been formatted to fit the\r\n *                                specified dimensions\r\n *\r\n * @throws {DimensionError}       If the product of the new dimension sizes does\r\n *                                not equal that of the old ones\r\n */\n\n\nexport function reshape(array, sizes) {\n  var flatArray = flatten(array);\n  var currentLength = flatArray.length;\n\n  if (!Array.isArray(array) || !Array.isArray(sizes)) {\n    throw new TypeError('Array expected');\n  }\n\n  if (sizes.length === 0) {\n    throw new DimensionError(0, currentLength, '!=');\n  }\n\n  sizes = processSizesWildcard(sizes, currentLength);\n  var newLength = product(sizes);\n\n  if (currentLength !== newLength) {\n    throw new DimensionError(newLength, currentLength, '!=');\n  }\n\n  try {\n    return _reshape(flatArray, sizes);\n  } catch (e) {\n    if (e instanceof DimensionError) {\n      throw new DimensionError(newLength, currentLength, '!=');\n    }\n\n    throw e;\n  }\n}\n/**\r\n * Replaces the wildcard -1 in the sizes array.\r\n * @param {Array.<number>} sizes  List of sizes for each dimension. At most on wildcard.\r\n * @param {number} currentLength  Number of elements in the array.\r\n * @throws {Error}                If more than one wildcard or unable to replace it.\r\n * @returns {Array.<number>}      The sizes array with wildcard replaced.\r\n */\n\nexport function processSizesWildcard(sizes, currentLength) {\n  var newLength = product(sizes);\n  var processedSizes = sizes.slice();\n  var WILDCARD = -1;\n  var wildCardIndex = sizes.indexOf(WILDCARD);\n  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;\n\n  if (isMoreThanOneWildcard) {\n    throw new Error('More than one wildcard in sizes');\n  }\n\n  var hasWildcard = wildCardIndex >= 0;\n  var canReplaceWildcard = currentLength % newLength === 0;\n\n  if (hasWildcard) {\n    if (canReplaceWildcard) {\n      processedSizes[wildCardIndex] = -currentLength / newLength;\n    } else {\n      throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);\n    }\n  }\n\n  return processedSizes;\n}\n/**\r\n * Computes the product of all array elements.\r\n * @param {Array<number>} array Array of factors\r\n * @returns {number}            Product of all elements\r\n */\n\nfunction product(array) {\n  return array.reduce((prev, curr) => prev * curr, 1);\n}\n/**\r\n * Iteratively re-shape a multi dimensional array to fit the specified dimensions\r\n * @param {Array} array           Array to be reshaped\r\n * @param {Array.<number>} sizes  List of sizes for each dimension\r\n * @returns {Array}               Array whose data has been formatted to fit the\r\n *                                specified dimensions\r\n */\n\n\nfunction _reshape(array, sizes) {\n  // testing if there are enough elements for the requested shape\n  var tmpArray = array;\n  var tmpArray2; // for each dimensions starting by the last one and ignoring the first one\n\n  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {\n    var size = sizes[sizeIndex];\n    tmpArray2 = []; // aggregate the elements of the current tmpArray in elements of the requested size\n\n    var length = tmpArray.length / size;\n\n    for (var i = 0; i < length; i++) {\n      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));\n    } // set it as the new tmpArray for the next loop turn or for return\n\n\n    tmpArray = tmpArray2;\n  }\n\n  return tmpArray;\n}\n/**\r\n * Squeeze a multi dimensional array\r\n * @param {Array} array\r\n * @param {Array} [size]\r\n * @returns {Array} returns the array itself\r\n */\n\n\nexport function squeeze(array, size) {\n  var s = size || arraySize(array); // squeeze outer dimensions\n\n  while (Array.isArray(array) && array.length === 1) {\n    array = array[0];\n    s.shift();\n  } // find the first dimension to be squeezed\n\n\n  var dims = s.length;\n\n  while (s[dims - 1] === 1) {\n    dims--;\n  } // squeeze inner dimensions\n\n\n  if (dims < s.length) {\n    array = _squeeze(array, dims, 0);\n    s.length = dims;\n  }\n\n  return array;\n}\n/**\r\n * Recursively squeeze a multi dimensional array\r\n * @param {Array} array\r\n * @param {number} dims Required number of dimensions\r\n * @param {number} dim  Current dimension\r\n * @returns {Array | *} Returns the squeezed array\r\n * @private\r\n */\n\nfunction _squeeze(array, dims, dim) {\n  var i, ii;\n\n  if (dim < dims) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _squeeze(array[i], dims, next);\n    }\n  } else {\n    while (Array.isArray(array)) {\n      array = array[0];\n    }\n  }\n\n  return array;\n}\n/**\r\n * Unsqueeze a multi dimensional array: add dimensions when missing\r\n *\r\n * Paramter `size` will be mutated to match the new, unqueezed matrix size.\r\n *\r\n * @param {Array} array\r\n * @param {number} dims       Desired number of dimensions of the array\r\n * @param {number} [outer]    Number of outer dimensions to be added\r\n * @param {Array} [size] Current size of array.\r\n * @returns {Array} returns the array itself\r\n * @private\r\n */\n\n\nexport function unsqueeze(array, dims, outer, size) {\n  var s = size || arraySize(array); // unsqueeze outer dimensions\n\n  if (outer) {\n    for (var i = 0; i < outer; i++) {\n      array = [array];\n      s.unshift(1);\n    }\n  } // unsqueeze inner dimensions\n\n\n  array = _unsqueeze(array, dims, 0);\n\n  while (s.length < dims) {\n    s.push(1);\n  }\n\n  return array;\n}\n/**\r\n * Recursively unsqueeze a multi dimensional array\r\n * @param {Array} array\r\n * @param {number} dims Required number of dimensions\r\n * @param {number} dim  Current dimension\r\n * @returns {Array | *} Returns the squeezed array\r\n * @private\r\n */\n\nfunction _unsqueeze(array, dims, dim) {\n  var i, ii;\n\n  if (Array.isArray(array)) {\n    var next = dim + 1;\n\n    for (i = 0, ii = array.length; i < ii; i++) {\n      array[i] = _unsqueeze(array[i], dims, next);\n    }\n  } else {\n    for (var d = dim; d < dims; d++) {\n      array = [array];\n    }\n  }\n\n  return array;\n}\n/**\r\n * Flatten a multi dimensional array, put all elements in a one dimensional\r\n * array\r\n * @param {Array} array   A multi dimensional array\r\n * @return {Array}        The flattened array (1 dimensional)\r\n */\n\n\nexport function flatten(array) {\n  if (!Array.isArray(array)) {\n    // if not an array, return as is\n    return array;\n  }\n\n  var flat = [];\n  array.forEach(function callback(value) {\n    if (Array.isArray(value)) {\n      value.forEach(callback); // traverse through sub-arrays recursively\n    } else {\n      flat.push(value);\n    }\n  });\n  return flat;\n}\n/**\r\n * A safe map\r\n * @param {Array} array\r\n * @param {function} callback\r\n */\n\nexport function map(array, callback) {\n  return Array.prototype.map.call(array, callback);\n}\n/**\r\n * A safe forEach\r\n * @param {Array} array\r\n * @param {function} callback\r\n */\n\nexport function forEach(array, callback) {\n  Array.prototype.forEach.call(array, callback);\n}\n/**\r\n * A safe filter\r\n * @param {Array} array\r\n * @param {function} callback\r\n */\n\nexport function filter(array, callback) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, callback);\n}\n/**\r\n * Filter values in a callback given a regular expression\r\n * @param {Array} array\r\n * @param {RegExp} regexp\r\n * @return {Array} Returns the filtered array\r\n * @private\r\n */\n\nexport function filterRegExp(array, regexp) {\n  if (arraySize(array).length !== 1) {\n    throw new Error('Only one dimensional matrices supported');\n  }\n\n  return Array.prototype.filter.call(array, entry => regexp.test(entry));\n}\n/**\r\n * A safe join\r\n * @param {Array} array\r\n * @param {string} separator\r\n */\n\nexport function join(array, separator) {\n  return Array.prototype.join.call(array, separator);\n}\n/**\r\n * Assign a numeric identifier to every element of a sorted array\r\n * @param {Array} a  An array\r\n * @return {Array} An array of objects containing the original value and its identifier\r\n */\n\nexport function identify(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n  var count = 0;\n  b[0] = {\n    value: a[0],\n    identifier: 0\n  };\n\n  for (var i = 1; i < a.length; i++) {\n    if (a[i] === a[i - 1]) {\n      count++;\n    } else {\n      count = 0;\n    }\n\n    b.push({\n      value: a[i],\n      identifier: count\n    });\n  }\n\n  return b;\n}\n/**\r\n * Remove the numeric identifier from the elements\r\n * @param {array} a  An array\r\n * @return {array} An array of values without identifiers\r\n */\n\nexport function generalize(a) {\n  if (!Array.isArray(a)) {\n    throw new TypeError('Array input expected');\n  }\n\n  if (a.length === 0) {\n    return a;\n  }\n\n  var b = [];\n\n  for (var i = 0; i < a.length; i++) {\n    b.push(a[i].value);\n  }\n\n  return b;\n}\n/**\r\n * Check the datatype of a given object\r\n * This is a low level implementation that should only be used by\r\n * parent Matrix classes such as SparseMatrix or DenseMatrix\r\n * This method does not validate Array Matrix shape\r\n * @param {Array} array\r\n * @param {function} typeOf   Callback function to use to determine the type of a value\r\n * @return {string}\r\n */\n\nexport function getArrayDataType(array, typeOf) {\n  var type; // to hold type info\n\n  var length = 0; // to hold length value to ensure it has consistent sizes\n\n  for (var i = 0; i < array.length; i++) {\n    var item = array[i];\n    var isArray = Array.isArray(item); // Saving the target matrix row size\n\n    if (i === 0 && isArray) {\n      length = item.length;\n    } // If the current item is an array but the length does not equal the targetVectorSize\n\n\n    if (isArray && item.length !== length) {\n      return undefined;\n    }\n\n    var itemType = isArray ? getArrayDataType(item, typeOf) // recurse into a nested array\n    : typeOf(item);\n\n    if (type === undefined) {\n      type = itemType; // first item\n    } else if (type !== itemType) {\n      return 'mixed';\n    } else {// we're good, everything has the same type so far\n    }\n  }\n\n  return type;\n}\n/**\r\n * Return the last item from an array\r\n * @param array\r\n * @returns {*}\r\n */\n\nexport function last(array) {\n  return array[array.length - 1];\n}\n/**\r\n * Get all but the last element of array.\r\n */\n\nexport function initial(array) {\n  return array.slice(0, array.length - 1);\n}\n/**\r\n * Test whether an array or string contains an item\r\n * @param {Array | string} array\r\n * @param {*} item\r\n * @return {boolean}\r\n */\n\nexport function contains(array, item) {\n  return array.indexOf(item) !== -1;\n}","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/utils/array.js"],"names":["isInteger","isNumber","format","DimensionError","IndexError","arraySize","x","s","Array","isArray","push","length","_validate","array","size","dim","i","len","dimNext","child","validate","isScalar","validateIndex","index","TypeError","resize","defaultValue","Error","forEach","value","_defaultValue","undefined","_resize","elem","oldLen","newLen","minLen","Math","min","reshape","sizes","flatArray","flatten","currentLength","processSizesWildcard","newLength","product","_reshape","e","processedSizes","slice","WILDCARD","wildCardIndex","indexOf","isMoreThanOneWildcard","hasWildcard","canReplaceWildcard","reduce","prev","curr","tmpArray","tmpArray2","sizeIndex","squeeze","shift","dims","_squeeze","ii","next","unsqueeze","outer","unshift","_unsqueeze","d","flat","callback","map","prototype","call","filter","filterRegExp","regexp","entry","test","join","separator","identify","a","b","count","identifier","generalize","getArrayDataType","typeOf","type","item","itemType","last","initial","contains"],"mappings":"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","sourcesContent":["import { isInteger } from './number.js';\r\nimport { isNumber } from './is.js';\r\nimport { format } from './string.js';\r\nimport { DimensionError } from '../error/DimensionError.js';\r\nimport { IndexError } from '../error/IndexError.js';\r\n\r\n/**\r\n * Calculate the size of a multi dimensional array.\r\n * This function checks the size of the first entry, it does not validate\r\n * whether all dimensions match. (use function `validate` for that)\r\n * @param {Array} x\r\n * @Return {Number[]} size\r\n */\r\nexport function arraySize(x) {\r\n  var s = [];\r\n  while (Array.isArray(x)) {\r\n    s.push(x.length);\r\n    x = x[0];\r\n  }\r\n  return s;\r\n}\r\n\r\n/**\r\n * Recursively validate whether each element in a multi dimensional array\r\n * has a size corresponding to the provided size array.\r\n * @param {Array} array    Array to be validated\r\n * @param {number[]} size  Array with the size of each dimension\r\n * @param {number} dim   Current dimension\r\n * @throws DimensionError\r\n * @private\r\n */\r\nfunction _validate(array, size, dim) {\r\n  var i;\r\n  var len = array.length;\r\n  if (len !== size[dim]) {\r\n    throw new DimensionError(len, size[dim]);\r\n  }\r\n  if (dim < size.length - 1) {\r\n    // recursively validate each child array\r\n    var dimNext = dim + 1;\r\n    for (i = 0; i < len; i++) {\r\n      var child = array[i];\r\n      if (!Array.isArray(child)) {\r\n        throw new DimensionError(size.length - 1, size.length, '<');\r\n      }\r\n      _validate(array[i], size, dimNext);\r\n    }\r\n  } else {\r\n    // last dimension. none of the childs may be an array\r\n    for (i = 0; i < len; i++) {\r\n      if (Array.isArray(array[i])) {\r\n        throw new DimensionError(size.length + 1, size.length, '>');\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Validate whether each element in a multi dimensional array has\r\n * a size corresponding to the provided size array.\r\n * @param {Array} array    Array to be validated\r\n * @param {number[]} size  Array with the size of each dimension\r\n * @throws DimensionError\r\n */\r\nexport function validate(array, size) {\r\n  var isScalar = size.length === 0;\r\n  if (isScalar) {\r\n    // scalar\r\n    if (Array.isArray(array)) {\r\n      throw new DimensionError(array.length, 0);\r\n    }\r\n  } else {\r\n    // array\r\n    _validate(array, size, 0);\r\n  }\r\n}\r\n\r\n/**\r\n * Test whether index is an integer number with index >= 0 and index < length\r\n * when length is provided\r\n * @param {number} index    Zero-based index\r\n * @param {number} [length] Length of the array\r\n */\r\nexport function validateIndex(index, length) {\r\n  if (!isNumber(index) || !isInteger(index)) {\r\n    throw new TypeError('Index must be an integer (value: ' + index + ')');\r\n  }\r\n  if (index < 0 || typeof length === 'number' && index >= length) {\r\n    throw new IndexError(index, length);\r\n  }\r\n}\r\n\r\n/**\r\n * Resize a multi dimensional array. The resized array is returned.\r\n * @param {Array} array         Array to be resized\r\n * @param {Array.<number>} size Array with the size of each dimension\r\n * @param {*} [defaultValue=0]  Value to be filled in in new entries,\r\n *                              zero by default. Specify for example `null`,\r\n *                              to clearly see entries that are not explicitly\r\n *                              set.\r\n * @return {Array} array         The resized array\r\n */\r\nexport function resize(array, size, defaultValue) {\r\n  // TODO: add support for scalars, having size=[] ?\r\n\r\n  // check the type of the arguments\r\n  if (!Array.isArray(array) || !Array.isArray(size)) {\r\n    throw new TypeError('Array expected');\r\n  }\r\n  if (size.length === 0) {\r\n    throw new Error('Resizing to scalar is not supported');\r\n  }\r\n\r\n  // check whether size contains positive integers\r\n  size.forEach(function (value) {\r\n    if (!isNumber(value) || !isInteger(value) || value < 0) {\r\n      throw new TypeError('Invalid size, must contain positive integers ' + '(size: ' + format(size) + ')');\r\n    }\r\n  });\r\n\r\n  // recursively resize the array\r\n  var _defaultValue = defaultValue !== undefined ? defaultValue : 0;\r\n  _resize(array, size, 0, _defaultValue);\r\n  return array;\r\n}\r\n\r\n/**\r\n * Recursively resize a multi dimensional array\r\n * @param {Array} array         Array to be resized\r\n * @param {number[]} size       Array with the size of each dimension\r\n * @param {number} dim          Current dimension\r\n * @param {*} [defaultValue]    Value to be filled in in new entries,\r\n *                              undefined by default.\r\n * @private\r\n */\r\nfunction _resize(array, size, dim, defaultValue) {\r\n  var i;\r\n  var elem;\r\n  var oldLen = array.length;\r\n  var newLen = size[dim];\r\n  var minLen = Math.min(oldLen, newLen);\r\n\r\n  // apply new length\r\n  array.length = newLen;\r\n  if (dim < size.length - 1) {\r\n    // non-last dimension\r\n    var dimNext = dim + 1;\r\n\r\n    // resize existing child arrays\r\n    for (i = 0; i < minLen; i++) {\r\n      // resize child array\r\n      elem = array[i];\r\n      if (!Array.isArray(elem)) {\r\n        elem = [elem]; // add a dimension\r\n        array[i] = elem;\r\n      }\r\n      _resize(elem, size, dimNext, defaultValue);\r\n    }\r\n\r\n    // create new child arrays\r\n    for (i = minLen; i < newLen; i++) {\r\n      // get child array\r\n      elem = [];\r\n      array[i] = elem;\r\n\r\n      // resize new child array\r\n      _resize(elem, size, dimNext, defaultValue);\r\n    }\r\n  } else {\r\n    // last dimension\r\n\r\n    // remove dimensions of existing values\r\n    for (i = 0; i < minLen; i++) {\r\n      while (Array.isArray(array[i])) {\r\n        array[i] = array[i][0];\r\n      }\r\n    }\r\n\r\n    // fill new elements with the default value\r\n    for (i = minLen; i < newLen; i++) {\r\n      array[i] = defaultValue;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Re-shape a multi dimensional array to fit the specified dimensions\r\n * @param {Array} array           Array to be reshaped\r\n * @param {Array.<number>} sizes  List of sizes for each dimension\r\n * @returns {Array}               Array whose data has been formatted to fit the\r\n *                                specified dimensions\r\n *\r\n * @throws {DimensionError}       If the product of the new dimension sizes does\r\n *                                not equal that of the old ones\r\n */\r\nexport function reshape(array, sizes) {\r\n  var flatArray = flatten(array);\r\n  var currentLength = flatArray.length;\r\n  if (!Array.isArray(array) || !Array.isArray(sizes)) {\r\n    throw new TypeError('Array expected');\r\n  }\r\n  if (sizes.length === 0) {\r\n    throw new DimensionError(0, currentLength, '!=');\r\n  }\r\n  sizes = processSizesWildcard(sizes, currentLength);\r\n  var newLength = product(sizes);\r\n  if (currentLength !== newLength) {\r\n    throw new DimensionError(newLength, currentLength, '!=');\r\n  }\r\n  try {\r\n    return _reshape(flatArray, sizes);\r\n  } catch (e) {\r\n    if (e instanceof DimensionError) {\r\n      throw new DimensionError(newLength, currentLength, '!=');\r\n    }\r\n    throw e;\r\n  }\r\n}\r\n\r\n/**\r\n * Replaces the wildcard -1 in the sizes array.\r\n * @param {Array.<number>} sizes  List of sizes for each dimension. At most on wildcard.\r\n * @param {number} currentLength  Number of elements in the array.\r\n * @throws {Error}                If more than one wildcard or unable to replace it.\r\n * @returns {Array.<number>}      The sizes array with wildcard replaced.\r\n */\r\nexport function processSizesWildcard(sizes, currentLength) {\r\n  var newLength = product(sizes);\r\n  var processedSizes = sizes.slice();\r\n  var WILDCARD = -1;\r\n  var wildCardIndex = sizes.indexOf(WILDCARD);\r\n  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;\r\n  if (isMoreThanOneWildcard) {\r\n    throw new Error('More than one wildcard in sizes');\r\n  }\r\n  var hasWildcard = wildCardIndex >= 0;\r\n  var canReplaceWildcard = currentLength % newLength === 0;\r\n  if (hasWildcard) {\r\n    if (canReplaceWildcard) {\r\n      processedSizes[wildCardIndex] = -currentLength / newLength;\r\n    } else {\r\n      throw new Error('Could not replace wildcard, since ' + currentLength + ' is no multiple of ' + -newLength);\r\n    }\r\n  }\r\n  return processedSizes;\r\n}\r\n\r\n/**\r\n * Computes the product of all array elements.\r\n * @param {Array<number>} array Array of factors\r\n * @returns {number}            Product of all elements\r\n */\r\nfunction product(array) {\r\n  return array.reduce((prev, curr) => prev * curr, 1);\r\n}\r\n\r\n/**\r\n * Iteratively re-shape a multi dimensional array to fit the specified dimensions\r\n * @param {Array} array           Array to be reshaped\r\n * @param {Array.<number>} sizes  List of sizes for each dimension\r\n * @returns {Array}               Array whose data has been formatted to fit the\r\n *                                specified dimensions\r\n */\r\n\r\nfunction _reshape(array, sizes) {\r\n  // testing if there are enough elements for the requested shape\r\n  var tmpArray = array;\r\n  var tmpArray2;\r\n  // for each dimensions starting by the last one and ignoring the first one\r\n  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {\r\n    var size = sizes[sizeIndex];\r\n    tmpArray2 = [];\r\n\r\n    // aggregate the elements of the current tmpArray in elements of the requested size\r\n    var length = tmpArray.length / size;\r\n    for (var i = 0; i < length; i++) {\r\n      tmpArray2.push(tmpArray.slice(i * size, (i + 1) * size));\r\n    }\r\n    // set it as the new tmpArray for the next loop turn or for return\r\n    tmpArray = tmpArray2;\r\n  }\r\n  return tmpArray;\r\n}\r\n\r\n/**\r\n * Squeeze a multi dimensional array\r\n * @param {Array} array\r\n * @param {Array} [size]\r\n * @returns {Array} returns the array itself\r\n */\r\nexport function squeeze(array, size) {\r\n  var s = size || arraySize(array);\r\n\r\n  // squeeze outer dimensions\r\n  while (Array.isArray(array) && array.length === 1) {\r\n    array = array[0];\r\n    s.shift();\r\n  }\r\n\r\n  // find the first dimension to be squeezed\r\n  var dims = s.length;\r\n  while (s[dims - 1] === 1) {\r\n    dims--;\r\n  }\r\n\r\n  // squeeze inner dimensions\r\n  if (dims < s.length) {\r\n    array = _squeeze(array, dims, 0);\r\n    s.length = dims;\r\n  }\r\n  return array;\r\n}\r\n\r\n/**\r\n * Recursively squeeze a multi dimensional array\r\n * @param {Array} array\r\n * @param {number} dims Required number of dimensions\r\n * @param {number} dim  Current dimension\r\n * @returns {Array | *} Returns the squeezed array\r\n * @private\r\n */\r\nfunction _squeeze(array, dims, dim) {\r\n  var i, ii;\r\n  if (dim < dims) {\r\n    var next = dim + 1;\r\n    for (i = 0, ii = array.length; i < ii; i++) {\r\n      array[i] = _squeeze(array[i], dims, next);\r\n    }\r\n  } else {\r\n    while (Array.isArray(array)) {\r\n      array = array[0];\r\n    }\r\n  }\r\n  return array;\r\n}\r\n\r\n/**\r\n * Unsqueeze a multi dimensional array: add dimensions when missing\r\n *\r\n * Paramter `size` will be mutated to match the new, unqueezed matrix size.\r\n *\r\n * @param {Array} array\r\n * @param {number} dims       Desired number of dimensions of the array\r\n * @param {number} [outer]    Number of outer dimensions to be added\r\n * @param {Array} [size] Current size of array.\r\n * @returns {Array} returns the array itself\r\n * @private\r\n */\r\nexport function unsqueeze(array, dims, outer, size) {\r\n  var s = size || arraySize(array);\r\n\r\n  // unsqueeze outer dimensions\r\n  if (outer) {\r\n    for (var i = 0; i < outer; i++) {\r\n      array = [array];\r\n      s.unshift(1);\r\n    }\r\n  }\r\n\r\n  // unsqueeze inner dimensions\r\n  array = _unsqueeze(array, dims, 0);\r\n  while (s.length < dims) {\r\n    s.push(1);\r\n  }\r\n  return array;\r\n}\r\n\r\n/**\r\n * Recursively unsqueeze a multi dimensional array\r\n * @param {Array} array\r\n * @param {number} dims Required number of dimensions\r\n * @param {number} dim  Current dimension\r\n * @returns {Array | *} Returns the squeezed array\r\n * @private\r\n */\r\nfunction _unsqueeze(array, dims, dim) {\r\n  var i, ii;\r\n  if (Array.isArray(array)) {\r\n    var next = dim + 1;\r\n    for (i = 0, ii = array.length; i < ii; i++) {\r\n      array[i] = _unsqueeze(array[i], dims, next);\r\n    }\r\n  } else {\r\n    for (var d = dim; d < dims; d++) {\r\n      array = [array];\r\n    }\r\n  }\r\n  return array;\r\n}\r\n/**\r\n * Flatten a multi dimensional array, put all elements in a one dimensional\r\n * array\r\n * @param {Array} array   A multi dimensional array\r\n * @return {Array}        The flattened array (1 dimensional)\r\n */\r\nexport function flatten(array) {\r\n  if (!Array.isArray(array)) {\r\n    // if not an array, return as is\r\n    return array;\r\n  }\r\n  var flat = [];\r\n  array.forEach(function callback(value) {\r\n    if (Array.isArray(value)) {\r\n      value.forEach(callback); // traverse through sub-arrays recursively\r\n    } else {\r\n      flat.push(value);\r\n    }\r\n  });\r\n  return flat;\r\n}\r\n\r\n/**\r\n * A safe map\r\n * @param {Array} array\r\n * @param {function} callback\r\n */\r\nexport function map(array, callback) {\r\n  return Array.prototype.map.call(array, callback);\r\n}\r\n\r\n/**\r\n * A safe forEach\r\n * @param {Array} array\r\n * @param {function} callback\r\n */\r\nexport function forEach(array, callback) {\r\n  Array.prototype.forEach.call(array, callback);\r\n}\r\n\r\n/**\r\n * A safe filter\r\n * @param {Array} array\r\n * @param {function} callback\r\n */\r\nexport function filter(array, callback) {\r\n  if (arraySize(array).length !== 1) {\r\n    throw new Error('Only one dimensional matrices supported');\r\n  }\r\n  return Array.prototype.filter.call(array, callback);\r\n}\r\n\r\n/**\r\n * Filter values in a callback given a regular expression\r\n * @param {Array} array\r\n * @param {RegExp} regexp\r\n * @return {Array} Returns the filtered array\r\n * @private\r\n */\r\nexport function filterRegExp(array, regexp) {\r\n  if (arraySize(array).length !== 1) {\r\n    throw new Error('Only one dimensional matrices supported');\r\n  }\r\n  return Array.prototype.filter.call(array, entry => regexp.test(entry));\r\n}\r\n\r\n/**\r\n * A safe join\r\n * @param {Array} array\r\n * @param {string} separator\r\n */\r\nexport function join(array, separator) {\r\n  return Array.prototype.join.call(array, separator);\r\n}\r\n\r\n/**\r\n * Assign a numeric identifier to every element of a sorted array\r\n * @param {Array} a  An array\r\n * @return {Array} An array of objects containing the original value and its identifier\r\n */\r\nexport function identify(a) {\r\n  if (!Array.isArray(a)) {\r\n    throw new TypeError('Array input expected');\r\n  }\r\n  if (a.length === 0) {\r\n    return a;\r\n  }\r\n  var b = [];\r\n  var count = 0;\r\n  b[0] = {\r\n    value: a[0],\r\n    identifier: 0\r\n  };\r\n  for (var i = 1; i < a.length; i++) {\r\n    if (a[i] === a[i - 1]) {\r\n      count++;\r\n    } else {\r\n      count = 0;\r\n    }\r\n    b.push({\r\n      value: a[i],\r\n      identifier: count\r\n    });\r\n  }\r\n  return b;\r\n}\r\n\r\n/**\r\n * Remove the numeric identifier from the elements\r\n * @param {array} a  An array\r\n * @return {array} An array of values without identifiers\r\n */\r\nexport function generalize(a) {\r\n  if (!Array.isArray(a)) {\r\n    throw new TypeError('Array input expected');\r\n  }\r\n  if (a.length === 0) {\r\n    return a;\r\n  }\r\n  var b = [];\r\n  for (var i = 0; i < a.length; i++) {\r\n    b.push(a[i].value);\r\n  }\r\n  return b;\r\n}\r\n\r\n/**\r\n * Check the datatype of a given object\r\n * This is a low level implementation that should only be used by\r\n * parent Matrix classes such as SparseMatrix or DenseMatrix\r\n * This method does not validate Array Matrix shape\r\n * @param {Array} array\r\n * @param {function} typeOf   Callback function to use to determine the type of a value\r\n * @return {string}\r\n */\r\nexport function getArrayDataType(array, typeOf) {\r\n  var type; // to hold type info\r\n  var length = 0; // to hold length value to ensure it has consistent sizes\r\n\r\n  for (var i = 0; i < array.length; i++) {\r\n    var item = array[i];\r\n    var isArray = Array.isArray(item);\r\n\r\n    // Saving the target matrix row size\r\n    if (i === 0 && isArray) {\r\n      length = item.length;\r\n    }\r\n\r\n    // If the current item is an array but the length does not equal the targetVectorSize\r\n    if (isArray && item.length !== length) {\r\n      return undefined;\r\n    }\r\n    var itemType = isArray ? getArrayDataType(item, typeOf) // recurse into a nested array\r\n    : typeOf(item);\r\n    if (type === undefined) {\r\n      type = itemType; // first item\r\n    } else if (type !== itemType) {\r\n      return 'mixed';\r\n    } else {\r\n      // we're good, everything has the same type so far\r\n    }\r\n  }\r\n  return type;\r\n}\r\n\r\n/**\r\n * Return the last item from an array\r\n * @param array\r\n * @returns {*}\r\n */\r\nexport function last(array) {\r\n  return array[array.length - 1];\r\n}\r\n\r\n/**\r\n * Get all but the last element of array.\r\n */\r\nexport function initial(array) {\r\n  return array.slice(0, array.length - 1);\r\n}\r\n\r\n/**\r\n * Test whether an array or string contains an item\r\n * @param {Array | string} array\r\n * @param {*} item\r\n * @return {boolean}\r\n */\r\nexport function contains(array, item) {\r\n  return array.indexOf(item) !== -1;\r\n}"]},"metadata":{},"sourceType":"module"}