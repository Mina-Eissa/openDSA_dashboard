{"ast":null,"code":"import { factory } from '../../../utils/factory.js';\nimport { extend } from '../../../utils/object.js';\nimport { createMatAlgo13xDD } from './matAlgo13xDD.js';\nimport { createMatAlgo14xDs } from './matAlgo14xDs.js';\nimport { createBroadcast } from './broadcast.js';\nvar name = 'matrixAlgorithmSuite';\nvar dependencies = ['typed', 'matrix', 'concat'];\nexport var createMatrixAlgorithmSuite = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    matrix,\n    concat\n  } = _ref;\n  var matAlgo13xDD = createMatAlgo13xDD({\n    typed\n  });\n  var matAlgo14xDs = createMatAlgo14xDs({\n    typed\n  });\n  var broadcast = createBroadcast({\n    concat\n  });\n  /**\r\n   * Return a signatures object with the usual boilerplate of\r\n   * matrix algorithms, based on a plain options object with the\r\n   * following properties:\r\n   *   elop: function -- the elementwise operation to use, defaults to self\r\n   *   SS: function -- the algorithm to apply for two sparse matrices\r\n   *   DS: function -- the algorithm to apply for a dense and a sparse matrix\r\n   *   SD: function -- algo for a sparse and a dense; defaults to SD flipped\r\n   *   Ss: function -- the algorithm to apply for a sparse matrix and scalar\r\n   *   sS: function -- algo for scalar and sparse; defaults to Ss flipped\r\n   *   scalar: string -- typed-function type for scalars, defaults to 'any'\r\n   *\r\n   * If Ss is not specified, no matrix-scalar signatures are generated.\r\n   *\r\n   * @param {object} options\r\n   * @return {Object<string, function>} signatures\r\n   */\n\n  return function matrixAlgorithmSuite(options) {\n    var elop = options.elop;\n    var SD = options.SD || options.DS;\n    var matrixSignatures;\n\n    if (elop) {\n      // First the dense ones\n      matrixSignatures = {\n        'DenseMatrix, DenseMatrix': (x, y) => matAlgo13xDD(...broadcast(x, y), elop),\n        'Array, Array': (x, y) => matAlgo13xDD(...broadcast(matrix(x), matrix(y)), elop).valueOf(),\n        'Array, DenseMatrix': (x, y) => matAlgo13xDD(...broadcast(matrix(x), y), elop),\n        'DenseMatrix, Array': (x, y) => matAlgo13xDD(...broadcast(x, matrix(y)), elop)\n      }; // Now incorporate sparse matrices\n\n      if (options.SS) {\n        matrixSignatures['SparseMatrix, SparseMatrix'] = (x, y) => options.SS(...broadcast(x, y), elop, false);\n      }\n\n      if (options.DS) {\n        matrixSignatures['DenseMatrix, SparseMatrix'] = (x, y) => options.DS(...broadcast(x, y), elop, false);\n\n        matrixSignatures['Array, SparseMatrix'] = (x, y) => options.DS(...broadcast(matrix(x), y), elop, false);\n      }\n\n      if (SD) {\n        matrixSignatures['SparseMatrix, DenseMatrix'] = (x, y) => SD(...broadcast(y, x), elop, true);\n\n        matrixSignatures['SparseMatrix, Array'] = (x, y) => SD(...broadcast(matrix(y), x), elop, true);\n      }\n    } else {\n      // No elop, use this\n      // First the dense ones\n      matrixSignatures = {\n        'DenseMatrix, DenseMatrix': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(...broadcast(x, y), self);\n        }),\n        'Array, Array': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(...broadcast(matrix(x), matrix(y)), self).valueOf();\n        }),\n        'Array, DenseMatrix': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(...broadcast(matrix(x), y), self);\n        }),\n        'DenseMatrix, Array': typed.referToSelf(self => (x, y) => {\n          return matAlgo13xDD(...broadcast(x, matrix(y)), self);\n        })\n      }; // Now incorporate sparse matrices\n\n      if (options.SS) {\n        matrixSignatures['SparseMatrix, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return options.SS(...broadcast(x, y), self, false);\n        });\n      }\n\n      if (options.DS) {\n        matrixSignatures['DenseMatrix, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return options.DS(...broadcast(x, y), self, false);\n        });\n        matrixSignatures['Array, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return options.DS(...broadcast(matrix(x), y), self, false);\n        });\n      }\n\n      if (SD) {\n        matrixSignatures['SparseMatrix, DenseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return SD(...broadcast(y, x), self, true);\n        });\n        matrixSignatures['SparseMatrix, Array'] = typed.referToSelf(self => (x, y) => {\n          return SD(...broadcast(matrix(y), x), self, true);\n        });\n      }\n    } // Now add the scalars\n\n\n    var scalar = options.scalar || 'any';\n    var Ds = options.Ds || options.Ss;\n\n    if (Ds) {\n      if (elop) {\n        matrixSignatures['DenseMatrix,' + scalar] = (x, y) => matAlgo14xDs(x, y, elop, false);\n\n        matrixSignatures[scalar + ', DenseMatrix'] = (x, y) => matAlgo14xDs(y, x, elop, true);\n\n        matrixSignatures['Array,' + scalar] = (x, y) => matAlgo14xDs(matrix(x), y, elop, false).valueOf();\n\n        matrixSignatures[scalar + ', Array'] = (x, y) => matAlgo14xDs(matrix(y), x, elop, true).valueOf();\n      } else {\n        matrixSignatures['DenseMatrix,' + scalar] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(x, y, self, false);\n        });\n        matrixSignatures[scalar + ', DenseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(y, x, self, true);\n        });\n        matrixSignatures['Array,' + scalar] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(matrix(x), y, self, false).valueOf();\n        });\n        matrixSignatures[scalar + ', Array'] = typed.referToSelf(self => (x, y) => {\n          return matAlgo14xDs(matrix(y), x, self, true).valueOf();\n        });\n      }\n    }\n\n    var sS = options.sS !== undefined ? options.sS : options.Ss;\n\n    if (elop) {\n      if (options.Ss) {\n        matrixSignatures['SparseMatrix,' + scalar] = (x, y) => options.Ss(x, y, elop, false);\n      }\n\n      if (sS) {\n        matrixSignatures[scalar + ', SparseMatrix'] = (x, y) => sS(y, x, elop, true);\n      }\n    } else {\n      if (options.Ss) {\n        matrixSignatures['SparseMatrix,' + scalar] = typed.referToSelf(self => (x, y) => {\n          return options.Ss(x, y, self, false);\n        });\n      }\n\n      if (sS) {\n        matrixSignatures[scalar + ', SparseMatrix'] = typed.referToSelf(self => (x, y) => {\n          return sS(y, x, self, true);\n        });\n      }\n    } // Also pull in the scalar signatures if the operator is a typed function\n\n\n    if (elop && elop.signatures) {\n      extend(matrixSignatures, elop.signatures);\n    }\n\n    return matrixSignatures;\n  };\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js"],"names":["factory","extend","createMatAlgo13xDD","createMatAlgo14xDs","createBroadcast","name","dependencies","createMatrixAlgorithmSuite","_ref","typed","matrix","concat","matAlgo13xDD","matAlgo14xDs","broadcast","matrixAlgorithmSuite","options","elop","SD","DS","matrixSignatures","x","y","valueOf","SS","referToSelf","self","scalar","Ds","Ss","sS","undefined","signatures"],"mappings":"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","sourcesContent":["import { factory } from '../../../utils/factory.js';\r\nimport { extend } from '../../../utils/object.js';\r\nimport { createMatAlgo13xDD } from './matAlgo13xDD.js';\r\nimport { createMatAlgo14xDs } from './matAlgo14xDs.js';\r\nimport { createBroadcast } from './broadcast.js';\r\nvar name = 'matrixAlgorithmSuite';\r\nvar dependencies = ['typed', 'matrix', 'concat'];\r\nexport var createMatrixAlgorithmSuite = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    typed,\r\n    matrix,\r\n    concat\r\n  } = _ref;\r\n  var matAlgo13xDD = createMatAlgo13xDD({\r\n    typed\r\n  });\r\n  var matAlgo14xDs = createMatAlgo14xDs({\r\n    typed\r\n  });\r\n  var broadcast = createBroadcast({\r\n    concat\r\n  });\r\n\r\n  /**\r\n   * Return a signatures object with the usual boilerplate of\r\n   * matrix algorithms, based on a plain options object with the\r\n   * following properties:\r\n   *   elop: function -- the elementwise operation to use, defaults to self\r\n   *   SS: function -- the algorithm to apply for two sparse matrices\r\n   *   DS: function -- the algorithm to apply for a dense and a sparse matrix\r\n   *   SD: function -- algo for a sparse and a dense; defaults to SD flipped\r\n   *   Ss: function -- the algorithm to apply for a sparse matrix and scalar\r\n   *   sS: function -- algo for scalar and sparse; defaults to Ss flipped\r\n   *   scalar: string -- typed-function type for scalars, defaults to 'any'\r\n   *\r\n   * If Ss is not specified, no matrix-scalar signatures are generated.\r\n   *\r\n   * @param {object} options\r\n   * @return {Object<string, function>} signatures\r\n   */\r\n  return function matrixAlgorithmSuite(options) {\r\n    var elop = options.elop;\r\n    var SD = options.SD || options.DS;\r\n    var matrixSignatures;\r\n    if (elop) {\r\n      // First the dense ones\r\n      matrixSignatures = {\r\n        'DenseMatrix, DenseMatrix': (x, y) => matAlgo13xDD(...broadcast(x, y), elop),\r\n        'Array, Array': (x, y) => matAlgo13xDD(...broadcast(matrix(x), matrix(y)), elop).valueOf(),\r\n        'Array, DenseMatrix': (x, y) => matAlgo13xDD(...broadcast(matrix(x), y), elop),\r\n        'DenseMatrix, Array': (x, y) => matAlgo13xDD(...broadcast(x, matrix(y)), elop)\r\n      };\r\n      // Now incorporate sparse matrices\r\n      if (options.SS) {\r\n        matrixSignatures['SparseMatrix, SparseMatrix'] = (x, y) => options.SS(...broadcast(x, y), elop, false);\r\n      }\r\n      if (options.DS) {\r\n        matrixSignatures['DenseMatrix, SparseMatrix'] = (x, y) => options.DS(...broadcast(x, y), elop, false);\r\n        matrixSignatures['Array, SparseMatrix'] = (x, y) => options.DS(...broadcast(matrix(x), y), elop, false);\r\n      }\r\n      if (SD) {\r\n        matrixSignatures['SparseMatrix, DenseMatrix'] = (x, y) => SD(...broadcast(y, x), elop, true);\r\n        matrixSignatures['SparseMatrix, Array'] = (x, y) => SD(...broadcast(matrix(y), x), elop, true);\r\n      }\r\n    } else {\r\n      // No elop, use this\r\n      // First the dense ones\r\n      matrixSignatures = {\r\n        'DenseMatrix, DenseMatrix': typed.referToSelf(self => (x, y) => {\r\n          return matAlgo13xDD(...broadcast(x, y), self);\r\n        }),\r\n        'Array, Array': typed.referToSelf(self => (x, y) => {\r\n          return matAlgo13xDD(...broadcast(matrix(x), matrix(y)), self).valueOf();\r\n        }),\r\n        'Array, DenseMatrix': typed.referToSelf(self => (x, y) => {\r\n          return matAlgo13xDD(...broadcast(matrix(x), y), self);\r\n        }),\r\n        'DenseMatrix, Array': typed.referToSelf(self => (x, y) => {\r\n          return matAlgo13xDD(...broadcast(x, matrix(y)), self);\r\n        })\r\n      };\r\n      // Now incorporate sparse matrices\r\n      if (options.SS) {\r\n        matrixSignatures['SparseMatrix, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\r\n          return options.SS(...broadcast(x, y), self, false);\r\n        });\r\n      }\r\n      if (options.DS) {\r\n        matrixSignatures['DenseMatrix, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\r\n          return options.DS(...broadcast(x, y), self, false);\r\n        });\r\n        matrixSignatures['Array, SparseMatrix'] = typed.referToSelf(self => (x, y) => {\r\n          return options.DS(...broadcast(matrix(x), y), self, false);\r\n        });\r\n      }\r\n      if (SD) {\r\n        matrixSignatures['SparseMatrix, DenseMatrix'] = typed.referToSelf(self => (x, y) => {\r\n          return SD(...broadcast(y, x), self, true);\r\n        });\r\n        matrixSignatures['SparseMatrix, Array'] = typed.referToSelf(self => (x, y) => {\r\n          return SD(...broadcast(matrix(y), x), self, true);\r\n        });\r\n      }\r\n    }\r\n\r\n    // Now add the scalars\r\n    var scalar = options.scalar || 'any';\r\n    var Ds = options.Ds || options.Ss;\r\n    if (Ds) {\r\n      if (elop) {\r\n        matrixSignatures['DenseMatrix,' + scalar] = (x, y) => matAlgo14xDs(x, y, elop, false);\r\n        matrixSignatures[scalar + ', DenseMatrix'] = (x, y) => matAlgo14xDs(y, x, elop, true);\r\n        matrixSignatures['Array,' + scalar] = (x, y) => matAlgo14xDs(matrix(x), y, elop, false).valueOf();\r\n        matrixSignatures[scalar + ', Array'] = (x, y) => matAlgo14xDs(matrix(y), x, elop, true).valueOf();\r\n      } else {\r\n        matrixSignatures['DenseMatrix,' + scalar] = typed.referToSelf(self => (x, y) => {\r\n          return matAlgo14xDs(x, y, self, false);\r\n        });\r\n        matrixSignatures[scalar + ', DenseMatrix'] = typed.referToSelf(self => (x, y) => {\r\n          return matAlgo14xDs(y, x, self, true);\r\n        });\r\n        matrixSignatures['Array,' + scalar] = typed.referToSelf(self => (x, y) => {\r\n          return matAlgo14xDs(matrix(x), y, self, false).valueOf();\r\n        });\r\n        matrixSignatures[scalar + ', Array'] = typed.referToSelf(self => (x, y) => {\r\n          return matAlgo14xDs(matrix(y), x, self, true).valueOf();\r\n        });\r\n      }\r\n    }\r\n    var sS = options.sS !== undefined ? options.sS : options.Ss;\r\n    if (elop) {\r\n      if (options.Ss) {\r\n        matrixSignatures['SparseMatrix,' + scalar] = (x, y) => options.Ss(x, y, elop, false);\r\n      }\r\n      if (sS) {\r\n        matrixSignatures[scalar + ', SparseMatrix'] = (x, y) => sS(y, x, elop, true);\r\n      }\r\n    } else {\r\n      if (options.Ss) {\r\n        matrixSignatures['SparseMatrix,' + scalar] = typed.referToSelf(self => (x, y) => {\r\n          return options.Ss(x, y, self, false);\r\n        });\r\n      }\r\n      if (sS) {\r\n        matrixSignatures[scalar + ', SparseMatrix'] = typed.referToSelf(self => (x, y) => {\r\n          return sS(y, x, self, true);\r\n        });\r\n      }\r\n    }\r\n    // Also pull in the scalar signatures if the operator is a typed function\r\n    if (elop && elop.signatures) {\r\n      extend(matrixSignatures, elop.signatures);\r\n    }\r\n    return matrixSignatures;\r\n  };\r\n});"]},"metadata":{},"sourceType":"module"}