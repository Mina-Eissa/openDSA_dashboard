{"ast":null,"code":"import { csPermute } from './csPermute.js';\nimport { csPost } from './csPost.js';\nimport { csEtree } from './csEtree.js';\nimport { createCsAmd } from './csAmd.js';\nimport { createCsCounts } from './csCounts.js';\nimport { factory } from '../../../utils/factory.js';\nvar name = 'csSqr';\nvar dependencies = ['add', 'multiply', 'transpose'];\nexport var createCsSqr = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    add,\n    multiply,\n    transpose\n  } = _ref;\n  var csAmd = createCsAmd({\n    add,\n    multiply,\n    transpose\n  });\n  var csCounts = createCsCounts({\n    transpose\n  });\n  /**\r\n   * Symbolic ordering and analysis for QR and LU decompositions.\r\n   *\r\n   * @param {Number}  order           The ordering strategy (see csAmd for more details)\r\n   * @param {Matrix}  a               The A matrix\r\n   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or\r\n   *                                  symbolic ordering and analysis for LU decomposition (false)\r\n   *\r\n   * @return {Object}                 The Symbolic ordering and analysis for matrix A\r\n   *\r\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n   */\n\n  return function csSqr(order, a, qr) {\n    // a arrays\n    var aptr = a._ptr;\n    var asize = a._size; // columns\n\n    var n = asize[1]; // vars\n\n    var k; // symbolic analysis result\n\n    var s = {}; // fill-reducing ordering\n\n    s.q = csAmd(order, a); // validate results\n\n    if (order && !s.q) {\n      return null;\n    } // QR symbolic analysis\n\n\n    if (qr) {\n      // apply permutations if needed\n      var c = order ? csPermute(a, null, s.q, 0) : a; // etree of C'*C, where C=A(:,q)\n\n      s.parent = csEtree(c, 1); // post order elimination tree\n\n      var post = csPost(s.parent, n); // col counts chol(C'*C)\n\n      s.cp = csCounts(c, s.parent, post, 1); // check we have everything needed to calculate number of nonzero elements\n\n      if (c && s.parent && s.cp && _vcount(c, s)) {\n        // calculate number of nonzero elements\n        for (s.unz = 0, k = 0; k < n; k++) {\n          s.unz += s.cp[k];\n        }\n      }\n    } else {\n      // for LU factorization only, guess nnz(L) and nnz(U)\n      s.unz = 4 * aptr[n] + n;\n      s.lnz = s.unz;\n    } // return result S\n\n\n    return s;\n  };\n  /**\r\n   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent\r\n   */\n\n  function _vcount(a, s) {\n    // a arrays\n    var aptr = a._ptr;\n    var aindex = a._index;\n    var asize = a._size; // rows & columns\n\n    var m = asize[0];\n    var n = asize[1]; // initialize s arrays\n\n    s.pinv = []; // (m + n)\n\n    s.leftmost = []; // (m)\n    // vars\n\n    var parent = s.parent;\n    var pinv = s.pinv;\n    var leftmost = s.leftmost; // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries\n\n    var w = []; // (m + 3 * n)\n\n    var next = 0;\n    var head = m;\n    var tail = m + n;\n    var nque = m + 2 * n; // vars\n\n    var i, k, p, p0, p1; // initialize w\n\n    for (k = 0; k < n; k++) {\n      // queue k is empty\n      w[head + k] = -1;\n      w[tail + k] = -1;\n      w[nque + k] = 0;\n    } // initialize row arrays\n\n\n    for (i = 0; i < m; i++) {\n      leftmost[i] = -1;\n    } // loop columns backwards\n\n\n    for (k = n - 1; k >= 0; k--) {\n      // values & index for column k\n      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\n        // leftmost[i] = min(find(A(i,:)))\n        leftmost[aindex[p]] = k;\n      }\n    } // scan rows in reverse order\n\n\n    for (i = m - 1; i >= 0; i--) {\n      // row i is not yet ordered\n      pinv[i] = -1;\n      k = leftmost[i]; // check row i is empty\n\n      if (k === -1) {\n        continue;\n      } // first row in queue k\n\n\n      if (w[nque + k]++ === 0) {\n        w[tail + k] = i;\n      } // put i at head of queue k\n\n\n      w[next + i] = w[head + k];\n      w[head + k] = i;\n    }\n\n    s.lnz = 0;\n    s.m2 = m; // find row permutation and nnz(V)\n\n    for (k = 0; k < n; k++) {\n      // remove row i from queue k\n      i = w[head + k]; // count V(k,k) as nonzero\n\n      s.lnz++; // add a fictitious row\n\n      if (i < 0) {\n        i = s.m2++;\n      } // associate row i with V(:,k)\n\n\n      pinv[i] = k; // skip if V(k+1:m,k) is empty\n\n      if (--nque[k] <= 0) {\n        continue;\n      } // nque[k] is nnz (V(k+1:m,k))\n\n\n      s.lnz += w[nque + k]; // move all rows to parent of k\n\n      var pa = parent[k];\n\n      if (pa !== -1) {\n        if (w[nque + pa] === 0) {\n          w[tail + pa] = w[tail + k];\n        }\n\n        w[next + w[tail + k]] = w[head + pa];\n        w[head + pa] = w[next + i];\n        w[nque + pa] += w[nque + k];\n      }\n    }\n\n    for (i = 0; i < m; i++) {\n      if (pinv[i] < 0) {\n        pinv[i] = k++;\n      }\n    }\n\n    return true;\n  }\n});","map":{"version":3,"sources":["C:/Users/x/Desktop/openDSA/openDSA_dashboard/project/node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js"],"names":["csPermute","csPost","csEtree","createCsAmd","createCsCounts","factory","name","dependencies","createCsSqr","_ref","add","multiply","transpose","csAmd","csCounts","csSqr","order","a","qr","aptr","_ptr","asize","_size","n","k","s","q","c","parent","post","cp","_vcount","unz","lnz","aindex","_index","m","pinv","leftmost","w","next","head","tail","nque","i","p","p0","p1","m2","pa"],"mappings":"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","sourcesContent":["import { csPermute } from './csPermute.js';\r\nimport { csPost } from './csPost.js';\r\nimport { csEtree } from './csEtree.js';\r\nimport { createCsAmd } from './csAmd.js';\r\nimport { createCsCounts } from './csCounts.js';\r\nimport { factory } from '../../../utils/factory.js';\r\nvar name = 'csSqr';\r\nvar dependencies = ['add', 'multiply', 'transpose'];\r\nexport var createCsSqr = /* #__PURE__ */factory(name, dependencies, _ref => {\r\n  var {\r\n    add,\r\n    multiply,\r\n    transpose\r\n  } = _ref;\r\n  var csAmd = createCsAmd({\r\n    add,\r\n    multiply,\r\n    transpose\r\n  });\r\n  var csCounts = createCsCounts({\r\n    transpose\r\n  });\r\n\r\n  /**\r\n   * Symbolic ordering and analysis for QR and LU decompositions.\r\n   *\r\n   * @param {Number}  order           The ordering strategy (see csAmd for more details)\r\n   * @param {Matrix}  a               The A matrix\r\n   * @param {boolean} qr              Symbolic ordering and analysis for QR decomposition (true) or\r\n   *                                  symbolic ordering and analysis for LU decomposition (false)\r\n   *\r\n   * @return {Object}                 The Symbolic ordering and analysis for matrix A\r\n   *\r\n   * Reference: http://faculty.cse.tamu.edu/davis/publications.html\r\n   */\r\n  return function csSqr(order, a, qr) {\r\n    // a arrays\r\n    var aptr = a._ptr;\r\n    var asize = a._size;\r\n    // columns\r\n    var n = asize[1];\r\n    // vars\r\n    var k;\r\n    // symbolic analysis result\r\n    var s = {};\r\n    // fill-reducing ordering\r\n    s.q = csAmd(order, a);\r\n    // validate results\r\n    if (order && !s.q) {\r\n      return null;\r\n    }\r\n    // QR symbolic analysis\r\n    if (qr) {\r\n      // apply permutations if needed\r\n      var c = order ? csPermute(a, null, s.q, 0) : a;\r\n      // etree of C'*C, where C=A(:,q)\r\n      s.parent = csEtree(c, 1);\r\n      // post order elimination tree\r\n      var post = csPost(s.parent, n);\r\n      // col counts chol(C'*C)\r\n      s.cp = csCounts(c, s.parent, post, 1);\r\n      // check we have everything needed to calculate number of nonzero elements\r\n      if (c && s.parent && s.cp && _vcount(c, s)) {\r\n        // calculate number of nonzero elements\r\n        for (s.unz = 0, k = 0; k < n; k++) {\r\n          s.unz += s.cp[k];\r\n        }\r\n      }\r\n    } else {\r\n      // for LU factorization only, guess nnz(L) and nnz(U)\r\n      s.unz = 4 * aptr[n] + n;\r\n      s.lnz = s.unz;\r\n    }\r\n    // return result S\r\n    return s;\r\n  };\r\n\r\n  /**\r\n   * Compute nnz(V) = s.lnz, s.pinv, s.leftmost, s.m2 from A and s.parent\r\n   */\r\n  function _vcount(a, s) {\r\n    // a arrays\r\n    var aptr = a._ptr;\r\n    var aindex = a._index;\r\n    var asize = a._size;\r\n    // rows & columns\r\n    var m = asize[0];\r\n    var n = asize[1];\r\n    // initialize s arrays\r\n    s.pinv = []; // (m + n)\r\n    s.leftmost = []; // (m)\r\n    // vars\r\n    var parent = s.parent;\r\n    var pinv = s.pinv;\r\n    var leftmost = s.leftmost;\r\n    // workspace, next: first m entries, head: next n entries, tail: next n entries, nque: next n entries\r\n    var w = []; // (m + 3 * n)\r\n    var next = 0;\r\n    var head = m;\r\n    var tail = m + n;\r\n    var nque = m + 2 * n;\r\n    // vars\r\n    var i, k, p, p0, p1;\r\n    // initialize w\r\n    for (k = 0; k < n; k++) {\r\n      // queue k is empty\r\n      w[head + k] = -1;\r\n      w[tail + k] = -1;\r\n      w[nque + k] = 0;\r\n    }\r\n    // initialize row arrays\r\n    for (i = 0; i < m; i++) {\r\n      leftmost[i] = -1;\r\n    }\r\n    // loop columns backwards\r\n    for (k = n - 1; k >= 0; k--) {\r\n      // values & index for column k\r\n      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {\r\n        // leftmost[i] = min(find(A(i,:)))\r\n        leftmost[aindex[p]] = k;\r\n      }\r\n    }\r\n    // scan rows in reverse order\r\n    for (i = m - 1; i >= 0; i--) {\r\n      // row i is not yet ordered\r\n      pinv[i] = -1;\r\n      k = leftmost[i];\r\n      // check row i is empty\r\n      if (k === -1) {\r\n        continue;\r\n      }\r\n      // first row in queue k\r\n      if (w[nque + k]++ === 0) {\r\n        w[tail + k] = i;\r\n      }\r\n      // put i at head of queue k\r\n      w[next + i] = w[head + k];\r\n      w[head + k] = i;\r\n    }\r\n    s.lnz = 0;\r\n    s.m2 = m;\r\n    // find row permutation and nnz(V)\r\n    for (k = 0; k < n; k++) {\r\n      // remove row i from queue k\r\n      i = w[head + k];\r\n      // count V(k,k) as nonzero\r\n      s.lnz++;\r\n      // add a fictitious row\r\n      if (i < 0) {\r\n        i = s.m2++;\r\n      }\r\n      // associate row i with V(:,k)\r\n      pinv[i] = k;\r\n      // skip if V(k+1:m,k) is empty\r\n      if (--nque[k] <= 0) {\r\n        continue;\r\n      }\r\n      // nque[k] is nnz (V(k+1:m,k))\r\n      s.lnz += w[nque + k];\r\n      // move all rows to parent of k\r\n      var pa = parent[k];\r\n      if (pa !== -1) {\r\n        if (w[nque + pa] === 0) {\r\n          w[tail + pa] = w[tail + k];\r\n        }\r\n        w[next + w[tail + k]] = w[head + pa];\r\n        w[head + pa] = w[next + i];\r\n        w[nque + pa] += w[nque + k];\r\n      }\r\n    }\r\n    for (i = 0; i < m; i++) {\r\n      if (pinv[i] < 0) {\r\n        pinv[i] = k++;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n});"]},"metadata":{},"sourceType":"module"}